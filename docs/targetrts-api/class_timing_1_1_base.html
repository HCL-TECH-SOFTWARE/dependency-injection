<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C++ TargetRTS: Timing::Base Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C++ TargetRTS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="struct_timing.html">Timing</a></li><li class="navelem"><a class="el" href="class_timing_1_1_base.html">Base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_timing_1_1_base-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Timing::Base Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Represents a timer port.  
 <a href="class_timing_1_1_base.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_r_t_timing_8h_source.html">RTTiming.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Timing::Base:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_timing_1_1_base.png" usemap="#Timing::Base_map" alt=""/>
  <map id="Timing::Base_map" name="Timing::Base_map">
<area href="class_r_t_protocol.html" title="Represents a general capsule port typed by a protocol which determines the set of events that can be ..." alt="RTProtocol" shape="rect" coords="0,0,82,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad13f91cd2ebd0fe7e89ad49b0e3f2872"><td class="memItemLeft" align="right" valign="top"><a id="ad13f91cd2ebd0fe7e89ad49b0e3f2872" name="ad13f91cd2ebd0fe7e89ad49b0e3f2872"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>rti_timeout</b> = rtiLast_RTProtocol + 1
 }</td></tr>
<tr class="separator:ad13f91cd2ebd0fe7e89ad49b0e3f2872"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9f4d6ae276c90d3bc10e39cecb1e2665"><td class="memItemLeft" align="right" valign="top"><a id="a9f4d6ae276c90d3bc10e39cecb1e2665" name="a9f4d6ae276c90d3bc10e39cecb1e2665"></a>
<a class="el" href="struct_r_t_in_signal.html">RTInSignal</a>&#160;</td><td class="memItemRight" valign="bottom"><b>timeout</b> (void)</td></tr>
<tr class="memdesc:a9f4d6ae276c90d3bc10e39cecb1e2665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the object that represents the timeout event which is received by this port when the timer has expired. <br /></td></tr>
<tr class="separator:a9f4d6ae276c90d3bc10e39cecb1e2665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20293cbdee413498ff2b1bba7aa8076"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_r_t_timespec.html">RTTimespec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_timing_1_1_base.html#ad20293cbdee413498ff2b1bba7aa8076">currentTime</a> (void) const</td></tr>
<tr class="memdesc:ad20293cbdee413498ff2b1bba7aa8076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current time.  <br /></td></tr>
<tr class="separator:ad20293cbdee413498ff2b1bba7aa8076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6234730bb7bd2cc2854c529c56a27960"><td class="memItemLeft" align="right" valign="top">RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_timing_1_1_base.html#a6234730bb7bd2cc2854c529c56a27960">informAt</a> (const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;when, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, int prio=General)</td></tr>
<tr class="memdesc:a6234730bb7bd2cc2854c529c56a27960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a timer which will expire at a particular absolute point in time.  <br /></td></tr>
<tr class="separator:a6234730bb7bd2cc2854c529c56a27960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3ec79232d1983533602032e7a9abac"><td class="memItemLeft" align="right" valign="top"><a id="a3c3ec79232d1983533602032e7a9abac" name="a3c3ec79232d1983533602032e7a9abac"></a>
RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><b>informAt</b> (const std::chrono::system_clock::time_point &amp;when, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, int prio=General)</td></tr>
<tr class="separator:a3c3ec79232d1983533602032e7a9abac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf003166a9927a0eb69a62546df61a7"><td class="memItemLeft" align="right" valign="top">RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_timing_1_1_base.html#abbf003166a9927a0eb69a62546df61a7">informAt</a> (const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;when, int prio=General)</td></tr>
<tr class="memdesc:abbf003166a9927a0eb69a62546df61a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a timer which will expire at a particular absolute point in time.  <br /></td></tr>
<tr class="separator:abbf003166a9927a0eb69a62546df61a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff945cbd834b8efdff4a660427a1304"><td class="memItemLeft" align="right" valign="top"><a id="a2ff945cbd834b8efdff4a660427a1304" name="a2ff945cbd834b8efdff4a660427a1304"></a>
RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><b>informAt</b> (const std::chrono::system_clock::time_point &amp;when, int prio=General)</td></tr>
<tr class="separator:a2ff945cbd834b8efdff4a660427a1304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80223a317545dbcfe3c196cd0cd9208"><td class="memItemLeft" align="right" valign="top">RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_timing_1_1_base.html#af80223a317545dbcfe3c196cd0cd9208">informAt</a> (const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;when, const <a class="el" href="class_r_t_data_object.html">RTDataObject</a> &amp;data, int prio=General)</td></tr>
<tr class="memdesc:af80223a317545dbcfe3c196cd0cd9208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a timer which will expire at a particular absolute point in time.  <br /></td></tr>
<tr class="separator:af80223a317545dbcfe3c196cd0cd9208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ebbe43264ba65c9be38c2b707250c6a"><td class="memItemLeft" align="right" valign="top"><a id="a6ebbe43264ba65c9be38c2b707250c6a" name="a6ebbe43264ba65c9be38c2b707250c6a"></a>
RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><b>informAt</b> (const std::chrono::system_clock::time_point &amp;when, const <a class="el" href="class_r_t_data_object.html">RTDataObject</a> &amp;data, int prio=General)</td></tr>
<tr class="separator:a6ebbe43264ba65c9be38c2b707250c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5dc6fc6ccc18e6b1da2b7c468e1f53"><td class="memItemLeft" align="right" valign="top">RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_timing_1_1_base.html#a4d5dc6fc6ccc18e6b1da2b7c468e1f53">informAt</a> (const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;when, const <a class="el" href="struct_r_t_typed_value.html">RTTypedValue</a> &amp;info, int prio=General)</td></tr>
<tr class="memdesc:a4d5dc6fc6ccc18e6b1da2b7c468e1f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a timer which will expire at a particular absolute point in time.  <br /></td></tr>
<tr class="separator:a4d5dc6fc6ccc18e6b1da2b7c468e1f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcae7f2268b0664cfc260d434e9d121f"><td class="memItemLeft" align="right" valign="top"><a id="adcae7f2268b0664cfc260d434e9d121f" name="adcae7f2268b0664cfc260d434e9d121f"></a>
RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><b>informAt</b> (const std::chrono::system_clock::time_point &amp;when, const <a class="el" href="struct_r_t_typed_value.html">RTTypedValue</a> &amp;info, int prio=General)</td></tr>
<tr class="separator:adcae7f2268b0664cfc260d434e9d121f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ab3b67ce5ddcc31da835f9b1db2aba"><td class="memItemLeft" align="right" valign="top">RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_timing_1_1_base.html#a43ab3b67ce5ddcc31da835f9b1db2aba">informIn</a> (const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;delta, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, int prio=General)</td></tr>
<tr class="memdesc:a43ab3b67ce5ddcc31da835f9b1db2aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a timer which will expire after a specified time interval.  <br /></td></tr>
<tr class="separator:a43ab3b67ce5ddcc31da835f9b1db2aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f0b5efe8b252d26b0dc068a5dfc0dd"><td class="memItemLeft" align="right" valign="top"><a id="a63f0b5efe8b252d26b0dc068a5dfc0dd" name="a63f0b5efe8b252d26b0dc068a5dfc0dd"></a>
RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><b>informIn</b> (const std::chrono::nanoseconds &amp;delta_ns, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, int prio=General)</td></tr>
<tr class="separator:a63f0b5efe8b252d26b0dc068a5dfc0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef685bfbbc8506ca31067b5f2c48d710"><td class="memItemLeft" align="right" valign="top">RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_timing_1_1_base.html#aef685bfbbc8506ca31067b5f2c48d710">informIn</a> (const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;delta, int prio=General)</td></tr>
<tr class="memdesc:aef685bfbbc8506ca31067b5f2c48d710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a timer which will expire after a specified time interval.  <br /></td></tr>
<tr class="separator:aef685bfbbc8506ca31067b5f2c48d710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3033f6046d367ba6cbf3887525f62ed6"><td class="memItemLeft" align="right" valign="top"><a id="a3033f6046d367ba6cbf3887525f62ed6" name="a3033f6046d367ba6cbf3887525f62ed6"></a>
RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><b>informIn</b> (const std::chrono::nanoseconds &amp;delta_ns, int prio=General)</td></tr>
<tr class="separator:a3033f6046d367ba6cbf3887525f62ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976a99d8f925c6a3e6e73c50c5818aee"><td class="memItemLeft" align="right" valign="top">RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_timing_1_1_base.html#a976a99d8f925c6a3e6e73c50c5818aee">informIn</a> (const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;delta, const <a class="el" href="class_r_t_data_object.html">RTDataObject</a> &amp;data, int prio=General)</td></tr>
<tr class="memdesc:a976a99d8f925c6a3e6e73c50c5818aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a timer which will expire after a specified time interval.  <br /></td></tr>
<tr class="separator:a976a99d8f925c6a3e6e73c50c5818aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01373ef48e9da9fc47354d3337da6fd"><td class="memItemLeft" align="right" valign="top"><a id="ac01373ef48e9da9fc47354d3337da6fd" name="ac01373ef48e9da9fc47354d3337da6fd"></a>
RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><b>informIn</b> (const std::chrono::nanoseconds &amp;delta_ns, const <a class="el" href="class_r_t_data_object.html">RTDataObject</a> &amp;data, int prio=General)</td></tr>
<tr class="separator:ac01373ef48e9da9fc47354d3337da6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5b230ea0ea15be80e3263b8df65299"><td class="memItemLeft" align="right" valign="top">RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_timing_1_1_base.html#a7f5b230ea0ea15be80e3263b8df65299">informIn</a> (const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;delta, const <a class="el" href="struct_r_t_typed_value.html">RTTypedValue</a> &amp;info, int prio=General)</td></tr>
<tr class="memdesc:a7f5b230ea0ea15be80e3263b8df65299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a timer which will expire after a specified time interval.  <br /></td></tr>
<tr class="separator:a7f5b230ea0ea15be80e3263b8df65299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4ff7705cc67367bfdaee0650417a2f"><td class="memItemLeft" align="right" valign="top"><a id="ace4ff7705cc67367bfdaee0650417a2f" name="ace4ff7705cc67367bfdaee0650417a2f"></a>
RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><b>informIn</b> (const std::chrono::nanoseconds &amp;delta_ns, const <a class="el" href="struct_r_t_typed_value.html">RTTypedValue</a> &amp;info, int prio=General)</td></tr>
<tr class="separator:ace4ff7705cc67367bfdaee0650417a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2d0d5da71be32ef7511a1a23ad5655"><td class="memItemLeft" align="right" valign="top"><a id="a5b2d0d5da71be32ef7511a1a23ad5655" name="a5b2d0d5da71be32ef7511a1a23ad5655"></a>
RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><b>informIn</b> (unsigned long centiseconds, int prio=General)</td></tr>
<tr class="separator:a5b2d0d5da71be32ef7511a1a23ad5655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d76c8558bc435abab4143073a88098"><td class="memItemLeft" align="right" valign="top"><a id="aa3d76c8558bc435abab4143073a88098" name="aa3d76c8558bc435abab4143073a88098"></a>
RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><b>informIn</b> (unsigned long centiseconds, const <a class="el" href="class_r_t_data_object.html">RTDataObject</a> &amp;data, int prio=General)</td></tr>
<tr class="separator:aa3d76c8558bc435abab4143073a88098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734b2a1d86ccbe2a67422673bfe7a22c"><td class="memItemLeft" align="right" valign="top"><a id="a734b2a1d86ccbe2a67422673bfe7a22c" name="a734b2a1d86ccbe2a67422673bfe7a22c"></a>
RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><b>informIn</b> (unsigned long centiseconds, const <a class="el" href="struct_r_t_typed_value.html">RTTypedValue</a> &amp;info, int prio=General)</td></tr>
<tr class="separator:a734b2a1d86ccbe2a67422673bfe7a22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8c3bc750c974b8e1c697599e7559a3"><td class="memItemLeft" align="right" valign="top">RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_timing_1_1_base.html#abf8c3bc750c974b8e1c697599e7559a3">informEvery</a> (const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;delta, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, int prio=General)</td></tr>
<tr class="memdesc:abf8c3bc750c974b8e1c697599e7559a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a periodic timer which will expire at regular intervals.  <br /></td></tr>
<tr class="separator:abf8c3bc750c974b8e1c697599e7559a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e3d4ce84e8511ca8e391146841135b"><td class="memItemLeft" align="right" valign="top"><a id="ae0e3d4ce84e8511ca8e391146841135b" name="ae0e3d4ce84e8511ca8e391146841135b"></a>
RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><b>informEvery</b> (const std::chrono::nanoseconds &amp;delta_ns, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, int prio=General)</td></tr>
<tr class="separator:ae0e3d4ce84e8511ca8e391146841135b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96f6cc50a7ad94d659ad1fffc6d5de2"><td class="memItemLeft" align="right" valign="top">RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_timing_1_1_base.html#aa96f6cc50a7ad94d659ad1fffc6d5de2">informEvery</a> (const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;delta, const <a class="el" href="class_r_t_data_object.html">RTDataObject</a> &amp;data, int prio=General)</td></tr>
<tr class="memdesc:aa96f6cc50a7ad94d659ad1fffc6d5de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a periodic timer which will expire at regular intervals.  <br /></td></tr>
<tr class="separator:aa96f6cc50a7ad94d659ad1fffc6d5de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff2aa9db9e7c6e4d6c55f9bde3c2d17"><td class="memItemLeft" align="right" valign="top"><a id="a0ff2aa9db9e7c6e4d6c55f9bde3c2d17" name="a0ff2aa9db9e7c6e4d6c55f9bde3c2d17"></a>
RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><b>informEvery</b> (const std::chrono::nanoseconds &amp;delta_ns, const <a class="el" href="class_r_t_data_object.html">RTDataObject</a> &amp;data, int prio=General)</td></tr>
<tr class="separator:a0ff2aa9db9e7c6e4d6c55f9bde3c2d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5d9a1ea01666a1d4187a99841819e4"><td class="memItemLeft" align="right" valign="top">RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_timing_1_1_base.html#a8e5d9a1ea01666a1d4187a99841819e4">informEvery</a> (const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;delta, const <a class="el" href="struct_r_t_typed_value.html">RTTypedValue</a> &amp;info, int prio=General)</td></tr>
<tr class="memdesc:a8e5d9a1ea01666a1d4187a99841819e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a periodic timer which will expire at regular intervals.  <br /></td></tr>
<tr class="separator:a8e5d9a1ea01666a1d4187a99841819e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e2249a147b510f6f7d3104757ac254"><td class="memItemLeft" align="right" valign="top"><a id="ad8e2249a147b510f6f7d3104757ac254" name="ad8e2249a147b510f6f7d3104757ac254"></a>
RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><b>informEvery</b> (const std::chrono::nanoseconds &amp;delta_ns, const <a class="el" href="struct_r_t_typed_value.html">RTTypedValue</a> &amp;info, int prio=General)</td></tr>
<tr class="separator:ad8e2249a147b510f6f7d3104757ac254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229d954c70c9d15da564b592c2e7e35d"><td class="memItemLeft" align="right" valign="top">RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_timing_1_1_base.html#a229d954c70c9d15da564b592c2e7e35d">informEvery</a> (const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;delta)</td></tr>
<tr class="memdesc:a229d954c70c9d15da564b592c2e7e35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a periodic timer which will expire at regular intervals.  <br /></td></tr>
<tr class="separator:a229d954c70c9d15da564b592c2e7e35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e16002533bc6ae3b14a742b3a5078fa"><td class="memItemLeft" align="right" valign="top"><a id="a3e16002533bc6ae3b14a742b3a5078fa" name="a3e16002533bc6ae3b14a742b3a5078fa"></a>
RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><b>informEvery</b> (const std::chrono::nanoseconds &amp;delta_ns)</td></tr>
<tr class="separator:a3e16002533bc6ae3b14a742b3a5078fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1694fd19b6f0a0bfb66e208197ffb4bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_timing_1_1_base.html#a1694fd19b6f0a0bfb66e208197ffb4bc">timeouts</a> (const <a class="el" href="class_r_t_timer_id.html">RTTimerId</a> &amp;id)</td></tr>
<tr class="memdesc:a1694fd19b6f0a0bfb66e208197ffb4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of timeout intervals that passed before the timeout of a periodic timer was actually processed.  <br /></td></tr>
<tr class="separator:a1694fd19b6f0a0bfb66e208197ffb4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975860973ae11ea49f1c8502149456a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_timing_1_1_base.html#a975860973ae11ea49f1c8502149456a9">cancelTimer</a> (<a class="el" href="class_r_t_timer_id.html">RTTimerId</a> &amp;id)</td></tr>
<tr class="memdesc:a975860973ae11ea49f1c8502149456a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a timer.  <br /></td></tr>
<tr class="separator:a975860973ae11ea49f1c8502149456a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749c3f090bacbb2528cc9e3842318a67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_timing_1_1_base.html#a749c3f090bacbb2528cc9e3842318a67">adjustTimeBegin</a> (void)</td></tr>
<tr class="memdesc:a749c3f090bacbb2528cc9e3842318a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin adjustment of system time.  <br /></td></tr>
<tr class="separator:a749c3f090bacbb2528cc9e3842318a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a58a305c0cb374acf54ea85daef87b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_timing_1_1_base.html#a19a58a305c0cb374acf54ea85daef87b">adjustTimeEnd</a> (const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;delta)</td></tr>
<tr class="memdesc:a19a58a305c0cb374acf54ea85daef87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">End adjustment of system time.  <br /></td></tr>
<tr class="separator:a19a58a305c0cb374acf54ea85daef87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_r_t_protocol"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_r_t_protocol')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_r_t_protocol.html">RTProtocol</a></td></tr>
<tr class="memitem:a02358053723895c6423f73ec97d5fe24 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_t_controller.html">RTController</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a02358053723895c6423f73ec97d5fe24">context</a> (void) const</td></tr>
<tr class="memdesc:a02358053723895c6423f73ec97d5fe24 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the context of the capsule that owns this port.  <br /></td></tr>
<tr class="separator:a02358053723895c6423f73ec97d5fe24 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7569d7ad23ba8a40313ebc91aee92cc4 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a7569d7ad23ba8a40313ebc91aee92cc4">getId</a> (void) const</td></tr>
<tr class="memdesc:a7569d7ad23ba8a40313ebc91aee92cc4 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of the port.  <br /></td></tr>
<tr class="separator:a7569d7ad23ba8a40313ebc91aee92cc4 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13996e31840891910920c9880670edf inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_r_t_port_descriptor.html">RTPortDescriptor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ab13996e31840891910920c9880670edf">getInfo</a> (void) const</td></tr>
<tr class="memdesc:ab13996e31840891910920c9880670edf inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about a port.  <br /></td></tr>
<tr class="separator:ab13996e31840891910920c9880670edf inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee715e514169058cc688ef652ec41f83 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aee715e514169058cc688ef652ec41f83">getName</a> (void) const</td></tr>
<tr class="memdesc:aee715e514169058cc688ef652ec41f83 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the port.  <br /></td></tr>
<tr class="separator:aee715e514169058cc688ef652ec41f83 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6545f036888aeacaab36096f4e876ff inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_t_actor.html">RTActor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#af6545f036888aeacaab36096f4e876ff">getOwner</a> (void) const</td></tr>
<tr class="memdesc:af6545f036888aeacaab36096f4e876ff inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the owner capsule to which the port belongs.  <br /></td></tr>
<tr class="separator:af6545f036888aeacaab36096f4e876ff inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf5a22f8232f12cd60a969523946889 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a1bf5a22f8232f12cd60a969523946889">size</a> (void) const</td></tr>
<tr class="memdesc:a1bf5a22f8232f12cd60a969523946889 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the port.  <br /></td></tr>
<tr class="separator:a1bf5a22f8232f12cd60a969523946889 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef50658d6d1246dee65718b70b1a2088 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aef50658d6d1246dee65718b70b1a2088">resize</a> (int new_size)</td></tr>
<tr class="memdesc:aef50658d6d1246dee65718b70b1a2088 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new size (i.e.  <br /></td></tr>
<tr class="separator:aef50658d6d1246dee65718b70b1a2088 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35cd8130dde852d13d7953419349a11 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#af35cd8130dde852d13d7953419349a11">registerSAP</a> (const char *service)</td></tr>
<tr class="memdesc:af35cd8130dde852d13d7953419349a11 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an unwired port (SAP) with the layer service (as a "client").  <br /></td></tr>
<tr class="separator:af35cd8130dde852d13d7953419349a11 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e580b53c346f4a623b2864fcc8e344b inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a5e580b53c346f4a623b2864fcc8e344b">deregisterSAP</a> (void)</td></tr>
<tr class="memdesc:a5e580b53c346f4a623b2864fcc8e344b inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister an unwired port (SAP).  <br /></td></tr>
<tr class="separator:a5e580b53c346f4a623b2864fcc8e344b inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb58413ecb8836fe47aa6c0069fb3cf inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aabb58413ecb8836fe47aa6c0069fb3cf">registerSPP</a> (const char *service)</td></tr>
<tr class="memdesc:aabb58413ecb8836fe47aa6c0069fb3cf inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an unwired port (SPP) with the layer service (as the "provider").  <br /></td></tr>
<tr class="separator:aabb58413ecb8836fe47aa6c0069fb3cf inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71503e6d0ec280fa95ea813db29f41e inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aa71503e6d0ec280fa95ea813db29f41e">deregisterSPP</a> (void)</td></tr>
<tr class="memdesc:aa71503e6d0ec280fa95ea813db29f41e inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister an unwired port (SPP).  <br /></td></tr>
<tr class="separator:aa71503e6d0ec280fa95ea813db29f41e inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d430e4ee11ed7438cb77d60faaba91f inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a0d430e4ee11ed7438cb77d60faaba91f">defaultLayerName</a> (void) const</td></tr>
<tr class="memdesc:a0d430e4ee11ed7438cb77d60faaba91f inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default registration name for the port.  <br /></td></tr>
<tr class="separator:a0d430e4ee11ed7438cb77d60faaba91f inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c47b94180b9f30bf3e25bcfa55fe0d0 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a2c47b94180b9f30bf3e25bcfa55fe0d0">isRegistered</a> (void) const</td></tr>
<tr class="memdesc:a2c47b94180b9f30bf3e25bcfa55fe0d0 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the port is currently registered with the layer service or not.  <br /></td></tr>
<tr class="separator:a2c47b94180b9f30bf3e25bcfa55fe0d0 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4759bbdb8fcd25545f463a9caf15961d inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a4759bbdb8fcd25545f463a9caf15961d">getRegisteredName</a> (void) const</td></tr>
<tr class="memdesc:a4759bbdb8fcd25545f463a9caf15961d inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the registration name of the port.  <br /></td></tr>
<tr class="separator:a4759bbdb8fcd25545f463a9caf15961d inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0dafbdb3f5339378036a1f9800ac8b8 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ad0dafbdb3f5339378036a1f9800ac8b8">registerAs</a> (const char *service)</td></tr>
<tr class="memdesc:ad0dafbdb3f5339378036a1f9800ac8b8 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an unwired port either as an SAP or SPP (depending on the "Publish" property set on the port in the model).  <br /></td></tr>
<tr class="separator:ad0dafbdb3f5339378036a1f9800ac8b8 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed18e2ea1cd805cf48df1c4dda1a56df inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aed18e2ea1cd805cf48df1c4dda1a56df">deregister</a> (void)</td></tr>
<tr class="memdesc:aed18e2ea1cd805cf48df1c4dda1a56df inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister an unwired port (either an SAP or SPP).  <br /></td></tr>
<tr class="separator:aed18e2ea1cd805cf48df1c4dda1a56df inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae364dd3d1d73dda4146f77cadd708d53 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ae364dd3d1d73dda4146f77cadd708d53">isBoundAt</a> (int index) const</td></tr>
<tr class="memdesc:ae364dd3d1d73dda4146f77cadd708d53 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a port instance is currently connected to another port instance.  <br /></td></tr>
<tr class="separator:ae364dd3d1d73dda4146f77cadd708d53 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2765cfbbe1295b939a47ea0b9be991c inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ab2765cfbbe1295b939a47ea0b9be991c">isIndexTo</a> (int index, <a class="el" href="class_r_t_actor.html">RTActor</a> *capsule) const</td></tr>
<tr class="memdesc:ab2765cfbbe1295b939a47ea0b9be991c inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a port instance is currently connected to a port instance owned by a certain capsule instance.  <br /></td></tr>
<tr class="separator:ab2765cfbbe1295b939a47ea0b9be991c inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f251e8160558cf5ae295a59cfab1202 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a7f251e8160558cf5ae295a59cfab1202">indexTo</a> (<a class="el" href="class_r_t_actor.html">RTActor</a> *capsule) const</td></tr>
<tr class="memdesc:a7f251e8160558cf5ae295a59cfab1202 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if there exists a port instance currently connected to a port instance owned by a certain capsule instance.  <br /></td></tr>
<tr class="separator:a7f251e8160558cf5ae295a59cfab1202 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9150bfbf17314443453d429c8f113553 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a9150bfbf17314443453d429c8f113553">purge</a> (void)</td></tr>
<tr class="memdesc:a9150bfbf17314443453d429c8f113553 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the defer queue of all port instances without recalling any deferred message.  <br /></td></tr>
<tr class="separator:a9150bfbf17314443453d429c8f113553 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2703f40abf6a8df9bbd730215c8c23e7 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a2703f40abf6a8df9bbd730215c8c23e7">purgeAt</a> (int index)</td></tr>
<tr class="memdesc:a2703f40abf6a8df9bbd730215c8c23e7 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the defer queue of a specified port instance without recalling any deferred message.  <br /></td></tr>
<tr class="separator:a2703f40abf6a8df9bbd730215c8c23e7 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775cee0be2a2cfd90b58b2cc3ec0f86e inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a775cee0be2a2cfd90b58b2cc3ec0f86e">recall</a> (void)</td></tr>
<tr class="memdesc:a775cee0be2a2cfd90b58b2cc3ec0f86e inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall a message from the defer queue and insert it at the back of the controller's message queue (after other queued messages).  <br /></td></tr>
<tr class="separator:a775cee0be2a2cfd90b58b2cc3ec0f86e inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae611db0412a09055815ac9717394f303 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ae611db0412a09055815ac9717394f303">recallFront</a> (void)</td></tr>
<tr class="memdesc:ae611db0412a09055815ac9717394f303 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall a message from the defer queue and insert it at the front of the controller's message queue (before other queued messages).  <br /></td></tr>
<tr class="separator:ae611db0412a09055815ac9717394f303 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7cfcb42423fc78b60f48f7220c0779 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a9f7cfcb42423fc78b60f48f7220c0779">recallAt</a> (int index, int front=0)</td></tr>
<tr class="memdesc:a9f7cfcb42423fc78b60f48f7220c0779 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall a message from the defer queue and insert it in the controller's message queue.  <br /></td></tr>
<tr class="separator:a9f7cfcb42423fc78b60f48f7220c0779 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc92df9cafd7c04372916ee4ef6c5c3c inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#afc92df9cafd7c04372916ee4ef6c5c3c">recallAll</a> (void)</td></tr>
<tr class="memdesc:afc92df9cafd7c04372916ee4ef6c5c3c inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall all messages from the defer queue and insert them at the back of the controller's message queue (after other queued messages).  <br /></td></tr>
<tr class="separator:afc92df9cafd7c04372916ee4ef6c5c3c inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70638165fd32d634670c2c2f174a3c3b inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a70638165fd32d634670c2c2f174a3c3b">recallAllFront</a> (void)</td></tr>
<tr class="memdesc:a70638165fd32d634670c2c2f174a3c3b inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall all messages from the defer queue and insert them at the front of the controller's message queue (before other queued messages).  <br /></td></tr>
<tr class="separator:a70638165fd32d634670c2c2f174a3c3b inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627afae9906e70cea7fc182bfb5f7cb8 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a627afae9906e70cea7fc182bfb5f7cb8">recallAllAt</a> (int index, int front=0)</td></tr>
<tr class="memdesc:a627afae9906e70cea7fc182bfb5f7cb8 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall all messages from the defer queue and insert them in the controller's message queue.  <br /></td></tr>
<tr class="separator:a627afae9906e70cea7fc182bfb5f7cb8 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b78477128d033d1e1f4c797ef0caf6 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a56b78477128d033d1e1f4c797ef0caf6">bindingNotification</a> (int on_off)</td></tr>
<tr class="memdesc:a56b78477128d033d1e1f4c797ef0caf6 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on or off binding notifications for this port.  <br /></td></tr>
<tr class="separator:a56b78477128d033d1e1f4c797ef0caf6 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb72eaea84b5ce02ebf4393d1768c21 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#adcb72eaea84b5ce02ebf4393d1768c21">bindingNotificationRequested</a> (void) const</td></tr>
<tr class="memdesc:adcb72eaea84b5ce02ebf4393d1768c21 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if binding notifications are currently enabled for the port.  <br /></td></tr>
<tr class="separator:adcb72eaea84b5ce02ebf4393d1768c21 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d444f5ca3150bf91f56cf1637623307 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a2d444f5ca3150bf91f56cf1637623307">sendTypeCheckEnable</a> (int on_off)</td></tr>
<tr class="memdesc:a2d444f5ca3150bf91f56cf1637623307 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on or off type checking when performing <a class="el" href="class_r_t_protocol.html#a4b38472435fc60256e4a4f2d0234c9de" title="Send an event on the port.">send()</a>, <a class="el" href="class_r_t_protocol.html#a4fba0c4760d48842f11d891b416f3ef9" title="Invoke an event on the port.">invoke()</a> or <a class="el" href="class_r_t_protocol.html#a6458de033f1ecf9f60de9b7745dc376f" title="Make a reply to respond to an invoke.">reply()</a> on the port.  <br /></td></tr>
<tr class="separator:a2d444f5ca3150bf91f56cf1637623307 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880d97d0e3b87ac9ea00bb2f6eaf0d56 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a880d97d0e3b87ac9ea00bb2f6eaf0d56">sendTypeCheckEnabled</a> (void) const</td></tr>
<tr class="memdesc:a880d97d0e3b87ac9ea00bb2f6eaf0d56 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if type checking when sending events is enabled.  <br /></td></tr>
<tr class="separator:a880d97d0e3b87ac9ea00bb2f6eaf0d56 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2a9a51d2ec8c9f97dd6eb8e8370aaa inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">RTProtocolDescriptor::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a1d2a9a51d2ec8c9f97dd6eb8e8370aaa">sendCheck</a> (int signal, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type) const</td></tr>
<tr class="memdesc:a1d2a9a51d2ec8c9f97dd6eb8e8370aaa inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a particular event would be possible to send on this port.  <br /></td></tr>
<tr class="separator:a1d2a9a51d2ec8c9f97dd6eb8e8370aaa inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac415448c9272ba92ead19c6e97c806bd inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ac415448c9272ba92ead19c6e97c806bd">receiveTypeCheckEnable</a> (int on_off)</td></tr>
<tr class="memdesc:ac415448c9272ba92ead19c6e97c806bd inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on or off type checking when receiving an event on the port.  <br /></td></tr>
<tr class="separator:ac415448c9272ba92ead19c6e97c806bd inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e0bd91743d6720c1ea3426074314e7 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a74e0bd91743d6720c1ea3426074314e7">receiveTypeCheckEnabled</a> (void) const</td></tr>
<tr class="memdesc:a74e0bd91743d6720c1ea3426074314e7 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if type checking when receiving events is enabled.  <br /></td></tr>
<tr class="separator:a74e0bd91743d6720c1ea3426074314e7 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ad300424f58e0f6325fdee64fe02d8 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">RTProtocolDescriptor::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aa2ad300424f58e0f6325fdee64fe02d8">receiveCheck</a> (int signal, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type) const</td></tr>
<tr class="memdesc:aa2ad300424f58e0f6325fdee64fe02d8 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a particular event would be possible to receive on this port.  <br /></td></tr>
<tr class="separator:aa2ad300424f58e0f6325fdee64fe02d8 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fba0c4760d48842f11d891b416f3ef9 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a4fba0c4760d48842f11d891b416f3ef9">invoke</a> (<a class="el" href="class_r_t_message.html">RTMessage</a> *replyBuffer, int signal, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, bool implicitReply)</td></tr>
<tr class="memdesc:a4fba0c4760d48842f11d891b416f3ef9 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke an event on the port.  <br /></td></tr>
<tr class="separator:a4fba0c4760d48842f11d891b416f3ef9 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c5eae9cdc5ab117f9332b41964bcf7 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aa3c5eae9cdc5ab117f9332b41964bcf7">invokeAt</a> (int index, <a class="el" href="class_r_t_message.html">RTMessage</a> *replyBuffer, int signal, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, bool implicitReply)</td></tr>
<tr class="memdesc:aa3c5eae9cdc5ab117f9332b41964bcf7 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke an event on a replicated port at a specified index.  <br /></td></tr>
<tr class="separator:aa3c5eae9cdc5ab117f9332b41964bcf7 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6458de033f1ecf9f60de9b7745dc376f inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a6458de033f1ecf9f60de9b7745dc376f">reply</a> (int signal, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type)</td></tr>
<tr class="memdesc:a6458de033f1ecf9f60de9b7745dc376f inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a reply to respond to an invoke.  <br /></td></tr>
<tr class="separator:a6458de033f1ecf9f60de9b7745dc376f inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b38472435fc60256e4a4f2d0234c9de inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a4b38472435fc60256e4a4f2d0234c9de">send</a> (int signal, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, int priority, bool moveData=false)</td></tr>
<tr class="memdesc:a4b38472435fc60256e4a4f2d0234c9de inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an event on the port.  <br /></td></tr>
<tr class="separator:a4b38472435fc60256e4a4f2d0234c9de inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d071f7137ca82a8ffd7c8e589c3114 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a77d071f7137ca82a8ffd7c8e589c3114">sendAt</a> (int index, int signal, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, int priority, bool moveData=false)</td></tr>
<tr class="memdesc:a77d071f7137ca82a8ffd7c8e589c3114 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an event on a replicated port at a specified index.  <br /></td></tr>
<tr class="separator:a77d071f7137ca82a8ffd7c8e589c3114 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a1a11ad90fcc801b912a471959845d483"><td class="memItemLeft" align="right" valign="top"><a id="a1a11ad90fcc801b912a471959845d483" name="a1a11ad90fcc801b912a471959845d483"></a>
static const <a class="el" href="struct_r_t_protocol_descriptor.html">RTProtocolDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rt_class</b></td></tr>
<tr class="separator:a1a11ad90fcc801b912a471959845d483"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a95b9db6eb971790b031b98bb6e65b6e9"><td class="memItemLeft" align="right" valign="top"><a id="a95b9db6eb971790b031b98bb6e65b6e9" name="a95b9db6eb971790b031b98bb6e65b6e9"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>rtiLast_Timing</b> = rti_timeout
 }</td></tr>
<tr class="separator:a95b9db6eb971790b031b98bb6e65b6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_class_r_t_protocol"><td colspan="2" onclick="javascript:toggleInherit('pro_types_class_r_t_protocol')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="class_r_t_protocol.html">RTProtocol</a></td></tr>
<tr class="memitem:a6dc9f620cde1f39e1a8ef8c9ff1350e9 inherit pro_types_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="a6dc9f620cde1f39e1a8ef8c9ff1350e9" name="a6dc9f620cde1f39e1a8ef8c9ff1350e9"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>BindingNotification</b> = 1
, <b>RegisteredAsSAP</b> = 2
, <b>SendTypeCheck</b> = 4
, <b>ReceiveTypeCheck</b> = 8
, <br />
&#160;&#160;<b>Resized</b> = 16
<br />
 }</td></tr>
<tr class="separator:a6dc9f620cde1f39e1a8ef8c9ff1350e9 inherit pro_types_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf537db66f86337bdc9dad4e91e86ec8 inherit pro_types_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="abf537db66f86337bdc9dad4e91e86ec8" name="abf537db66f86337bdc9dad4e91e86ec8"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>rtiLast_RTProtocol</b> = 0
 }</td></tr>
<tr class="separator:abf537db66f86337bdc9dad4e91e86ec8 inherit pro_types_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0dce1faa272f1d93adb2ed06d72dc49b"><td class="memItemLeft" align="right" valign="top"><a id="a0dce1faa272f1d93adb2ed06d72dc49b" name="a0dce1faa272f1d93adb2ed06d72dc49b"></a>
RTTimerNode *&#160;</td><td class="memItemRight" valign="bottom"><b>informIn</b> (const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;when, const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;repeatInterval, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, int prio)</td></tr>
<tr class="separator:a0dce1faa272f1d93adb2ed06d72dc49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_r_t_protocol"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_r_t_protocol')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_r_t_protocol.html">RTProtocol</a></td></tr>
<tr class="memitem:ac7a17e8dc831575b8b324c123af2b0da inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="ac7a17e8dc831575b8b324c123af2b0da" name="ac7a17e8dc831575b8b324c123af2b0da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> (const <a class="el" href="struct_r_t_port_descriptor.html">RTPortDescriptor</a> *)</td></tr>
<tr class="separator:ac7a17e8dc831575b8b324c123af2b0da inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab821319dd07a3ef521765d9260783898 inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="ab821319dd07a3ef521765d9260783898" name="ab821319dd07a3ef521765d9260783898"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getFlags</b> (void) const</td></tr>
<tr class="separator:ab821319dd07a3ef521765d9260783898 inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13b117f2c7538cb426e361fba7426ef inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="ab13b117f2c7538cb426e361fba7426ef" name="ab13b117f2c7538cb426e361fba7426ef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setFlag</b> (int)</td></tr>
<tr class="separator:ab13b117f2c7538cb426e361fba7426ef inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc08d99d20ab533b5079e3aa074e892 inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="acbc08d99d20ab533b5079e3aa074e892" name="acbc08d99d20ab533b5079e3aa074e892"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resetFlag</b> (int)</td></tr>
<tr class="separator:acbc08d99d20ab533b5079e3aa074e892 inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8e009f25cb11e3f94b3e8b1a03e885 inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="a1b8e009f25cb11e3f94b3e8b1a03e885" name="a1b8e009f25cb11e3f94b3e8b1a03e885"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bindAt</b> (int, <a class="el" href="struct_r_t_binding_end.html">RTBindingEnd</a> &amp;, <a class="el" href="class_r_t_controller.html">RTController</a> *)</td></tr>
<tr class="separator:a1b8e009f25cb11e3f94b3e8b1a03e885 inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab999150c4dc37ce4cbc4390b847f39fb inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="ab999150c4dc37ce4cbc4390b847f39fb" name="ab999150c4dc37ce4cbc4390b847f39fb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>peerAt</b> (int, <a class="el" href="struct_r_t_binding_end.html">RTBindingEnd</a> &amp;)</td></tr>
<tr class="separator:ab999150c4dc37ce4cbc4390b847f39fb inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12e8428f1305054a5ddf074f19b595a inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="ae12e8428f1305054a5ddf074f19b595a" name="ae12e8428f1305054a5ddf074f19b595a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unbindAt</b> (int, <a class="el" href="class_r_t_controller.html">RTController</a> *)</td></tr>
<tr class="separator:ae12e8428f1305054a5ddf074f19b595a inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7adb291e96c24590673c557299d052e inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="aa7adb291e96c24590673c557299d052e" name="aa7adb291e96c24590673c557299d052e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>notifyInit</b> (<a class="el" href="class_r_t_controller.html">RTController</a> *)</td></tr>
<tr class="separator:aa7adb291e96c24590673c557299d052e inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2536ee9af988c7bebd23c626cb3f4898 inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="a2536ee9af988c7bebd23c626cb3f4898" name="a2536ee9af988c7bebd23c626cb3f4898"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>notifyBoundAt</b> (int, <a class="el" href="class_r_t_controller.html">RTController</a> *)</td></tr>
<tr class="separator:a2536ee9af988c7bebd23c626cb3f4898 inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad5e51b438ea0273812f4635142530d45"><td class="memItemLeft" align="right" valign="top"><a id="ad5e51b438ea0273812f4635142530d45" name="ad5e51b438ea0273812f4635142530d45"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>RTTimerActor</b></td></tr>
<tr class="separator:ad5e51b438ea0273812f4635142530d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1f12628355b26cb170e26c89d46197"><td class="memItemLeft" align="right" valign="top"><a id="a1b1f12628355b26cb170e26c89d46197" name="a1b1f12628355b26cb170e26c89d46197"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>RTTimerNode</b></td></tr>
<tr class="separator:a1b1f12628355b26cb170e26c89d46197"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a timer port. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a749c3f090bacbb2528cc9e3842318a67" name="a749c3f090bacbb2528cc9e3842318a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749c3f090bacbb2528cc9e3842318a67">&#9670;&#160;</a></span>adjustTimeBegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Timing::Base::adjustTimeBegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin adjustment of system time. </p>
<p>If ever the real-time clock needs to be adjusted it has to be done between calls to <a class="el" href="class_timing_1_1_base.html#a749c3f090bacbb2528cc9e3842318a67" title="Begin adjustment of system time.">adjustTimeBegin()</a> and <a class="el" href="class_timing_1_1_base.html#a19a58a305c0cb374acf54ea85daef87b" title="End adjustment of system time.">adjustTimeEnd()</a> so that the run-time system can be aware of it and make any necessary adjustments to its internal data structures so that relative timeouts (requested via <a class="el" href="class_timing_1_1_base.html#a43ab3b67ce5ddcc31da835f9b1db2aba" title="Start a timer which will expire after a specified time interval.">informIn()</a> or <a class="el" href="class_timing_1_1_base.html#abf8c3bc750c974b8e1c697599e7559a3" title="Start a periodic timer which will expire at regular intervals.">informEvery()</a> calls) are not delayed nor advanced. </p>

</div>
</div>
<a id="a19a58a305c0cb374acf54ea85daef87b" name="a19a58a305c0cb374acf54ea85daef87b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a58a305c0cb374acf54ea85daef87b">&#9670;&#160;</a></span>adjustTimeEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Timing::Base::adjustTimeEnd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End adjustment of system time. </p>
<p>If ever the real-time clock needs to be adjusted it has to be done between calls to <a class="el" href="class_timing_1_1_base.html#a749c3f090bacbb2528cc9e3842318a67" title="Begin adjustment of system time.">adjustTimeBegin()</a> and <a class="el" href="class_timing_1_1_base.html#a19a58a305c0cb374acf54ea85daef87b" title="End adjustment of system time.">adjustTimeEnd()</a> so that the run-time system can be aware of it and make any necessary adjustments to its internal data structures so that relative timeouts (requested via <a class="el" href="class_timing_1_1_base.html#a43ab3b67ce5ddcc31da835f9b1db2aba" title="Start a timer which will expire after a specified time interval.">informIn()</a> or <a class="el" href="class_timing_1_1_base.html#abf8c3bc750c974b8e1c697599e7559a3" title="Start a periodic timer which will expire at regular intervals.">informEvery()</a> calls) are not delayed nor advanced. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>Specifies how the real-time clock was changed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a975860973ae11ea49f1c8502149456a9" name="a975860973ae11ea49f1c8502149456a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975860973ae11ea49f1c8502149456a9">&#9670;&#160;</a></span>cancelTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Timing::Base::cancelTimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_t_timer_id.html">RTTimerId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel a timer. </p>
<p>The function ensures that the timeout event of the specified timer will not be delivered to this timer port. This is true even if the timer already have expired at the time when this function is called, but the timeout event is waiting to be dispatched. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Timer identifier for the timer to be cancelled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if a pending timeout request was cancelled, 0 otherwise. </dd></dl>

</div>
</div>
<a id="ad20293cbdee413498ff2b1bba7aa8076" name="ad20293cbdee413498ff2b1bba7aa8076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20293cbdee413498ff2b1bba7aa8076">&#9670;&#160;</a></span>currentTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_r_t_timespec.html">RTTimespec</a> Timing::Base::currentTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current time. </p>
<p>It is recommended, for performance reasons, to instead use <a class="el" href="struct_r_t_timespec.html#aeadd5a948b4fe3784ad1daeeb1e1267d" title="Get the current time.">RTTimespec::getclock()</a>. </p>

</div>
</div>
<a id="af80223a317545dbcfe3c196cd0cd9208" name="af80223a317545dbcfe3c196cd0cd9208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80223a317545dbcfe3c196cd0cd9208">&#9670;&#160;</a></span>informAt() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTTimerNode * Timing::Base::informAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;&#160;</td>
          <td class="paramname"><em>when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_r_t_data_object.html">RTDataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em> = <code>General</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a timer which will expire at a particular absolute point in time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">when</td><td>The desired absolute time when the timer is to expire. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data object to put in the timeout event. The data is copied by the TargetRTS using the copy function of the type descriptor for the data object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>The priority at which the timeout event should be sent. A message priority is interpreted as its relative importance with respect to all other unprocessed messages on a thread. The priority evaluates to one of the defined global priority values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A timer handle which can be used to construct a timer identifier represented by an <a class="el" href="class_r_t_timer_id.html" title="An identifier for a timer request.">RTTimerId</a>. This object can be used to cancel the timer prior to its expiry. NULL is returned in case the timer request fails. </dd></dl>

</div>
</div>
<a id="a4d5dc6fc6ccc18e6b1da2b7c468e1f53" name="a4d5dc6fc6ccc18e6b1da2b7c468e1f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5dc6fc6ccc18e6b1da2b7c468e1f53">&#9670;&#160;</a></span>informAt() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTTimerNode * Timing::Base::informAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;&#160;</td>
          <td class="paramname"><em>when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_typed_value.html">RTTypedValue</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em> = <code>General</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a timer which will expire at a particular absolute point in time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">when</td><td>The desired absolute time when the timer is to expire. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>An <a class="el" href="struct_r_t_typed_value.html" title="Encapsulates a data object and its type descriptor.">RTTypedValue</a> object which encapsules the data object to put in the timeout event and its type descriptor. The data is copied by the TargetRTS using the copy function of the type descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>The priority at which the timeout event should be sent. A message priority is interpreted as its relative importance with respect to all other unprocessed messages on a thread. The priority evaluates to one of the defined global priority values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A timer handle which can be used to construct a timer identifier represented by an <a class="el" href="class_r_t_timer_id.html" title="An identifier for a timer request.">RTTimerId</a>. This object can be used to cancel the timer prior to its expiry. NULL is returned in case the timer request fails. </dd></dl>

</div>
</div>
<a id="a6234730bb7bd2cc2854c529c56a27960" name="a6234730bb7bd2cc2854c529c56a27960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6234730bb7bd2cc2854c529c56a27960">&#9670;&#160;</a></span>informAt() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTTimerNode * Timing::Base::informAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;&#160;</td>
          <td class="paramname"><em>when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em> = <code>General</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a timer which will expire at a particular absolute point in time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">when</td><td>The desired absolute time when the timer is to expire. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data object to put in the timeout event. The data is copied by the TargetRTS using the copy function of the type descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type descriptor for the data object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>The priority at which the timeout event should be sent. A message priority is interpreted as its relative importance with respect to all other unprocessed messages on a thread. The priority evaluates to one of the defined global priority values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A timer handle which can be used to construct a timer identifier represented by an <a class="el" href="class_r_t_timer_id.html" title="An identifier for a timer request.">RTTimerId</a>. This object can be used to cancel the timer prior to its expiry. NULL is returned in case the timer request fails. </dd></dl>

</div>
</div>
<a id="abbf003166a9927a0eb69a62546df61a7" name="abbf003166a9927a0eb69a62546df61a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf003166a9927a0eb69a62546df61a7">&#9670;&#160;</a></span>informAt() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTTimerNode * Timing::Base::informAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;&#160;</td>
          <td class="paramname"><em>when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em> = <code>General</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a timer which will expire at a particular absolute point in time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">when</td><td>The desired absolute time when the timer is to expire. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>The priority at which the timeout event should be sent. A message priority is interpreted as its relative importance with respect to all other unprocessed messages on a thread. The priority evaluates to one of the defined global priority values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A timer handle which can be used to construct a timer identifier represented by an <a class="el" href="class_r_t_timer_id.html" title="An identifier for a timer request.">RTTimerId</a>. This object can be used to cancel the timer prior to its expiry. NULL is returned in case the timer request fails. </dd></dl>

</div>
</div>
<a id="a229d954c70c9d15da564b592c2e7e35d" name="a229d954c70c9d15da564b592c2e7e35d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229d954c70c9d15da564b592c2e7e35d">&#9670;&#160;</a></span>informEvery() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTTimerNode * Timing::Base::informEvery </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a periodic timer which will expire at regular intervals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>The desired time interval specifying how frequently the timer should expire. If the interval is less than or equal to the current time or equal to zero, the timer will expire immediately. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A timer handle which can be used to construct a timer identifier represented by an <a class="el" href="class_r_t_timer_id.html" title="An identifier for a timer request.">RTTimerId</a>. This object can be used to cancel the timer prior to its expiry. NULL is returned in case the timer request fails. </dd></dl>

</div>
</div>
<a id="aa96f6cc50a7ad94d659ad1fffc6d5de2" name="aa96f6cc50a7ad94d659ad1fffc6d5de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96f6cc50a7ad94d659ad1fffc6d5de2">&#9670;&#160;</a></span>informEvery() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTTimerNode * Timing::Base::informEvery </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_r_t_data_object.html">RTDataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em> = <code>General</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a periodic timer which will expire at regular intervals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>The desired time interval specifying how frequently the timer should expire. If the interval is less than or equal to the current time or equal to zero, the timer will expire immediately. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data object to put in the timeout event. The data is copied by the TargetRTS using the copy function of the type descriptor for the data object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>The priority at which the timeout event should be sent. A message priority is interpreted as its relative importance with respect to all other unprocessed messages on a thread. The priority evaluates to one of the defined global priority values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A timer handle which can be used to construct a timer identifier represented by an <a class="el" href="class_r_t_timer_id.html" title="An identifier for a timer request.">RTTimerId</a>. This object can be used to cancel the timer prior to its expiry. NULL is returned in case the timer request fails. </dd></dl>

</div>
</div>
<a id="a8e5d9a1ea01666a1d4187a99841819e4" name="a8e5d9a1ea01666a1d4187a99841819e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5d9a1ea01666a1d4187a99841819e4">&#9670;&#160;</a></span>informEvery() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTTimerNode * Timing::Base::informEvery </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_typed_value.html">RTTypedValue</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em> = <code>General</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a periodic timer which will expire at regular intervals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>The desired time interval specifying how frequently the timer should expire. If the interval is less than or equal to the current time or equal to zero, the timer will expire immediately. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>An <a class="el" href="struct_r_t_typed_value.html" title="Encapsulates a data object and its type descriptor.">RTTypedValue</a> object which encapsules the data object to put in the timeout event and its type descriptor. The data is copied by the TargetRTS using the copy function of the type descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>The priority at which the timeout event should be sent. A message priority is interpreted as its relative importance with respect to all other unprocessed messages on a thread. The priority evaluates to one of the defined global priority values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A timer handle which can be used to construct a timer identifier represented by an <a class="el" href="class_r_t_timer_id.html" title="An identifier for a timer request.">RTTimerId</a>. This object can be used to cancel the timer prior to its expiry. NULL is returned in case the timer request fails. </dd></dl>

</div>
</div>
<a id="abf8c3bc750c974b8e1c697599e7559a3" name="abf8c3bc750c974b8e1c697599e7559a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8c3bc750c974b8e1c697599e7559a3">&#9670;&#160;</a></span>informEvery() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTTimerNode * Timing::Base::informEvery </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em> = <code>General</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a periodic timer which will expire at regular intervals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>The desired time interval specifying how frequently the timer should expire. If the interval is less than or equal to the current time or equal to zero, the timer will expire immediately. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data object to put in the timeout event. The data is copied by the TargetRTS using the copy function of the type descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type descriptor for the data object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>The priority at which the timeout event should be sent. A message priority is interpreted as its relative importance with respect to all other unprocessed messages on a thread. The priority evaluates to one of the defined global priority values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A timer handle which can be used to construct a timer identifier represented by an <a class="el" href="class_r_t_timer_id.html" title="An identifier for a timer request.">RTTimerId</a>. This object can be used to cancel the timer prior to its expiry. NULL is returned in case the timer request fails. </dd></dl>

</div>
</div>
<a id="a976a99d8f925c6a3e6e73c50c5818aee" name="a976a99d8f925c6a3e6e73c50c5818aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976a99d8f925c6a3e6e73c50c5818aee">&#9670;&#160;</a></span>informIn() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTTimerNode * Timing::Base::informIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_r_t_data_object.html">RTDataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em> = <code>General</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a timer which will expire after a specified time interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>The desired time interval (expressed as a time relative from now) when the timer is to expire. If the interval is less than or equal to the current time or equal to zero, the timer will expire immediately. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data object to put in the timeout event. The data is copied by the TargetRTS using the copy function of the type descriptor for the data object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>The priority at which the timeout event should be sent. A message priority is interpreted as its relative importance with respect to all other unprocessed messages on a thread. The priority evaluates to one of the defined global priority values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A timer handle which can be used to construct a timer identifier represented by an <a class="el" href="class_r_t_timer_id.html" title="An identifier for a timer request.">RTTimerId</a>. This object can be used to cancel the timer prior to its expiry. NULL is returned in case the timer request fails. </dd></dl>

</div>
</div>
<a id="a7f5b230ea0ea15be80e3263b8df65299" name="a7f5b230ea0ea15be80e3263b8df65299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5b230ea0ea15be80e3263b8df65299">&#9670;&#160;</a></span>informIn() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTTimerNode * Timing::Base::informIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_typed_value.html">RTTypedValue</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em> = <code>General</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a timer which will expire after a specified time interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>The desired time interval (expressed as a time relative from now) when the timer is to expire. If the interval is less than or equal to the current time or equal to zero, the timer will expire immediately. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>An <a class="el" href="struct_r_t_typed_value.html" title="Encapsulates a data object and its type descriptor.">RTTypedValue</a> object which encapsules the data object to put in the timeout event and its type descriptor. The data is copied by the TargetRTS using the copy function of the type descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>The priority at which the timeout event should be sent. A message priority is interpreted as its relative importance with respect to all other unprocessed messages on a thread. The priority evaluates to one of the defined global priority values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A timer handle which can be used to construct a timer identifier represented by an <a class="el" href="class_r_t_timer_id.html" title="An identifier for a timer request.">RTTimerId</a>. This object can be used to cancel the timer prior to its expiry. NULL is returned in case the timer request fails. </dd></dl>

</div>
</div>
<a id="a43ab3b67ce5ddcc31da835f9b1db2aba" name="a43ab3b67ce5ddcc31da835f9b1db2aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ab3b67ce5ddcc31da835f9b1db2aba">&#9670;&#160;</a></span>informIn() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTTimerNode * Timing::Base::informIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em> = <code>General</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a timer which will expire after a specified time interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>The desired time interval (expressed as a time relative from now) when the timer is to expire. If the interval is less than or equal to the current time or equal to zero, the timer will expire immediately. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data object to put in the timeout event. The data is copied by the TargetRTS using the copy function of the type descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type descriptor for the data object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>The priority at which the timeout event should be sent. A message priority is interpreted as its relative importance with respect to all other unprocessed messages on a thread. The priority evaluates to one of the defined global priority values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A timer handle which can be used to construct a timer identifier represented by an <a class="el" href="class_r_t_timer_id.html" title="An identifier for a timer request.">RTTimerId</a>. This object can be used to cancel the timer prior to its expiry. NULL is returned in case the timer request fails. </dd></dl>

</div>
</div>
<a id="aef685bfbbc8506ca31067b5f2c48d710" name="aef685bfbbc8506ca31067b5f2c48d710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef685bfbbc8506ca31067b5f2c48d710">&#9670;&#160;</a></span>informIn() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTTimerNode * Timing::Base::informIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_r_t_timespec.html">RTTimespec</a> &amp;&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em> = <code>General</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a timer which will expire after a specified time interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>The desired time interval (expressed as a time relative from now) when the timer is to expire. If the interval is less than or equal to the current time or equal to zero, the timer will expire immediately. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>The priority at which the timeout event should be sent. A message priority is interpreted as its relative importance with respect to all other unprocessed messages on a thread. The priority evaluates to one of the defined global priority values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A timer handle which can be used to construct a timer identifier represented by an <a class="el" href="class_r_t_timer_id.html" title="An identifier for a timer request.">RTTimerId</a>. This object can be used to cancel the timer prior to its expiry. NULL is returned in case the timer request fails. </dd></dl>

</div>
</div>
<a id="a1694fd19b6f0a0bfb66e208197ffb4bc" name="a1694fd19b6f0a0bfb66e208197ffb4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1694fd19b6f0a0bfb66e208197ffb4bc">&#9670;&#160;</a></span>timeouts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Timing::Base::timeouts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_r_t_timer_id.html">RTTimerId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of timeout intervals that passed before the timeout of a periodic timer was actually processed. </p>
<p>Calling this function is a way to measure the accuracy of a periodic timer. The precision of a periodic timer depends on the underlying operating system. If you set a periodic timer with a timeout interval that is small, you may miss certain timeouts simply because the underlying operating system cannot process the timeouts fast enough. This function returns how many timeout intervals that have been missed since the last time a periodic timer expired. NOTE: Setting a timeout frequency higher than the granularity of the operating system means that the memory usage will grow since timeout messages then are produced at a higher pace than what they are consumed. If this goes on for long enough the application will run out of memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Timer identifier for a periodic timer to measure the accuracy of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A measurement of the number of missed timeout intervals since the last time the timer expired. If the timer never has expired 0 is returned. If no interval is missed (i.e. the timer expired at the specified time) 1 is returned. The higher number returned, the less accurate is the timer. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_r_t_timing_8h_source.html">RTTiming.h</a></li>
<li>RTTiming.inl</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
