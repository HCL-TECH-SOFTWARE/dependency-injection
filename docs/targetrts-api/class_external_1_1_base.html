<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C++ TargetRTS: External::Base Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C++ TargetRTS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="struct_external.html">External</a></li><li class="navelem"><a class="el" href="class_external_1_1_base.html">Base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="class_external_1_1_base-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">External::Base Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Represents a port through which an external thread can safely communicate with its owner capsule.  
 <a href="class_external_1_1_base.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_r_t_external_8h_source.html">RTExternal.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for External::Base:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_external_1_1_base.png" usemap="#External::Base_map" alt=""/>
  <map id="External::Base_map" name="External::Base_map">
<area href="class_r_t_protocol.html" title="Represents a general capsule port typed by a protocol which determines the set of events that can be ..." alt="RTProtocol" shape="rect" coords="0,0,92,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aadfcd76fd5c0e04e8e269e0219383124"><td class="memItemLeft" align="right" valign="top"><a id="aadfcd76fd5c0e04e8e269e0219383124" name="aadfcd76fd5c0e04e8e269e0219383124"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>rti_event</b> = rtiLast_RTProtocol + 1
 }</td></tr>
<tr class="separator:aadfcd76fd5c0e04e8e269e0219383124"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a20a21158ffc3d6872879f604b81f314c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_external_1_1_base.html#a20a21158ffc3d6872879f604b81f314c">enable</a> (void)</td></tr>
<tr class="memdesc:a20a21158ffc3d6872879f604b81f314c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the owner capsule to receive an event on the external port.  <br /></td></tr>
<tr class="separator:a20a21158ffc3d6872879f604b81f314c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7c1cdd74f5395d44c420ff5833b378"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_external_1_1_base.html#aab7c1cdd74f5395d44c420ff5833b378">disable</a> (void)</td></tr>
<tr class="memdesc:aab7c1cdd74f5395d44c420ff5833b378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the owner capsule from receiving an event on the external port.  <br /></td></tr>
<tr class="separator:aab7c1cdd74f5395d44c420ff5833b378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f48420dea3566e5b292e16bf7a8a6f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_external_1_1_base.html#a16f48420dea3566e5b292e16bf7a8a6f">raise</a> (const void *data=nullptr, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type=nullptr)</td></tr>
<tr class="memdesc:a16f48420dea3566e5b292e16bf7a8a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an event on the external port.  <br /></td></tr>
<tr class="separator:a16f48420dea3566e5b292e16bf7a8a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e87c64eb0a3330e28d7455ef7c3c1e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_external_1_1_base.html#a6e87c64eb0a3330e28d7455ef7c3c1e9">dataPushBack</a> (void *data)</td></tr>
<tr class="memdesc:a6e87c64eb0a3330e28d7455ef7c3c1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a data object on the external port.  <br /></td></tr>
<tr class="separator:a6e87c64eb0a3330e28d7455ef7c3c1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b68ec01f677002125312be6b6f3069"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_external_1_1_base.html#ab9b68ec01f677002125312be6b6f3069">dataPopFront</a> (void **data)</td></tr>
<tr class="memdesc:ab9b68ec01f677002125312be6b6f3069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the first data object off the list of objects stored on the external port.  <br /></td></tr>
<tr class="separator:ab9b68ec01f677002125312be6b6f3069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f0c2ccc19997bc4b0f3b0915d17a4c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_external_1_1_base.html#a72f0c2ccc19997bc4b0f3b0915d17a4c">dataPopBack</a> (void **data)</td></tr>
<tr class="memdesc:a72f0c2ccc19997bc4b0f3b0915d17a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the last data object off the list of objects stored on the external port.  <br /></td></tr>
<tr class="separator:a72f0c2ccc19997bc4b0f3b0915d17a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04524fb547bb8e4c6ed138e2cc167c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_external_1_1_base.html#af04524fb547bb8e4c6ed138e2cc167c9">dataDelete</a> (void *data)</td></tr>
<tr class="memdesc:af04524fb547bb8e4c6ed138e2cc167c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to find a specific data object in the list of objects stored on the external port.  <br /></td></tr>
<tr class="separator:af04524fb547bb8e4c6ed138e2cc167c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2dda14b76b2e29ca006a697c4d132a"><td class="memItemLeft" align="right" valign="top"><a id="ace2dda14b76b2e29ca006a697c4d132a" name="ace2dda14b76b2e29ca006a697c4d132a"></a>
<a class="el" href="struct_r_t_in_signal.html">RTInSignal</a>&#160;</td><td class="memItemRight" valign="bottom"><b>event</b> (void)</td></tr>
<tr class="memdesc:ace2dda14b76b2e29ca006a697c4d132a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the object that represents the event which can be sent to the external port by an external thread, and received by the thread on which the owner capsule executes. <br /></td></tr>
<tr class="separator:ace2dda14b76b2e29ca006a697c4d132a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_r_t_protocol"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_r_t_protocol')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_r_t_protocol.html">RTProtocol</a></td></tr>
<tr class="memitem:a02358053723895c6423f73ec97d5fe24 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_t_controller.html">RTController</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a02358053723895c6423f73ec97d5fe24">context</a> (void) const</td></tr>
<tr class="memdesc:a02358053723895c6423f73ec97d5fe24 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the context of the capsule that owns this port.  <br /></td></tr>
<tr class="separator:a02358053723895c6423f73ec97d5fe24 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7569d7ad23ba8a40313ebc91aee92cc4 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a7569d7ad23ba8a40313ebc91aee92cc4">getId</a> (void) const</td></tr>
<tr class="memdesc:a7569d7ad23ba8a40313ebc91aee92cc4 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of the port.  <br /></td></tr>
<tr class="separator:a7569d7ad23ba8a40313ebc91aee92cc4 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13996e31840891910920c9880670edf inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_r_t_port_descriptor.html">RTPortDescriptor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ab13996e31840891910920c9880670edf">getInfo</a> (void) const</td></tr>
<tr class="memdesc:ab13996e31840891910920c9880670edf inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about a port.  <br /></td></tr>
<tr class="separator:ab13996e31840891910920c9880670edf inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee715e514169058cc688ef652ec41f83 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aee715e514169058cc688ef652ec41f83">getName</a> (void) const</td></tr>
<tr class="memdesc:aee715e514169058cc688ef652ec41f83 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the port.  <br /></td></tr>
<tr class="separator:aee715e514169058cc688ef652ec41f83 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6545f036888aeacaab36096f4e876ff inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_t_actor.html">RTActor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#af6545f036888aeacaab36096f4e876ff">getOwner</a> (void) const</td></tr>
<tr class="memdesc:af6545f036888aeacaab36096f4e876ff inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the owner capsule to which the port belongs.  <br /></td></tr>
<tr class="separator:af6545f036888aeacaab36096f4e876ff inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf5a22f8232f12cd60a969523946889 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a1bf5a22f8232f12cd60a969523946889">size</a> (void) const</td></tr>
<tr class="memdesc:a1bf5a22f8232f12cd60a969523946889 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the port.  <br /></td></tr>
<tr class="separator:a1bf5a22f8232f12cd60a969523946889 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef50658d6d1246dee65718b70b1a2088 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aef50658d6d1246dee65718b70b1a2088">resize</a> (int new_size)</td></tr>
<tr class="memdesc:aef50658d6d1246dee65718b70b1a2088 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new size (i.e.  <br /></td></tr>
<tr class="separator:aef50658d6d1246dee65718b70b1a2088 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35cd8130dde852d13d7953419349a11 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#af35cd8130dde852d13d7953419349a11">registerSAP</a> (const char *service)</td></tr>
<tr class="memdesc:af35cd8130dde852d13d7953419349a11 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an unwired port (SAP) with the layer service (as a "client").  <br /></td></tr>
<tr class="separator:af35cd8130dde852d13d7953419349a11 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e580b53c346f4a623b2864fcc8e344b inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a5e580b53c346f4a623b2864fcc8e344b">deregisterSAP</a> (void)</td></tr>
<tr class="memdesc:a5e580b53c346f4a623b2864fcc8e344b inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister an unwired port (SAP).  <br /></td></tr>
<tr class="separator:a5e580b53c346f4a623b2864fcc8e344b inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb58413ecb8836fe47aa6c0069fb3cf inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aabb58413ecb8836fe47aa6c0069fb3cf">registerSPP</a> (const char *service)</td></tr>
<tr class="memdesc:aabb58413ecb8836fe47aa6c0069fb3cf inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an unwired port (SPP) with the layer service (as the "provider").  <br /></td></tr>
<tr class="separator:aabb58413ecb8836fe47aa6c0069fb3cf inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71503e6d0ec280fa95ea813db29f41e inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aa71503e6d0ec280fa95ea813db29f41e">deregisterSPP</a> (void)</td></tr>
<tr class="memdesc:aa71503e6d0ec280fa95ea813db29f41e inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister an unwired port (SPP).  <br /></td></tr>
<tr class="separator:aa71503e6d0ec280fa95ea813db29f41e inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d430e4ee11ed7438cb77d60faaba91f inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a0d430e4ee11ed7438cb77d60faaba91f">defaultLayerName</a> (void) const</td></tr>
<tr class="memdesc:a0d430e4ee11ed7438cb77d60faaba91f inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default registration name for the port.  <br /></td></tr>
<tr class="separator:a0d430e4ee11ed7438cb77d60faaba91f inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c47b94180b9f30bf3e25bcfa55fe0d0 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a2c47b94180b9f30bf3e25bcfa55fe0d0">isRegistered</a> (void) const</td></tr>
<tr class="memdesc:a2c47b94180b9f30bf3e25bcfa55fe0d0 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the port is currently registered with the layer service or not.  <br /></td></tr>
<tr class="separator:a2c47b94180b9f30bf3e25bcfa55fe0d0 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4759bbdb8fcd25545f463a9caf15961d inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a4759bbdb8fcd25545f463a9caf15961d">getRegisteredName</a> (void) const</td></tr>
<tr class="memdesc:a4759bbdb8fcd25545f463a9caf15961d inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the registration name of the port.  <br /></td></tr>
<tr class="separator:a4759bbdb8fcd25545f463a9caf15961d inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0dafbdb3f5339378036a1f9800ac8b8 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ad0dafbdb3f5339378036a1f9800ac8b8">registerAs</a> (const char *service)</td></tr>
<tr class="memdesc:ad0dafbdb3f5339378036a1f9800ac8b8 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an unwired port either as an SAP or SPP (depending on the "Publish" property set on the port in the model).  <br /></td></tr>
<tr class="separator:ad0dafbdb3f5339378036a1f9800ac8b8 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed18e2ea1cd805cf48df1c4dda1a56df inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aed18e2ea1cd805cf48df1c4dda1a56df">deregister</a> (void)</td></tr>
<tr class="memdesc:aed18e2ea1cd805cf48df1c4dda1a56df inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister an unwired port (either an SAP or SPP).  <br /></td></tr>
<tr class="separator:aed18e2ea1cd805cf48df1c4dda1a56df inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae364dd3d1d73dda4146f77cadd708d53 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ae364dd3d1d73dda4146f77cadd708d53">isBoundAt</a> (int index) const</td></tr>
<tr class="memdesc:ae364dd3d1d73dda4146f77cadd708d53 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a port instance is currently connected to another port instance.  <br /></td></tr>
<tr class="separator:ae364dd3d1d73dda4146f77cadd708d53 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2765cfbbe1295b939a47ea0b9be991c inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ab2765cfbbe1295b939a47ea0b9be991c">isIndexTo</a> (int index, <a class="el" href="class_r_t_actor.html">RTActor</a> *capsule) const</td></tr>
<tr class="memdesc:ab2765cfbbe1295b939a47ea0b9be991c inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a port instance is currently connected to a port instance owned by a certain capsule instance.  <br /></td></tr>
<tr class="separator:ab2765cfbbe1295b939a47ea0b9be991c inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f251e8160558cf5ae295a59cfab1202 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a7f251e8160558cf5ae295a59cfab1202">indexTo</a> (<a class="el" href="class_r_t_actor.html">RTActor</a> *capsule) const</td></tr>
<tr class="memdesc:a7f251e8160558cf5ae295a59cfab1202 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if there exists a port instance currently connected to a port instance owned by a certain capsule instance.  <br /></td></tr>
<tr class="separator:a7f251e8160558cf5ae295a59cfab1202 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9150bfbf17314443453d429c8f113553 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a9150bfbf17314443453d429c8f113553">purge</a> (void)</td></tr>
<tr class="memdesc:a9150bfbf17314443453d429c8f113553 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the defer queue of all port instances without recalling any deferred message.  <br /></td></tr>
<tr class="separator:a9150bfbf17314443453d429c8f113553 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2703f40abf6a8df9bbd730215c8c23e7 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a2703f40abf6a8df9bbd730215c8c23e7">purgeAt</a> (int index)</td></tr>
<tr class="memdesc:a2703f40abf6a8df9bbd730215c8c23e7 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the defer queue of a specified port instance without recalling any deferred message.  <br /></td></tr>
<tr class="separator:a2703f40abf6a8df9bbd730215c8c23e7 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775cee0be2a2cfd90b58b2cc3ec0f86e inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a775cee0be2a2cfd90b58b2cc3ec0f86e">recall</a> (void)</td></tr>
<tr class="memdesc:a775cee0be2a2cfd90b58b2cc3ec0f86e inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall a message from the defer queue and insert it at the back of the controller's message queue (after other queued messages).  <br /></td></tr>
<tr class="separator:a775cee0be2a2cfd90b58b2cc3ec0f86e inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae611db0412a09055815ac9717394f303 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ae611db0412a09055815ac9717394f303">recallFront</a> (void)</td></tr>
<tr class="memdesc:ae611db0412a09055815ac9717394f303 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall a message from the defer queue and insert it at the front of the controller's message queue (before other queued messages).  <br /></td></tr>
<tr class="separator:ae611db0412a09055815ac9717394f303 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7cfcb42423fc78b60f48f7220c0779 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a9f7cfcb42423fc78b60f48f7220c0779">recallAt</a> (int index, int front=0)</td></tr>
<tr class="memdesc:a9f7cfcb42423fc78b60f48f7220c0779 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall a message from the defer queue and insert it in the controller's message queue.  <br /></td></tr>
<tr class="separator:a9f7cfcb42423fc78b60f48f7220c0779 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc92df9cafd7c04372916ee4ef6c5c3c inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#afc92df9cafd7c04372916ee4ef6c5c3c">recallAll</a> (void)</td></tr>
<tr class="memdesc:afc92df9cafd7c04372916ee4ef6c5c3c inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall all messages from the defer queue and insert them at the back of the controller's message queue (after other queued messages).  <br /></td></tr>
<tr class="separator:afc92df9cafd7c04372916ee4ef6c5c3c inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70638165fd32d634670c2c2f174a3c3b inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a70638165fd32d634670c2c2f174a3c3b">recallAllFront</a> (void)</td></tr>
<tr class="memdesc:a70638165fd32d634670c2c2f174a3c3b inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall all messages from the defer queue and insert them at the front of the controller's message queue (before other queued messages).  <br /></td></tr>
<tr class="separator:a70638165fd32d634670c2c2f174a3c3b inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627afae9906e70cea7fc182bfb5f7cb8 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a627afae9906e70cea7fc182bfb5f7cb8">recallAllAt</a> (int index, int front=0)</td></tr>
<tr class="memdesc:a627afae9906e70cea7fc182bfb5f7cb8 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall all messages from the defer queue and insert them in the controller's message queue.  <br /></td></tr>
<tr class="separator:a627afae9906e70cea7fc182bfb5f7cb8 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b78477128d033d1e1f4c797ef0caf6 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a56b78477128d033d1e1f4c797ef0caf6">bindingNotification</a> (int on_off)</td></tr>
<tr class="memdesc:a56b78477128d033d1e1f4c797ef0caf6 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on or off binding notifications for this port.  <br /></td></tr>
<tr class="separator:a56b78477128d033d1e1f4c797ef0caf6 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb72eaea84b5ce02ebf4393d1768c21 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#adcb72eaea84b5ce02ebf4393d1768c21">bindingNotificationRequested</a> (void) const</td></tr>
<tr class="memdesc:adcb72eaea84b5ce02ebf4393d1768c21 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if binding notifications are currently enabled for the port.  <br /></td></tr>
<tr class="separator:adcb72eaea84b5ce02ebf4393d1768c21 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d444f5ca3150bf91f56cf1637623307 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a2d444f5ca3150bf91f56cf1637623307">sendTypeCheckEnable</a> (int on_off)</td></tr>
<tr class="memdesc:a2d444f5ca3150bf91f56cf1637623307 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on or off type checking when performing <a class="el" href="class_r_t_protocol.html#a4b38472435fc60256e4a4f2d0234c9de" title="Send an event on the port.">send()</a>, <a class="el" href="class_r_t_protocol.html#a4fba0c4760d48842f11d891b416f3ef9" title="Invoke an event on the port.">invoke()</a> or <a class="el" href="class_r_t_protocol.html#a6458de033f1ecf9f60de9b7745dc376f" title="Make a reply to respond to an invoke.">reply()</a> on the port.  <br /></td></tr>
<tr class="separator:a2d444f5ca3150bf91f56cf1637623307 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880d97d0e3b87ac9ea00bb2f6eaf0d56 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a880d97d0e3b87ac9ea00bb2f6eaf0d56">sendTypeCheckEnabled</a> (void) const</td></tr>
<tr class="memdesc:a880d97d0e3b87ac9ea00bb2f6eaf0d56 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if type checking when sending events is enabled.  <br /></td></tr>
<tr class="separator:a880d97d0e3b87ac9ea00bb2f6eaf0d56 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2a9a51d2ec8c9f97dd6eb8e8370aaa inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">RTProtocolDescriptor::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a1d2a9a51d2ec8c9f97dd6eb8e8370aaa">sendCheck</a> (int signal, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type) const</td></tr>
<tr class="memdesc:a1d2a9a51d2ec8c9f97dd6eb8e8370aaa inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a particular event would be possible to send on this port.  <br /></td></tr>
<tr class="separator:a1d2a9a51d2ec8c9f97dd6eb8e8370aaa inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac415448c9272ba92ead19c6e97c806bd inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ac415448c9272ba92ead19c6e97c806bd">receiveTypeCheckEnable</a> (int on_off)</td></tr>
<tr class="memdesc:ac415448c9272ba92ead19c6e97c806bd inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on or off type checking when receiving an event on the port.  <br /></td></tr>
<tr class="separator:ac415448c9272ba92ead19c6e97c806bd inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e0bd91743d6720c1ea3426074314e7 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a74e0bd91743d6720c1ea3426074314e7">receiveTypeCheckEnabled</a> (void) const</td></tr>
<tr class="memdesc:a74e0bd91743d6720c1ea3426074314e7 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if type checking when receiving events is enabled.  <br /></td></tr>
<tr class="separator:a74e0bd91743d6720c1ea3426074314e7 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ad300424f58e0f6325fdee64fe02d8 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">RTProtocolDescriptor::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aa2ad300424f58e0f6325fdee64fe02d8">receiveCheck</a> (int signal, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type) const</td></tr>
<tr class="memdesc:aa2ad300424f58e0f6325fdee64fe02d8 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a particular event would be possible to receive on this port.  <br /></td></tr>
<tr class="separator:aa2ad300424f58e0f6325fdee64fe02d8 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fba0c4760d48842f11d891b416f3ef9 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a4fba0c4760d48842f11d891b416f3ef9">invoke</a> (<a class="el" href="class_r_t_message.html">RTMessage</a> *replyBuffer, int signal, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, bool implicitReply)</td></tr>
<tr class="memdesc:a4fba0c4760d48842f11d891b416f3ef9 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke an event on the port.  <br /></td></tr>
<tr class="separator:a4fba0c4760d48842f11d891b416f3ef9 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c5eae9cdc5ab117f9332b41964bcf7 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aa3c5eae9cdc5ab117f9332b41964bcf7">invokeAt</a> (int index, <a class="el" href="class_r_t_message.html">RTMessage</a> *replyBuffer, int signal, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, bool implicitReply)</td></tr>
<tr class="memdesc:aa3c5eae9cdc5ab117f9332b41964bcf7 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke an event on a replicated port at a specified index.  <br /></td></tr>
<tr class="separator:aa3c5eae9cdc5ab117f9332b41964bcf7 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6458de033f1ecf9f60de9b7745dc376f inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a6458de033f1ecf9f60de9b7745dc376f">reply</a> (int signal, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type)</td></tr>
<tr class="memdesc:a6458de033f1ecf9f60de9b7745dc376f inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a reply to respond to an invoke.  <br /></td></tr>
<tr class="separator:a6458de033f1ecf9f60de9b7745dc376f inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b38472435fc60256e4a4f2d0234c9de inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a4b38472435fc60256e4a4f2d0234c9de">send</a> (int signal, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, int priority, bool moveData=false)</td></tr>
<tr class="memdesc:a4b38472435fc60256e4a4f2d0234c9de inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an event on the port.  <br /></td></tr>
<tr class="separator:a4b38472435fc60256e4a4f2d0234c9de inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d071f7137ca82a8ffd7c8e589c3114 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a77d071f7137ca82a8ffd7c8e589c3114">sendAt</a> (int index, int signal, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, int priority, bool moveData=false)</td></tr>
<tr class="memdesc:a77d071f7137ca82a8ffd7c8e589c3114 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an event on a replicated port at a specified index.  <br /></td></tr>
<tr class="separator:a77d071f7137ca82a8ffd7c8e589c3114 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a409abf498737bed2549cc246701fd451"><td class="memItemLeft" align="right" valign="top"><a id="a409abf498737bed2549cc246701fd451" name="a409abf498737bed2549cc246701fd451"></a>
static const <a class="el" href="struct_r_t_protocol_descriptor.html">RTProtocolDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rt_class</b></td></tr>
<tr class="separator:a409abf498737bed2549cc246701fd451"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:af29795e694ec9b5c2c0efe1943851571"><td class="memItemLeft" align="right" valign="top"><a id="af29795e694ec9b5c2c0efe1943851571" name="af29795e694ec9b5c2c0efe1943851571"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>rtiLast_External</b> = rti_event
 }</td></tr>
<tr class="separator:af29795e694ec9b5c2c0efe1943851571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_class_r_t_protocol"><td colspan="2" onclick="javascript:toggleInherit('pro_types_class_r_t_protocol')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="class_r_t_protocol.html">RTProtocol</a></td></tr>
<tr class="memitem:a6dc9f620cde1f39e1a8ef8c9ff1350e9 inherit pro_types_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="a6dc9f620cde1f39e1a8ef8c9ff1350e9" name="a6dc9f620cde1f39e1a8ef8c9ff1350e9"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>BindingNotification</b> = 1
, <b>RegisteredAsSAP</b> = 2
, <b>SendTypeCheck</b> = 4
, <b>ReceiveTypeCheck</b> = 8
, <br />
&#160;&#160;<b>Resized</b> = 16
<br />
 }</td></tr>
<tr class="separator:a6dc9f620cde1f39e1a8ef8c9ff1350e9 inherit pro_types_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf537db66f86337bdc9dad4e91e86ec8 inherit pro_types_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="abf537db66f86337bdc9dad4e91e86ec8" name="abf537db66f86337bdc9dad4e91e86ec8"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>rtiLast_RTProtocol</b> = 0
 }</td></tr>
<tr class="separator:abf537db66f86337bdc9dad4e91e86ec8 inherit pro_types_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_r_t_protocol"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_r_t_protocol')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_r_t_protocol.html">RTProtocol</a></td></tr>
<tr class="memitem:ac7a17e8dc831575b8b324c123af2b0da inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="ac7a17e8dc831575b8b324c123af2b0da" name="ac7a17e8dc831575b8b324c123af2b0da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> (const <a class="el" href="struct_r_t_port_descriptor.html">RTPortDescriptor</a> *)</td></tr>
<tr class="separator:ac7a17e8dc831575b8b324c123af2b0da inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab821319dd07a3ef521765d9260783898 inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="ab821319dd07a3ef521765d9260783898" name="ab821319dd07a3ef521765d9260783898"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getFlags</b> (void) const</td></tr>
<tr class="separator:ab821319dd07a3ef521765d9260783898 inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13b117f2c7538cb426e361fba7426ef inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="ab13b117f2c7538cb426e361fba7426ef" name="ab13b117f2c7538cb426e361fba7426ef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setFlag</b> (int)</td></tr>
<tr class="separator:ab13b117f2c7538cb426e361fba7426ef inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc08d99d20ab533b5079e3aa074e892 inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="acbc08d99d20ab533b5079e3aa074e892" name="acbc08d99d20ab533b5079e3aa074e892"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resetFlag</b> (int)</td></tr>
<tr class="separator:acbc08d99d20ab533b5079e3aa074e892 inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8e009f25cb11e3f94b3e8b1a03e885 inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="a1b8e009f25cb11e3f94b3e8b1a03e885" name="a1b8e009f25cb11e3f94b3e8b1a03e885"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bindAt</b> (int, <a class="el" href="struct_r_t_binding_end.html">RTBindingEnd</a> &amp;, <a class="el" href="class_r_t_controller.html">RTController</a> *)</td></tr>
<tr class="separator:a1b8e009f25cb11e3f94b3e8b1a03e885 inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab999150c4dc37ce4cbc4390b847f39fb inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="ab999150c4dc37ce4cbc4390b847f39fb" name="ab999150c4dc37ce4cbc4390b847f39fb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>peerAt</b> (int, <a class="el" href="struct_r_t_binding_end.html">RTBindingEnd</a> &amp;)</td></tr>
<tr class="separator:ab999150c4dc37ce4cbc4390b847f39fb inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12e8428f1305054a5ddf074f19b595a inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="ae12e8428f1305054a5ddf074f19b595a" name="ae12e8428f1305054a5ddf074f19b595a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unbindAt</b> (int, <a class="el" href="class_r_t_controller.html">RTController</a> *)</td></tr>
<tr class="separator:ae12e8428f1305054a5ddf074f19b595a inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7adb291e96c24590673c557299d052e inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="aa7adb291e96c24590673c557299d052e" name="aa7adb291e96c24590673c557299d052e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>notifyInit</b> (<a class="el" href="class_r_t_controller.html">RTController</a> *)</td></tr>
<tr class="separator:aa7adb291e96c24590673c557299d052e inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2536ee9af988c7bebd23c626cb3f4898 inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="a2536ee9af988c7bebd23c626cb3f4898" name="a2536ee9af988c7bebd23c626cb3f4898"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>notifyBoundAt</b> (int, <a class="el" href="class_r_t_controller.html">RTController</a> *)</td></tr>
<tr class="separator:a2536ee9af988c7bebd23c626cb3f4898 inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a port through which an external thread can safely communicate with its owner capsule. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af04524fb547bb8e4c6ed138e2cc167c9" name="af04524fb547bb8e4c6ed138e2cc167c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04524fb547bb8e4c6ed138e2cc167c9">&#9670;&#160;</a></span>dataDelete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void External::Base::dataDelete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to find a specific data object in the list of objects stored on the external port. </p>
<p>If it is found it will be deleted. This function will typically be called from the same external thread that pushed the object into the list, and it can be useful if the object contains data that has become invalid so that it no longer should be processed by the owner capsule. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data object to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72f0c2ccc19997bc4b0f3b0915d17a4c" name="a72f0c2ccc19997bc4b0f3b0915d17a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f0c2ccc19997bc4b0f3b0915d17a4c">&#9670;&#160;</a></span>dataPopBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int External::Base::dataPopBack </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop the last data object off the list of objects stored on the external port. </p>
<p>This function should normally be called by the thread on which the owner capsule executes. It is the responsibility of the caller to delete the popped data object when done with it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>The address where to store the retrieved object. Will be null in case of errors (for example when attempting to pop from an empty list). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of data objects remaining in the list of objects stored on the external port. </dd></dl>

</div>
</div>
<a id="ab9b68ec01f677002125312be6b6f3069" name="ab9b68ec01f677002125312be6b6f3069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b68ec01f677002125312be6b6f3069">&#9670;&#160;</a></span>dataPopFront()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int External::Base::dataPopFront </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop the first data object off the list of objects stored on the external port. </p>
<p>This function should normally be called by the thread on which the owner capsule executes. It is the responsibility of the caller to delete the popped data object when done with it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>The address where to store the retrieved object. Will be null in case of errors (for example when attempting to pop from an empty list). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of data objects remaining in the list of objects stored on the external port. </dd></dl>

</div>
</div>
<a id="a6e87c64eb0a3330e28d7455ef7c3c1e9" name="a6e87c64eb0a3330e28d7455ef7c3c1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e87c64eb0a3330e28d7455ef7c3c1e9">&#9670;&#160;</a></span>dataPushBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void External::Base::dataPushBack </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a data object on the external port. </p>
<p>The data object will be put as the last object in the list of objects stored on the external port. This function should normally be called from an external thread when it has data that should be passed to a capsule thread, and when it's not appropriate to pass the data in the call of <a class="el" href="class_external_1_1_base.html#a16f48420dea3566e5b292e16bf7a8a6f" title="Send an event on the external port.">raise()</a>, for example to avoid copying the data object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data object (non-null and dynamically allocated by code in the external thread, which calls this function) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab7c1cdd74f5395d44c420ff5833b378" name="aab7c1cdd74f5395d44c420ff5833b378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7c1cdd74f5395d44c420ff5833b378">&#9670;&#160;</a></span>disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void External::Base::disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the owner capsule from receiving an event on the external port. </p>
<p>This function may only be called from the thread on which the owner capsule executes. </p>

</div>
</div>
<a id="a20a21158ffc3d6872879f604b81f314c" name="a20a21158ffc3d6872879f604b81f314c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a21158ffc3d6872879f604b81f314c">&#9670;&#160;</a></span>enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void External::Base::enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the owner capsule to receive an event on the external port. </p>
<p>This function may only be called from the thread on which the owner capsule executes. </p>

</div>
</div>
<a id="a16f48420dea3566e5b292e16bf7a8a6f" name="a16f48420dea3566e5b292e16bf7a8a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f48420dea3566e5b292e16bf7a8a6f">&#9670;&#160;</a></span>raise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int External::Base::raise </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td>
          <td class="paramname"><em>type</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send an event on the external port. </p>
<p>Data can optionally be included in the event. This function may be used only on external threads (i.e. another thread than the one on which the owner capsule executes). Sending of the event will only be successful if the external port is currently enabled for event reception. After this function has been called, the port is automatically disabled from receiving another event until <a class="el" href="class_external_1_1_base.html#a20a21158ffc3d6872879f604b81f314c" title="Enable the owner capsule to receive an event on the external port.">enable()</a> has been called again. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data object to put in the sent event. The data is copied by the TargetRTS using the copy function of the type descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type descriptor for the data object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success and 0 if the event could not be sent on the external port (typically because it was not enabled). </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_r_t_external_8h_source.html">RTExternal.h</a></li>
<li>RTExternal.inl</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
