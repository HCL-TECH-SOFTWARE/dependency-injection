{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"art-comp/","text":"Art compiler reference (command-line arguments etc)","title":"The Art Compiler"},{"location":"art-lang/","text":"Art is a language for developing stateful and event-driven realtime applications. By stateful we mean that the application consists of objects whose behavior can be described with state machines. By event-driven we mean that these objects communicate with each other by sending events, which can cause their state machines to transition from one state to another. The Art language is an extension of C++, that provides high-level concepts not directly found in the C++ language. All these high-level concepts are transformed into C++ code by the Art compiler. Generated code uses a run-time library known as the TargetRTS ( Target RunTime System ). The TargetRTS is a C++ library that acts as a layer between the generated code and the underlying platform (hardware, operating system etc) on which the realtime application runs. Art is well suited for describing both the behavior and structure of a realtime application, but it uses C++ as expression and action language. C++ is also used for declaring types, variables, functions etc. As a rule of thumb, Art uses C++ for everything where C++ is a good fit, and only provides new language concepts where no appropriate constructs exist in C++. This means that if you already know C++, you can quickly learn Art too, and existing C++ code you may have already written can still be used. Concepts and Terminology In Art the concept of a capsule is central. A capsule is like a C++ class, but with a few differences and extensions. A C++ class is passive in the sense that a caller can access its public member functions and variables at any time. Hence a C++ object always executes in the context of the caller, and when a member function is called, the caller is blocked until it returns. A capsule, however, is active and has its own execution context. This means that we never call a capsule member function or access a capsule member variable from outside the capsule itself. Instead we communicate with the capsule by sending events to it. Each capsule has a queue of events it has received and the events will be dispatched to the capsule one by one. The sender of the event is not blocked, as the event will be handled by the capsule asynchronously when it is later dispatched. The picture below shows 3 capsule instances each holding a queue with events that have been received, but not yet dispatched. Note that this picture is conceptual. In a real implementation several performance optimizations are applied, for example it's common to let a single thread drive more than one capsule instance, and several capsule instances can share a common event queue. But from a conceptual point of view each capsule has its own queue of events that are waiting to be dispatched to it. Events have a priority which determines how they are ordered in the queue. Events with high priority are placed before events with lower priority, and if two events have the same priority they are ordered according to when they arrive. A capsule may have ports. A port is typed by a protocol which defines the events that may be sent in to the port (these are known as in-events ), as well as the events the capsule itself may send out through the port for others to receive (these are called out-events ). Ports can be used both for internal and external communication. A port used for external communication is called a service port . Together the service ports constitute the communication interface of the capsule, and decides what \"services\" the capsule provides for other capsules to use. A simple capsule which only handles a small number of events, may be able to handle all these events using a single state machine. However, when new ports are added (or new events in protocols typing existing ports), the capsule interface grows and the state machine has to grow with it, since there will be more events for it to handle. Eventually a point is reached where it will not be practical for a capsule to handle any more events in its own state machine, because it has grown too large or complex. If not before, this is the time to define a composite structure for the capsule. A composite structure is created by decomposing a capsule using capsule parts. A capsule part (or for simplicity just part ) is typed by another capsule and is a way for a capsule to delegate some of its responsibilities to other capsules. Such a decomposition is purely an implementation detail that is not visible from the outside of the capsule. When you send an event to a capsule you cannot know if the capsule will handle the event itself, or if it will forward the event to another capsule typing one of its capsule parts. The ability to decompose a capsule into parts is important for managing complexity. When a capsule has grown too big and complex you can decompose it into capsule parts without changing the communication interface of the capsule. Ports of capsules typing capsule parts are connected to each other by means of connectors. A connector is a conceptual construct for showing how events are routed in the internal structure of a capsule. At run-time connectors don't exist, and ports are directly connected to each other. Because of this, it's not mandatory to use connectors. You can also choose to dynamically connect (and disconnect) ports at run-time. Although this provides for more flexibility, it has the drawback of making it impossible to statically visualize the communication paths of a capsule. Ports that connect statically to other ports via connectors are called wired ports. Ports that are connected dynamically without use of static connectors are called unwired ports. The picture below shows the structure of a capsule Top which consists of two capsule parts ping and pong each holding a capsule instance (a Pinger capsule and a Ponger capsule respectively). The connector between the wired ports p on these capsules makes it possible for these capsules to communicate with each other. Communication can also happen using the unwired ports q1 and q2 if they are connected at run-time. The picture also shows that the capsule Ponger is further decomposed using a capsule part inner . All events sent to port p of Ponger will be further routed to port i of the Internal capsule. Regardless if ports are statically connected by connectors (wired ports), or dynamically connected at run-time (unwired ports), they must be compatible with each other. This means that the out-events of one port must match the in-events of the other port, for the ports to be possible to connect. This constraint ensures that events are never lost when traveling between two connected ports. To make it possible to describe the events that may travel between two connected ports using a single protocol, it's possible to make one of the ports conjugated . For a conjugated port the meaning of in-events and out-events are swapped, so that the in-events are the events that may be sent out through the port, and the out-events are the ports that may be sent to the port. In the picture above port q1 is non-conjugated ( ) while port q2 is conjugated ( ). Both capsule parts and ports may have multiplicity. You can think about a capsule part with multiplicity > 1 as an array that holds capsule instances at run-time. In the same way you can think about a port with multiplicity > 1 as an array that holds connections to port instances at run-time. The multiplicity of ports and parts must match when connecting two ports with each other. Once again, this constraint ensures that events will not be lost when traveling between the connected ports at run-time. XXX PICTURE SHOWING PARTS+PORTS WITH MULTIPLICITY XXX In addition to regular C++ member functions a capsule may have a state machine as its behavior. A state machine describes how an instance of the capsule may move between different states through its life-time. A transition that connects a source state with a target state may be triggered when an event from a capsule's event queue is dispatched. Several conditions must hold true for the transition to trigger. For example, the event must match a trigger that specifies the expected type of event and the port on which it was received. It's also possible to associate a boolean guard condition with the transition and/or with the trigger which must be true for the transition to trigger. A transition may have an effect , which is a piece of C++ code that executes when the transition gets triggered. The picture below shows a state machine containing three states and three transitions. The presence of transition guard code is shown with a yellow dot and the presence of transition effect code is shown with a blue dot. Both these are C++ code snippets that are embedded in the Art file. When a capsule instance is created (this is sometimes referred to as capsule incarnation ), it's state machine starts to execute by triggering the transition that goes out from the initial state (the big blue circle in the above diagram). Each state machine must have exactly one such initial state with an outgoing transition. Since this initial transition is triggered automatically when the capsule instance is created it cannot have any constraints like mentioned above. The initial transition is an example of a non-triggered transition since it cannot have triggers. The path from the source state to the target state can sometimes consist of more than one transition. In that case only the first of these is a triggered transition that may have triggers that specify when it will trigger. Once the first transition in this path has triggered, subsequent non-triggered transitions will always execute, one by another according to how they are connected in the state machine. However, also non-triggered transitions (with the exception of the initial transition) may have guards. Such guards are usually evaluated before the triggered transition triggers to ensure that they all are enabled, so that it's guaranteed that the target state can be reached. There is one exception to this rule, for transitions that leave a choice . Such guards are only evaluated once the choice has been reached to dynamically decide which outgoing transition to take next. This also means that guards of such transitions must be mutually exclusive, or there is a risk that the state machine will get stuck in the choice. In the state machine shown below the transitions t2 and t5 are triggered transitions, while other transitions are non-triggered. Transition t5 can only be triggered if either the guard of t7 or t6 is true, while t2 can be triggered even if neither the guard of t3 nor t4 is true. The target of transition t5 is a junction which is used for either splitting or merging transition paths depending on evaluated guard conditions. A state may be decomposed by a sub state machine. Such a state is called a composite state and a state machine that has composite states is called a hierarchical state machine . Transitions enter a composite state through an entry point and exit it through an exit point . Usually an entry point is connected to a nested state inside the state machine of the composite state, but it can also connect to a deep history . Reaching the deep history of a composite state means that all sub states that were previously active will become active again. Hence, deep history is a way to restore a composite state so all its nested states will be reactivated again recursively. The picture below shows a state machine with a composite state Composite containing two nested states S1 and S2 . When this state machine starts to execute state S1 first becomes active since Composite is entered using the ep1 entry point. Later, when leaving S2 through the ex1 exit point, state X becomes active. Then when leaving X through the transition that connects to the ep2 entry point the state S1 once again becomes active since ep2 is connected to the deep history. Of course, whenever a nested state is active, the enclosing composite state is also active. At any point in time a state machine has an active state configuration , which consists of the set of currently active states. A state may have an entry action and/or exit action which is a C++ code snippet that gets executed whenever the state is entered or exited. Note that state entry actions for nested states also run when those states are entered because of a deep history. In state diagrams the presence of entry and/or exit actions are shown by icons just below the state name. In the state machine shown below state S1 has an entry action, state S2 has an exit action and state S3 has both an entry and an exit action. A transition where the source and target state is the same state is called a self-transition . A special kind of self-transition is an internal transition , which is a transition that when triggered doesn't leave the current state. Hence, when an internal transition is triggered the active state configuration remains unchanged, and neither the entry nor exit action of the state gets executed. In the state machine shown below the state has two self-transitions; t which is a regular self-transition (a.k.a. external self-transition ) and it which is an internal transition. Since a state may have a large number of internal transitions they are not shown inside the state symbol, but if you select the state symbol you can see them in the Properties view. State machines can not only be defined for capsules but also for regular classes. This can be useful if you want a plain passive C++ class to have a state machine. Contrary to a capsule a class may not have ports and doesn't execute in its own context. It's therefore common to associate such a class with a capsule that it can use for sending events through its ports. Transitions of a passive class state machine are triggered by calling trigger operations on the class. Such operations have no code, but just trigger transitions in the class state machine. The realtime application needs to designate one capsule as the top capsule . This is done in the transformation configuration , which is a file containing all the properties used for building the application (e.g. code generator options, compiler settings etc.). There is no language construct in Art for defining a top capsule; any capsule that you define can act as the top capsule. However, in practise you typically decide at an early stage which capsule that will be the top capsule. If you build a library rather than an executable you don't have a top capsule. The top capsule is the entry point of the realtime application. When it starts to execute one instance of the top capsule will be automatically created, and its state machine starts to execute. Embedded C++ Code Art uses C++ as action and expression language. It also uses C++ for defining types, variables and functions. A C++ code snippet can be embedded into Art at many places by enclosing it with backticks. Here is an example of how to write the code that should execute when a transition triggers: S1 -> S2 on timer.timeout ` std::cout << \"Hello World!\" << std::endl; `; Here is another example that shows how to include some C++ code as the header preface of a capsule: capsule BrewControl { [[rt::impl_preface]] ` #include <iostream> ` }; Code snippets can not only be associated with Art language constructs as in the above two examples, but can also be placed at the Art file level. There are two such file-level code snippets: Declarations (rt::decl) May contain arbitrary C++ declarations. All these code snippets will be generated into a C++ header file with the same name as the Art file. Implementations (rt::impl) May contain arbitrary C++ implementations. All these code snippets will be generated into a C++ implementation file with the same name as the Art file. As an example, assume we have an Art file sample.art with the following contents [[rt::decl]] ` typedef C* Cptr; Cptr func1(); ` [[rt::impl]] ` Cptr func1() { return nullptr; } ` Two C++ files will be generated from this Art file: sample.h typedef C* Cptr; Cptr func1(); sample.cpp #include \"sample.h\" Cptr func1() { return nullptr; } File-level code snippets are useful whenever you need to include some C++ code in your application that doesn't naturally belong to any particular Art element. They can for example be used for declaring and implementing utility functions or types that are needed by many different Art elements. All C++ files that are generated from Art elements in an Art file that contains file-level code snippets will automatically include the header file that is generated for those code snippets. If you want to use the C++ declarations also from another generated file, you need to manually add an #include for that header file using a code snippet on the Art element that corresponds to that generated file. For example, a protocol defined in sample.art can use the type Cptr directly without adding an #include . protocol MyEvents { out alert(`Cptr`); }; However, a capsule defined in sample2.art needs to include sample.h to make that type available. capsule Cx { [[rt::header_preface]] ` #include \"sample.h\" ` [[rt::decl]] ` protected: Cptr m_ptr; ` // ... }; Here an rt::header_preface code snippet is used for making the generated capsule header file include sample.h while an rt::decl code snippet is used for declaring a member variable m_ptr for the capsule. See the documentation of the different Art elements in the Art Language Reference to learn about what code snippets that are available for each kind of Art element. Textual and Graphical Notations The Art language is a textual language, but many parts of it also have a graphical notation. For example, a state machine can be shown using a graphical state diagram, and the composite structure of a capsule can be shown in a structure diagram. Relationships between capsules, protocols and classes, such as inheritance, can be shown in class diagrams. Below are examples of these three kinds of diagrams: Syntax Art uses a syntax that should look familiar to developers with knowledge about languages like C++ and Java. Declarations are terminated with a semicolon ; Multiple elements declared in the same language construct uses comma , for separating the elements Curly brackets {} are used for grouping nested elements Square brackets [] are used for specifying cardinality (i.e. multiplicity) of elements A dot ( . ) is used as scope resolution operator Line // and block /* */ comments may be freely used for commenting Names and Keywords Names of Art elements must be valid C++ identifiers since they will be used as names of C++ definitions in generated code. Names also must not clash with names used in the TargetRTS. Don't worry. The Art language editor will let you know if you choose a name that won't work. Just like any language, Art has certain keywords that are reserved and which cannot be used as names. These keywords are listed below: Art keywords behavior capsule choice class connect entry entrypoint exclude exclude exit exitpoint fixed history in initial junction notify on optional out part plugin port protocol publish redefine service state statemachine subscribe template trigger typename unwired when with Art is a case-sensitive language and names may use any capitalization. However, just like with most languages, there are conventions for how to capitalize names. Those conventions are described below where each Art language construct is described in detail. Comments The same kinds of comments as in C++ can be used, i.e. line and block comments. // line comment /* block comment */ /* multi-line block comment */ Capsule A capsule defines an active class with its own execution context. It may have ports through which it can receive events . A capsule has a state machine that describes how instances of the capsule transitions between different states in the response to received events. Names of capsules are typically nouns, often describing something that performs some form of activity. For example \"Controller\", \"TrafficLight\" or \"FaultHandler\". By convention names of capsules start with uppercase. Embedded C++ code can be used for declaring member variables, member functions, nested types etc for the capsule. Here is an example of a capsule with a simple state machine and a member variable. capsule Elevator { [[rt::decl]] ` unsigned int currentLevel = 0; ` statemachine { state Waiting; initial -> Waiting; }; }; Note Capsule member variables and member functions may be private or protected, but should usually not be public. To avoid threading issues all communication with a capsule should be done using events, and therefore public members are not recommended. An exception is capsule constructors which need to be accessible from other capsules that create instances of the capsule using a capsule factory. If you anyway let a capsule have public members you need to ensure they are only accessed from the same thread that runs the capsule. The example above uses an rt::decl code snippet for declaring a capsule member variable. Here is the list of all code snippets that can be used for a capsule: Code snippet C++ mapping Example of use rt::header_preface Inserted at the top of the capsule class header file Adding #includes rt::header_ending Inserted at the bottom of the capsule class header file Declaring a type alias for the capsule class rt::impl_preface Inserted at the top of the capsule class implementation file Adding #includes rt::impl_ending Inserted at the bottom of the capsule class implementation file Undefining a macro only used in a capsule implementation rt::decl Inserted into the capsule class header file (inside the class) Declaring a capsule member variable or function rt::impl Inserted into the capsule class implementation file Implement a capsule member function Capsule Constructor Just like a regular class a capsule may have constructors. A capsule constructor is declared using an rt::decl code snippet and defined using an rt::impl code snippet. All capsule constructors have two mandatory parameters: rtg_rts This is the controller ( RTController* ) which will execute an instance of the capsule rtg_ref This is the part ( RTActorRef* ) into which the capsule instance will be inserted After these parameters you can add your own parameters, to pass arbitrary initialization data to the capsule instance. Below is an example where a capsule MyCap has a reference variable m_c . To initialize this variable a capsule constructor is used. capsule MyCap { [[rt::decl]] ` public: MyCap(RTController*, RTActorRef*, MyClass&); private: MyClass& m_c; ` [[rt::impl]] ` MyCap(RTController* rtg_rts, RTActorRef* rtg_ref, MyClass& c) :RTActor(rtg_rts, rtg_ref), m_c(c) { } ` // ... }; Note that a capsule constructor must call the RTActor constructor in its initializer.. Protocol and Event A protocol defines events that may be sent in to a port (so called in-events) and events that may be sent out from the same port (so called out-events). By grouping events into protocols, and then typing ports with such protocols, we can precisely define which events the capsule may send and receive through that port. By convention names of protocols start with uppercase, while names of events start with lowercase and use camelCase if the name consists of multiple words. A protocol event may have a parameter, which enables it to carry data. You declare a parameter for an event by specifying the C++ type of the data to be carried by the event. Note An event can have at most one parameter. If you need to send multiple data objects with an event you can declare an event parameter of struct or class type. Here is an example of a protocol that defines some in-events and some out-events: protocol MachineEvents { in start(); in startDeferred(`unsigned long` /* milliseconds */); out success(); out error(`std::string` /* error message */); in relayEvent(); out relayEvent(); }; The event relayEvent above is both an in-event and an out-event. Such symmetric events are useful in protocols typing ports the may receive and send the same events (for example a port that just forwards received events to another port). By convention a symmetric event is declared on a single line. At run-time we often talk about a message rather than an event. A message is an instance of an event, similar to how a capsule instance is an instance of a capsule. In other words, a message is a run-time concept while an event is a design-time concept. Port A port defines a named point of communication for a capsule. A port is typed by a protocol which defines the events that may be sent in to (in-events) and out from (out-events) the port. A port may be conjugated in order to swap the meaning of in-events and out-events. That is, a capsule may send out-events on its non-conjugated ports, but in-events for its conjugated ports. A port becomes conjugated if you add a tilde (~) after its name. Ports are often named to describe the role or purpose of the communication that takes place on them. Note that when a capsule wants to send an event to another capsule it's the port name that is referenced, rather than the name of the receiver capsule (which the sender capsule shouldn't need to know about). By convention names of ports start with lowercase and use camelCase if the name consists of multiple words. Here is an example of a capsule with a few ports. Note that RTist in Code provides several predefined protocols that can be used right away, for example Timing . Also note that you can declare multiple ports on a single line if the ports are of the same kind ( p1 and p2 below are both service ports). capsule Machine { service port control : MachineEvents; behavior port timer : Timing; // predefined Timing protocol service behavior port control2 : CtrlEvents; service port p1~ : MoreEvents, p2~ : OtherEvents; // ... }; Service ports constitute the externally visible communication interface for a capsule, and together they define which events can be sent to the capsule, and which events the capsule can send out for other capsules to receive. In a structure diagram the service ports are shown on the border of a capsule or part symbol. A behavior port is logically connected to the behavior (i.e. state machine ) of a capsule. This means that an event that a capsule receives on a behavior port will be handled by the state machine of that capsule. A non-behavior port, however, will simply route an event to another port to which it is connected. Every sent event will ultimately reach a behavior port (provided ports are properly connected), and the state machine of the capsule owning that behavior port will handle the event. In a structure diagram, behavior ports are connected to a small ellipse which represents the capsule state machine. Note that ports can also be shown in a class diagram. Port Multiplicity At run-time an instance of a port can be connected to a port instance on another capsule. Such connections is what make a sent event be routed from the port on which it is sent, through a number of non-behavior ports, until it finally reaches a behavior port. By default a port has single multiplicity (1) meaning that at most one such connection can be established. However, you can specify a non-single multiplicity for a port to allow for more connections to be created at run-time. In the example below a Server capsule has a port with multiplicity 100. At run-time an instance of that Server capsule can be connected to 100 different client ports, each of which can send events to the server. capsule Server { service port clients : ComEvents[100]; // ... }; In a structure diagrams a port is shown as \"stacked\" if it has non-single multiplicity. You can also use a C++ expression to specify the port multiplicity. This can for example be useful if the multiplicity is defined in C++ as a macro, a template parameter or a constexpr. For example: capsule Server { service port clients : ComEvents[`NBR_CLIENTS`]; // ... }; Notification Port Every protocol contains two implicit events rtBound and rtUnbound. A port can choose to receive those events whenever a connection for the port is established (rtBound) or dropped (rtUnbound) at run-time. Declare a port as a notification port to receive these events. capsule Server { service notify port clients : ComEvents[100]; // ... }; Port notifications are useful in dynamic systems when capsules need to wait until other capsules are ready, before they can start to communicate with those capsules. For example, a client may need to wait until a server is ready before it sends a request to that server. In the same way it's often useful to get notified when a connection is dropped, since that means communication on that port should no longer take place. Unwired Port Ports are by default wired, meaning that they should be connected with connectors to specify statically how events will be routed. Having a static connector structure defined has the benefit that it becomes possible to look at a capsule's structure diagram to see how events received by the capsule will be routed at run-time. However, in some dynamic systems it's not possible to describe this statically. Ports may be connected and disconnected dynamically and the run-time connections between port instances may hence vary over time. If you need this flexibility you can declare ports as unwired. Here is an example of an application where a client capsule can connect to different kinds of server capsules. Sometimes it may be connected to server1 and sometimes to server2 . It is therefore not possible to describe the connections of Top statically using connectors, and we can instead declare the ports as unwired. capsule Top { part client : Client; part server1 : Server; part server2 : Server; // ... }; capsule Client { service behavior unwired port p : Protocol; // ... }; capsule Server { service behavior unwired port p~ : Protocol; // ... }; Note Only use unwired ports when required. It's strongly recommended to use wired ports whenever possible to enable the visualization of the connector structure in a structure diagram. When unwired ports are required you should write a comment that describes how they will be connected at run-time, since this often cannot easily be concluded by looking at the C++ code of the capsule. An unwired port is always a behavior port. In a structure diagram an unwired port is drawn with a hollow ellipse, while a wired behavior port is drawn with a filled ellipse. In the structure diagram below port q is wired while port p is unwired. An unwired port is either a service access point (SAP) or a service provision point (SPP) depending on the role it plays in a dynamic connection with another unwired port. The capsule that owns the SAP port uses it to subscribe to a service that is published by another capsule by means of an SPP port. The capsule with the SAP port is often called \"client\" or \"subscriber\" while the capsule with the SPP port is often called \"server\" or \"publisher\". Unwired ports get connected by means of registering them under a service name that should be unique in the application. Registration of unwired ports can either happen automatically when the container capsule instance is created, or programmatically at a later point in time. It's also possible to deregister unwired ports in order to disconnect them. You can specify how an unwired port should be registered by means of the following properties: registration specifies when an unwired port should be registered registration_name specifies the service name with which the port should be registered If you choose to register an unwired port programmatically (using the TargetRTS functions registerSPP and registerSAP ) you decide at registration time whether the port should be an SAP or SPP port. However, if you choose to instead let the port be registered automatically you need to declare the port as either a subscribe (SAP) or publish (SPP) port. Here is the same example again, but now with automatic registration of the unwired ports using the service name myService : capsule Client { subscribe behavior port sap [[rt::properties( registration_name = \"myService\") ]] : Protocol; // ... }; capsule Server { publish behavior port spp~ [[rt::properties( registration_name = \"myService\") ]] : Protocol; // ... }; Note that the keyword unwired is implicit when you declare a port as either a subscribe or publish port. Connector Connectors describe how events are routed within a capsule by connecting ports in its composite structure. They make it possible to see in a structure diagram which parts of a capsule that can communicate with each other. Each connector connects exactly two ports with each other. A connected port may either be a port of the capsule itself, or a port of a capsule that types one of its capsule parts. A few constraints decide if it's possible to connect two ports: 1) The ports must be wired. Unwired ports cannot be connected. 2) The ports must be typed by the same protocol. 3) The ports' conjugations must match. If the ports are at the same level in the capsule's structure (e.g. both ports belong to capsules typing capsule parts owned by the same capsule), then the connected ports must have the opposite conjugation. This is because events that are sent out from one of the ports must be able to be received by the other port. However, if the ports are at different levels in the capsule's structure (e.g. one of them belongs to a capsule typing a capsule part owned by the capsule and the other belongs to the capsule itself), then the ports must have the same conjugation. This is because in this case events are simply delegated from one capsule to another. The example below shows the structure diagram of a capsule Top where we can see two connectors. capsule Top { part ping : Pinger, pong : Ponger; connect ping.p1 with pong.p2; // ... }; capsule Internal { service behavior port i~ : PROTO; // ... }; capsule Pinger { service behavior port p1 : PROTO; // ... }; capsule Ponger { service behavior port p2~ : PROTO; part inner : Internal; connect p2 with inner.i; // ... }; The connector between p1 and p2 goes between two ports on the same level which is why these ports must have opposite conjugation. The connector between p2 and i goes between two ports at different levels which is why these ports must have the same conjugation. The non-behavior port p2 is a so called relay port (it just relays all events it receives to another port) and the connector between p2 and i is sometimes called a delegation connector to describe the fact that capsule Ponger uses it for delegating some of its responsiblities to the capsule Inner . Note that relay ports can be optimized away so they don't exist at run-time (i.e. at run-time port p1 can be directly connected to i ). A connector doesn't have a direction, so it doesn't matter in which order it connects the two ports. That is, connecting X with Y is equivalent to connecting Y with X. Part A capsule can be decomposed by means of parts (also called \"capsule parts\" to emphasize that they are parts of a capsule). A part is a container that at run-time may hold one or many capsule instances. The part has a multiplicity that specifies the maximum number of capsule instances it can contain at run-time, and it has a type which is another capsule. All capsule instances must either be of that specific capsule type, or of a capsule type that inherits from it. It's common to name parts according to the capsule that types them. For example, a part typed by a capsule Controller may be called controller , ctrl or perhaps theController . By convention part names start with lowercase and use camelCase if the name consists of multiple words. There are three kinds of parts which determine how and when they will be populated with capsule instances. 1) Fixed part In a fixed part capsule instances are created automatically when the container capsule is created, and destroyed when the container is destroyed. Fixed parts by default have multiplicity 1. Such a part will always contain one and only one instance of the capsule that types the part. 2) Optional part In an optional part capsule instances don't have a strong lifetime relationship with the container capsule as is the case for fixed parts. The capsule instances can be created programmatically using the Frame service of the TargetRTS at some point after the container capsule has been created, and they can be destroyed before the container capsule is destroyed. However, at the latest they will be automatically destroyed when the container is destroyed. Optional parts by default have multiplicity 0..1. This means that it may either contain zero or one capsule instance at any point in time. The presence of zero in the multiplicity is what makes the part optional. 3) Plugin part A plugin part is similar to an optional part in that it is populated by capsule instances programmatically. However, the capsule instances are not created in the plugin part but instead imported into the plugin part from another part. Typically such a capsule instance is first created into an optional part, and then at some later point in time imported into a plugin part. Later it can be deported (i.e. removed) from the plugin part and perhaps imported into another plugin part. This makes it possible to create very dynamic composite structures where the same capsule instance can play different roles in different parts over time. Moving a capsule instance by deporting it from one plugin part and then importing it in another plugin part is more efficient than destroying the capsule instance in one optional part and then creating another capsule instance in another optional part. Plugin parts are typically used together with unwired ports . In general it's possible to import a capsule instance into more than one plugin part at the same time, but it can only be imported if its ports are not already bound in its current location. Plugin parts by default have multiplicity 0..1. In the example below the capsule C contains a few parts of different kinds and multiplicities. Note that you may declare multiple parts on the same line if they are of the same kind (both c and d below are optional parts). capsule C { part a : D; fixed part b : D[4]; optional part c : D, d : D[0..5]; plugin part e : D; part f : D[`COUNT`]; // ... }; Part a is fixed with multiplicity 1 since neither kind nor multiplicity is specified for it. Part b is also fixed (using the \"fixed\" keyword for more clarity) and with multiplicity 4. When an instance of capsule C is created 5 instances of capsule D will be automatically created. One of these instances will be inserted into part a and the others into part b . These instances will remain there until the C capsule instance is destroyed. Part c is optional with multiplicity 0..1. At run-time it can contain at most one instance of capsule D . Part d is also optional but can contain up to 5 instances of D as specified by its multiplicity 0..5. Part e is plugin with the default multiplicity 0..1. At run-time at most one instance of capsule D can be imported into it. That instance must already have been created in another part, for example part c . Part f uses a C++ expression for specifying the multiplicity. This can for example be useful if the multiplicity is defined in C++ as a macro, a template parameter or a constexpr. Parts can be shown in a structure diagram: Parts are shown as \"stacked\" if they have non-single multiplicity. Optional parts are shown with a \"diagonal\" background pattern, while plugin parts are shown with a \"double diagonal\" background pattern. Parts can also be shown in a class diagram: In the above diagram the filled diamonds show that there is a strong life-time relationship between a C instance and the instances of D that are located in the fixed and optional parts a , b , c and d , while this is not the case for the instance located in the plugin part d as shown by the hollow diamond. Part with Capsule Factory If the capsule that types a part has a capsule constructor with custom constructor parameters, you can define a capsule factory for the part. Such a capsule factory consists of two code snippets that define how an instance of that capsule should be created and destroyed. rt::createFunction Defines how to create an instance of the capsule. For example, which constructor arguments to pass, which thread to use for running the created capsule instance, at which index to insert the capsule instance into the part (in case it has multiplicity > 1) etc. rt::destroyFunction Defines how to destroy an instance of the capsule. By default it's destroyed using the new operator. Here is an example where a part defines a capsule factory that specifies a create function. The create function gets the mandatory constructor parameters rtg_rts and rtg_ref as arguments, as well as an index argument that specifies the index where the created capsule instance would be inserted by default. part engine : Engine [[rt::createFunction]] ` return new Engine(rtg_rts, rtg_ref, true /* custom constructor arg */); `; Note that you may want to create a capsule factory for a part also for other reasons than passing custom constructor parameters. For example, you may want to change the default thread ( RTController* ) that should execute the created capsule instance, or you may want to instantiate an inherited capsule rather than the capsule that types the part. State Machine State machines are used for specifying the behavior of capsules . It is also possible to provide a state machine for a passive class; see Class with State Machine for more information about that. In this chapter we focus on state machines in capsules. A state machine consists of states and transitions. During its lifetime a capsule instance transitions between the various states of its state machine, as a consequence of receiving messages on its behavior ports. When transitioning between two states one or several code snippets may execute. Such code may for example send messages to other capsule instances, something that may cause transitions to execute in their state machines. A state machine may also have pseudo states , which just like states may be connected with transitions, but that unlike states are not places where the state machine should stay for some time. For example, most pseudo states like junctions and entry/exit points merely act as connection points that make it possible to execute more than one transition when transitioning between two states. The notable exception is the choice in which actually the state machine may get stuck for ever, but this is something that should not happen in a correctly designed state machine. State The states of a state machine are the places where the state machine may stay for some time while waiting for another message to arrive. States should have names that describe what is happening while the state machine stays there, or what has happened for the state machine to arrive there. For example, \"WaitForInit\", \"Processing\" or \"Terminated\". By convention state names start with uppercase. You can declare multiple states on the same line using a comma-separated list of state names. It can be good to write a comment in front of the state name, if you want to elaborate more on its meaning that what is possible in the name itself. Here is an example of a state machine with some states: capsule TrafficLight { statemachine { state WaitUntilServerReady, CycleLight; state /* pedestrians are crossing the street */ PedestriansCrossing; initial -> WaitUntilServerReady; WaitUntilServerReady -> CycleLight; CycleLight -> PedestriansCrossing; }; }; A state comment is not visible in a state diagram, but show up in a tooltip when putting the cursor on a reference to the state. They can thereby make it easier to understand a state machine. States may be nested to create a hierarchical state machine . Entry and Exit Action A state may have an entry and/or exit action which is a code snippet that runs whenever the state is entered and/or exited. state Walk { entry ` server.walk().send(); `; exit ` server.stop().send(); `; }; Transition A transition connects a source state (or pseudo state) to a target state (or pseudo state). When a capsule instance handles a message that was received on one of its behavior ports, one or several transitions may execute. It's not required to give a name to a transition, but it's possible and often makes the state machine easier to understand. At least triggered transitions (i.e. transitions where the source is a state) should have a name. A transition name can be choosen to describe what needs to have happened for the transition to execute, for example \"requestReceived\", \"timeout\" etc. By convention transition names start with lowercase and use camelCase if the name consists of multiple words. A triggered transition has one or several triggers which define when the transition can be triggered. Each trigger specifies a port and an event. The trigger can only trigger its transition if the received message is an instance of the specified event, and was received on the specified port. In addition it's possible to provide guard conditions that must be fulfilled for the trigger to trigger its transition. Such a guard condition can be specified for the transition, but also for each individual trigger. Here is an example of a capsule state machine with two triggered transitions requestReceived and timeout . It also contains an initial transition that has no name. capsule MyCap { statemachine { state Waiting, Processing; initial -> Waiting; requestReceived: Waiting -> Processing on com1.request, com2.request when ` return canHandleNow(); ` ` log.log(\"Handling request\"); log.commit(); handle(msg); `; timeout: Waiting -> Waiting on timer.timeout[`return zCount < 10;`]; }; }; Note the following: Triggers are specified as PORT.EVENT after the keyword on . You may specify multiple triggers separated by comma ( , ). A guard condition for the transition is specified after the when keyword, while a guard condition for an individual trigger is specified in square brackets ( [] ) after the trigger. A guard condition is actually a C++ statement that returns the boolean guard condition. Note Guard conditions should execute fast and have no side-effects. They are called frequently to decide which transition to execute when a message has arrived. Initial Transition Every state machine needs exactly one initial transition. When the state machine starts to run, the first thing that happens is that the initial transition executes and takes the state machine to its first state. Therefore, an initial transition is a non-triggered transition and also cannot have a guard condition. But it can of course have an effect code snippet. The source of the initial transition is the initial pseudo state which is declared using the initial keyword. Just like for any transition it's optional to give a name to the initial transition (in fact it's often left unnamed). For capsule instances that are programmatically created (i.e. located in optional capsule parts) you can provide initialization data at the time of creation. This is a data object that can be accessed in the effect code of the initial transition. Here is an example: initial -> WaitForServerInit ` RTpchar str = *((RTpchar*) rtdata); `; Note Any type of data object can be passed as initialization data which means that rtdata is an untyped pointer that has to be casted to the expected type. A more type-safe way of passing initialization data is to define a constructor for a capsule. A capsule constructor can take any number of arguments, while with rtdata only one data object can be passed (even if you of course can group several data objects into a struct or class to circumvent this limitation). With capsule constructors you can pass initialization data also for capsule instances that are located in fixed parts. By default rtdata cannot be modified (it has type const void* ). However, by setting the const_rtdata_param property to false on the initial transition, you can make it non-const. One reason for doing this could be that the initial transition effect code wants to pass some data back to the code that creates the capsule instance. However, you must be very careful if you do this since this will only work if the creating code runs in the same thread that runs the initial transition. A more legitimate reason could be that you want to move the initialization data into a capsule variable, so you can access it later. Moving data can be more efficient than copying it. [[rt::properties(const_rtdata_param=false)]] initial -> Waiting ` pC = std::move(*((MyClass*) rtdata)); `; Internal Transition An internal transition doesn't change the active state and therefore doesn't have a target state. An internal transition is always a triggered transition. You define an internal transition inside the state to which it belongs. Here is an example: state Done { unexpected: on myPort.* ` std::cout << \"Unexpected event received! << std::endl; `; }; Note the usage of an asterisk ( * ) to specify that any event received on myPort will trigger the internal transition when the state machine is in the Done state. Such \"receive-any\" events can of course be used for a trigger of any transition, but can in particular be useful for internal transitions that should handle all messages received on a port that are not handled by other triggered transitions leaving substates of the state. If another event is added to the port's protocol in the future, such a trigger will handle the new event too without a need for being updated. Internal transitions are examples of so called self-transitions. To learn about other types of self-transitions see this chapter . Frequent Transition Sometimes you may have a state where one or a few outgoing transitions can be expected to execute much more frequently than others. You can then set a frequent property on the transition trigger that you expect will trigger the transition frequently. The Art compiler uses this information to optimize generated C++ code so that such transition triggers are evaluated before other triggers that are expected to trigger the transition less frequently. interrupted: Working -> Stopped on [[rt::properties( frequent=true )]] external.interrupt ` // Interrupted while working... `; Note The frequent property relies on optimization features in the C++ compiler that may or may not be available depending on which target compiler that is used. Only use frequent transitions if profiling has shown that you have a need to do this optimization. Choice and Junction Choices and junctions are pseudo states that make it possible to split transition flows in a state machine. That is, one incoming transition may be split into multiple outgoing transitions. Which of the outgoing transitions that will execute is decided by evaluating their guard conditions. For a junction the guard conditions are evaluated already before leaving the currently active state. Only if there exists a path of transitions where all guards are fulfilled, will the active state be exited and the transitions can execute. Otherwise the state machine stays in its current state and attempts to find another path of transitions to execute. For a choice the guard conditions are evaluated after leaving the current state, when reaching the choice itself. The outgoing transition which has a fulfilled guard will execute next. Note It's important that there always is an outgoing transition for a choice with a fulfilled guard condition. Otherwise the state machine will get stuck in the choice without any chance of getting out of it. Choices and junctions must have names, so they can be referenced as the source or target of transitions. You can choose to use a name that gives a hint about what conditions that are checked in the guards of the outgoing transitions. For example, isEnabled for a choice that checks a boolean condition and checkValue when the condition has some other type. If you follow this approach you can then name the outgoing transitions accordingly. For example true and false for a choice that checks a boolean condition. By convention choice and junction names start with lowercase and use camelCase if consisting of multiple words. Sometimes it may be difficult to come up with a good name and in that case you can choose something short and \"technical\" like j1 , check1 etc. Below is an example of a state machine containing a choice and a junction. statemachine { state First, Second, Third; t1: initial -> First; choice isEnabled; junction checkThreshold; switchTurned: First -> isEnabled; true: isEnabled -> Second when ` return isEnabled(); `; false: isEnabled -> Second when ` else `; timeout: First -> checkThreshold; low: checkThreshold -> Third when ` return t < LIMIT1; `; medium: checkThreshold -> Third when ` return t >= LIMIT1 && t < LIMIT2; `; high: checkThreshold -> Third; }; Note the use of the keyword else for defining an else-guard. An else-guard will be fulfilled when no other guard of other outgoing transitions is fulfilled. For choices it's good practise to always have exactly one transition with an else-guard to ensure that at least one guard condition will be fulfilled. Thereby we avoid the risk of the state machine getting stuck in the choice. Else-guards can also be useful for junction transitions, but there they are more optional. You can also define an else-transition for a choice or junction by simply omitting the guard condition. This is consistent with triggered transitions where the absense of a guard condition is equivalent to a guard condition that always is fulfilled. See the transition high in the above example. Guard conditions should be mutually exclusive so that the order in which they are evaluated doesn't matter. Junctions can also be used for merging multiple incoming transition flows into a single outgoing transition. This can for example be useful if you want to reuse a transition path in the state machine for several triggered transitions. statemachine { state S1, S2; junction j1; initial -> S1; t1: S1 -> j1 on port1.e1 ` // handle e1 `; t2: S1 -> j1 on port2.e2 ` // handle e2 `; t3: S1 -> j1 on port3.e3 ` // handle e3 `; common: j1 -> S2 ` // common code here `; }; Of course, in the above simple example the same code reuse could also be obtained by putting the common code in a capsule member function which is called by each of the incoming transitions. But if the common transition is followed by more non-triggered transitions the above approach is more feasible. Hierarchical State Machine A state machine is hierarchical if it contains at least one composite state, i.e. a state with a nested state machine. A transition that is triggered in the enclosing state machine (i.e. the state machine that contains the composite state) should enter a composite state by specifying an entry point of the composite state as the target. In the nested state machine another transition can connect that entry point to a state in the nested state machine. A transition in the nested state machine may specify an exit point of the composite state as the target. In the enclosing state machine another transition can connect that exit point to a state in the enclosing state machine. Entry and exit points are pseudo states that need to be named. The names can be chosen to give a hint about when the composite state is entered or exited through them, for example systemStarted or errorDetected . If you want you can prefix the names with ep or ex . It's also common to use short and \"technical\" names like ep1 or ex1 if a more descriptive name doesn't make sense. By convention entry and exit point names start with lowercase and use camelCase if consisting of multiple words. It's also possible to directly enter a composite state without using an entry point. In this case the behavior will depend on whether the composite state is entered for the first time or not. If it is for the first time, the initial transition of the nested state machine will execute after the transition that targets the composite state has executed. Otherwise the composite state will instead be entered using deep history , i.e. by activating the state in the nested state machine that was most recently active (and recursively if that state again is a composite state). Note It's recommended to always enter a composite state using an entry point as the behavior then doesn't depend on if the state was previously entered or not. Below is an example of an hierarchical state machine with a composite state CompositeState that contains a nested state machine. Note that you can declare multiple entry or exit points on the same line. statemachine { initial -> CompositeState.ep1; state CompositeState { state Nested; entrypoint ep1, ep2; exitpoint ex1; initial -> Nested; ep1 -> Nested; Nested -> ex1; ep2 -> history*; }; state Other; CompositeState.ex1 -> Other; Other -> CompositeState.ep2; }; Note that a dot ( . ) is used as scope resolution operator, to make it possible to reference an entry or exit point from the enclosing state machine. Inside the nested state machine the entry and exit points are directly accessible without use of the scope resolution operator (using it there would be an error). It is possible to only connect an entry point on the \"outside\". Entering such an entry point will behave in the same way as entering the composite state without using an entry point (see above). It's therefore not recommended. In the same way it's possible to exit a composite state using an exit point that only is connected on the \"inside\". In this case the composite state is not exited and instead the previously active substate again becomes active (recursively, just like for deep history ). This is also not recommended, unless the transition is a local transition . Deep History Every nested state machine has an implicit pseudo state with the name history* (in state diagrams it's shown as H* to save space). It can be used as a target for any transition inside the nested state machine. When it is reached, the state machine will restore the previously active substate. If that state again is a composite state, its previously active substate will also be restored. This goes on recursively for all nested state machines (which is why it's called a deep history). In the example above we can see that the transition from ep2 targets the deep history pseudo state. This means that if the Nested substate is active and then the transition to ex1 gets triggered, the state Other becomes active. If then the transition to ep2 gets triggered the CompositeState will be entered using deep history so that the Nested substate will again become active. Local Transition A transition in a nested state machine where the source is an entry point and the target is an exit point, and these entry/exit points only are connected on the \"inside\", is a local transition . A local transition is a self-transition that behaves something in between an internal transition and a regular (a.k.a. external) self-transition. An internal transition defined on a composite state handles a message without exiting neither that composite state, nor any of its substates. However, a local transition will exit the composite state and then enter it again, but it will not do this for the substate that is active in the composite state. Hence, if a composite state has an exit action it will be called for the composite state, but not for the active substate. An external self-transition on the other hand will exit both the composite state and all active substates recursively, and then enter these states again. Exiting happens bottom-up which means that the deepest nested substate will first be exited, then its parent state, and so on until the top composite state is exited. Entering happens in the opposite order, i.e. in a top-down fashion. Let's look at an example to understand the difference between these three kinds of self-transitions: statemachine { initial -> SelfTransitionExample; state SelfTransitionExample { state Nested1 { state Nested2; }; internal: on port1.e1 ` // Internal transition `; entrypoint e1; exitpoint e2; local: e1 -> e2 ` // Local transition `; }; external: SelfTransitionExample -> SelfTransitionExample on port2.e2 ` // External transition `; }; Assume the currently active state configuration is { SelfTransitionExample , Nested1 , Nested2 } when one of the self-transitions get triggered: Internal transition ( internal ) No state is exited and the active state configuration remains unchanged. Local transition ( local ) 1) Nested2 is exited. 2) Nested1 is exited. 3) local executes. 4) Nested1 is entered. 5) Nested2 is entered. External transition ( external ) 1) Nested2 is exited. 2) Nested1 is exited. 3) SelfTransitionExample is exited. 4) external executes. 5) SelfTransitionExample is entered. 6) Nested1 is entered. 7) Nested2 is entered. Class with State Machine Art allows you to create passive classes with state machines. This can be an alternative to using a capsule in case you only need a passive stateful data object, and don't need the ability to send events to it, or to let it execute in its own context. A class with a state machine is more lightweight than a capsule at runtime. Transitions in a class state machine are triggered by calling trigger operations on the class. A trigger operation is similar to a regular member function in C++, but does not have a code behavior of its own. Instead, when you call a trigger operation on an object of a class with a state machine it may trigger a transition in the class' state machine. That transition may have an effect code snippet that will execute. A trigger operation can have parameters which allows you to pass data when calling them. Those parameters can be accessed in the transition that is triggered by it. Below is an example of a class with a state machine with two trigger operations initialize and finalize . Note that you can define multiple trigger operations on the same line. class DataObject { /* Trigger Operations */ trigger initialize(`int` data), finalize(); /* State Machine */ statemachine { state Initial, Initialized, Finalized; initial -> Initial; init: Initial -> Initialized on initialize(`int`) ` // Initialized int i = data; `; Initialized -> Finalized on finalize() ` // Finalized `; }; }; Just like for C++ member functions, trigger operations support overloading. That is, you can have many trigger operations with the same name as long as their full signatures are unique. The signature of a trigger operation consists of its name and the types of all its parameters. When you reference a trigger operation with parameters as a transition trigger, you need to include the types of the parameters (see the trigger for the init transition above). The same transition can be triggered by multiple trigger operations (just like a transition in a capsule state machine can be triggered by multiple events). However, in that case those trigger operations should agree on the names and types of their parameters so that the transition effect code can access them in a way that works regardless of which of the trigger operations that will trigger the transition. Names of classes with state machines by convention start with uppercase, while names of trigger operations and their parameters by convention start with lowercase and use camelCase if the name consists of multiple words. A common design pattern is to let a class-with-statemachine instance be managed by a single capsule instance. This means that the capsule instance is responsible both for creating, using and finally destroying the class-with-statemachine instance. If you follow this pattern it is thread-safe to for example call public member functions defined on the capsule from a transition in the class state machine. This can for example be used as a means for the class state machine to send events through the ports of the capsule (i.e. it can call a capsule member function that sends the event). However, to avoid exposing the full capsule functionality to the class state machine it's recommended to define an interface (i.e. abstract C++ class) which the capsule can implement. This interface can contain only those member functions which the class needs to access from its state machine. A class state machine can use the same constructs as a capsule state machine with a few exceptions: The initial transition cannot access initialization data as can a capsule's initial transition . Instead you can define one or several constructors for the class with parameters needed for passing initialization data when the class-with-statemachine instance is created. See Constructor for more information. Frequent transitions are not supported. The state machine can be hierarchical but the deep history pseudo state is not supported. Instead the shallow history pseudo state can be used. Even if it's possible for a class with a state machine to inherit from another class with a state machine, this doesn't mean that the state machines will be inherited as is the case for capsule inheritance. Read more about this in Inheritance . A class with state machine can have the same code snippets as a capsule. Constructor By default the initial transition of a class state machine executes at the time of constructing the class-with-statemachine instance. This happens because the generated default constructor will call an operation rtg_init1() which contains the code from the initial transition. If you want to wait with \"starting\" the state machine until a later point in time you need to define your own parameterless constructor which doesn't call this function. You can define any constructors you need on a class with a state machine. They are regular C++ constructors and allow to pass initialization data when creating a class-with-statemachine instance. Remember to call the rtg_init1() function in all such constructors, if you want the state machine to start at the time of creating the class-with-statemachine instance. Here is an example of a class with a state machine that has a user-defined constructor: class PC { [[rt::decl]] ` private: double m_data; public: PC(double data); ` [[rt::impl]] ` PC::PC(double data) : m_data(data) { rtg_init1(); } ` statemachine { state First; initial -> First ` // State machine started `; }; }; Shallow History Every nested state machine has an implicit pseudo state with the name history (in state diagrams it's shown as H to save space). It can be used as a target for any transition inside the nested state machine. When it is reached, the state machine will restore the previously active substate. However, if that state again is a composite state it's previously active substate will not be restored. This is in contrast to the deep history for capsule state machines, and is why for a class state machine this pseudo state is referred to as a shallow history. Here is an example: class MyClass { statemachine { state First { entrypoint ep1; ep1 -> history; }; initial -> First.ep1; }; }; Inheritance By using inheritance you can reuse and customize generic ( base ) Art elements into more specific ( derived ) Art elements. An Art element can inherit either from one or several other Art elements, and/or it can inherit from one or several C++ classes. The derived Art element can redefine elements of the base element. The redefining element (located in the derived element) can change one or several properties of the redefined element (located in the base element). This is very similar to how inheritance works in C++, with the difference that in C++ a redefining element has more restrictions on what properties that can be changed in the redefined element. For example, a redefining member function (known as an overridden member function in C++ terminology) must keep the same signature as the redefined member function (known as a virtual base member function in C++ terminology), and can only (in fact, must) change its implementation. In some cases Art inheritance not only allows to redefine inherited elements, but also to completely exclude them. An excluded element is not present in the derived element, so exclusion can be seen as a special form of redefinition where the whole element is removed in the derived element. In C++ it's not possible to exclude any inherited members. Capsule Inheritance A capsule can inherit from another capsule. Only one base capsule is allowed; multiple inheritance is not supported for capsules. In addition a capsule can inherit from any number of C++ classes (or structs). The derived capsule is type compatible with the base capsule in the sense that if you have a capsule part typed by the base capsule, you can at runtime incarnate it with instances of the derived capsule. Capsule inheritance has multiple dimensions. One dimension is the usual C++ inheritance between classes (remember that a capsule is an active class). In this dimension it is for example possible to redefine (a.k.a override) a virtual member function defined in the base capsule or in another base C++ class. But there is also a second dimension where the state machine of the derived capsule will implicitly inherit from the state machine of the base capsule. This makes it possible to redefine transitions and states. For example, a redefining transition in a derived capsule can change the effect code, the guard condition or the target state or pseudo state. And a redefining state in a derived capsule can change the entry or exit action, as well as any substate or subtransition in case the state is composite and has a nested state machine. It's also possible to completely exclude a state or a transition, either in the top capsule state machine, or in a nested state machine. Below is an example of a capsule D that inherits from another capsule B . In addition the capsule D inherits from two C++ classes IDataManager and IController . capsule B { statemachine { state BS, BS2; Initial: initial -> BS; }; }; capsule D : B, `IDataManager`, `IController` { [[rt::decl]] ` // IDataManager impl public: void manageData() override; // IController impl public: void control() override; ` [[rt::impl]] ` // impl of manageData() and control() ` statemachine { state DS; state exclude BS2; redefine Initial: initial -> DS; }; }; In the example we can see that D overrides functions from the base C++ classes that are assumed to be virtual (or pure virtual). For brevity the implementations of these functions have been omitted but would be placed in the rt::impl code snippet. We can also see an example of a state machine redefinition. The initial transition Initial of B 's state machine is redefined in D 's state machine so that it targets state DS instead of state BS . In the state diagram of D the state BS and the initial pseudo state are drawn with gray color and dashed outline, to show that they are inherited. The transition Initial is also drawn in grayed with dashed outline but with a blue label to show that it's redefining the inherited initial transition. The state BS2 is excluded in D 's state machine. In state diagrams excluded elements are by default shown with a \"crossed\" background, but by setting a diagram preference it's also possible to completely hide them from the diagram. Note that to be able to redefine the initial transition of B it is necessary to give it a name (so that it can be referenced as redefined from D ). This is yet another reason why it's good practise to give names to transitions, even if it's not mandated. But, of course, if you want to prevent anyone from creating a derived capsule with a state machine that redefines a certain transition, you can accomplish that by not giving a name to that transition. In effect, an unnamed transition is final , i.e. cannot be overridden or excluded. The rule that a capsule state machine must have exactly one initial transition also applies to a derived capsule. Therefore, when you introduce inheritance between two existing capsules, you typically first get an error saying that the derived capsule has two initial transitions (one inherited, and one locally defined). You then need to decide if you want to either remove the initial transition in the derived capsule, or (like in the above example) instead redefine the initial transition. Capsule inheritance also has a third dimension, which relates to its structure. Parts and ports defined in the base capsule are inherited by the derived capsule. Just like for states and transitions, it's possible to redefine or exclude a part or a port. A redefining port can change the type (i.e. protocol ), multiplicity and the notification property of the redefined port. A redefining part can change the type, multiplicity and kind (fixed, optional or plugin) of the redefined part. Below is an example of a capsule DPPI that inherits from another capsule BPPI . The port port1 and the part part1 is redefined, while the port port2 and part part2 are excluded. capsule BPPI { service port port1 : PR1; port port2 : PR1; part part1 : Cap1; part part2 : Cap1; statemachine { state State; initial -> State; }; }; capsule DPPI : BPPI { service notify port redefine port1 : PR2[10]; optional part redefine part1 : Cap2[0..20]; part exclude part2; port exclude port2; statemachine { state State2; }; }; Class Inheritance A class with state machine can inherit from other classes with state machines, or from C++ classes (or structs). Multiple inheritance is supported. Contrary to capsule inheritance , class inheritance does not imply inheritance between the state machines in the derived and base classes. This means it's not possible to redefine or exclude states and transitions in an inherited class state machine. Nor is it possible to redefine trigger operations. In fact, the derived class will have two state machines (its own, plus the one inherited from the base class) and these two state machines will execute independently of each other. That is, class inheritance is more a way of aggregating state machines rather than reusing and redefining them. Because of this, it's rather unusual to let two classes with state machines inherit each other. It's more useful to let a class with state machine inherit from other C++ classes. Below is an example of a class with state machine that inherits from two C++ classes DataContainer<CData> and IDisposable . class DataClass : `DataContainer<CData>`, `IDisposable` { [[rt::decl]] ` void dispose() override; // From IDisposable ` [[rt::impl]] ` void DataClass:dispose() { // impl } ` statemachine { state State; initial -> State; }; }; Protocol Inheritance A protocol may inherit events from another protocol. Only one base protocol is allowed; multiple inheritance is not supported for protocols. Inherited events can be redefined, but not excluded. A redefining event in a derived protocol can change the type of the event parameter as defined in the base protocol. In the example below, the protocol ExtendedMachineEvents adds one more in-event stop to the inherited MachineEvents protocol. It also redefines the startDeferred event to change its parameter type. protocol MachineEvents { in start(); in startDeferred(`unsigned long` /* milliseconds */); out success(); out error(`std::string` /* error message */); }; protocol ExtendedMachineEvents : MachineEvents { in stop(); in redefine startDeferred(`unsigned long long`); }; Template A template is a type that is parameterized by means of template parameters to make it more generic. When a template is used (a.k.a. instantiated), actual template parameters must be provided that match the formal template parameters defined in the template. Both capsules and classes can have template parameters. Just like in C++ two kinds of template parameters are supported: Type template parameter Replaced with a type when the template is instantiated. Non-type template parameters Replaced with a non-type, for example a constant value, when the template is instantiated. Template parameters may have defaults that will be used if a matching actual template parameter is not provided when instantiating the template. Below is an example of a capsule and a class with template parameters, some of which have defaults specified. The keywords typename and class can both be used for defining a type template parameter. A non-type template parameter is defined by specifying its type as a C++ code snippet. template <typename T = `int`, `int` p1 = `5`> capsule TemplateCapsule { [[rt::decl]] ` void func(T arg1) { // impl } ` service port mp : MachineEvents[`p1`]; statemachine { state State; initial -> State; }; }; template <typename T, class U, `int` p1> class TemplateClass : `Base<T,U,p1>` { statemachine { state State; initial -> State; }; }; Template parameters can only be used from C++ code snippets, and above you see some examples of how they can be used. It's not possible to instantiate a template in Art itself. For example, even if class Base above was defined as an Art class, a C++ code snippet has to be used since it has template parameters. Property Properties are name-value pairs that provide a generic mechanism for augmenting Art elements with extra data. Such data can be utilized by tools that operate on a parsed Art file, such as the code generator and semantic checker. Most Art elements can have properties and the syntax for specifying properties is the same regardless of the kind of element. However, different kinds of Art elements can have different properties. For Art elements that have a name, properties are specified right after the name. For elements without name, properties are specified before the element itself. In both cases the syntax looks like this: [[rt::properties( <property name>=<property value>, <property name>=<property value>, ... <property name>=<property value> )]] All properties have a default value, so you only need to specify a property if you want to set it to something else. The default values have been chosen so that you in most cases don't need to specify any properties at all. A property has a type, and its value must conform to that type. The following property types are supported: Boolean Boolean properties have a value that is either true or false . If you want to set a boolean property to true you can use a shorthand syntax where you just specify the property name. For example: capsule CapProp [[rt::properties( generate_file_impl=false, generate_file_header )]] { // ... }; Writing generate_file_header is equivalent to writing generate_file_header=true . However, this particular property has the default value true and hence doesn't need to be set at all. Integer Integer properties have a numeric value (>= 0). Here is an example: protocol XProtocol [[rt::properties( version=1 )]]{ // ... }; String String properties have a string value, enclosed in double quotes. Here is an example: class MC [[rt::properties( rule_config=\"E0022\" )]]{ // ... }; Enumeration A property of enumeration type has a value that references a literal of the enumeration. There are different enumerations used for different properties. The best way to learn about what enumeration literals that are available for a certain property is to use the Content Assist feature in the Art file editor. Place the cursor after the equal sign, and press Ctrl + Space . Here is an example of defining a property of enumeration type: class MC [[rt::properties( kind=struct )]]{ // ... }; Note that in some cases the name of an enumeration literal starts with underscore ( _ ) to prevent it from clashing with the set of Art keywords . Below is a table that lists all properties that can be used on different kinds of Art elements. Each property is described in a section of its own below the table. Art Elements Property Type Default Capsule , Class generate_file_header Boolean true Capsule , Class generate_file_impl Boolean true Capsule , Class , Protocol , Port , Initial transition , Triggered transition Trigger rule_config String \"\" Class , Protocol version Integer 0 Class generate_descriptor Enumeration (true, false, manual) true Class kind Enumeration (_class, struct, union) _class Class generate_class Boolean true Class generate_statemachine Boolean true Class const_target_param_for_decode Boolean false Class default_constructor_generate Boolean true Class default_constructor_explicit Boolean false Class default_constructor_inline Boolean false Class default_constructor_default Boolean false Class default_constructor_delete Boolean false Class default_constructor_visibility Enumeration (public, protected, private) public Port registration Enumeration (automatic, automatic_locked, application) automatic Port registration_name String \"\" Initial transition , Triggered transition const_rtdata_param Boolean true Trigger frequent Boolean false generate_file_header By default a capsule or class is translated to one header file ( .h ) and one implementation file ( .cpp ). Set this property to false to prevent generation of the header file, for example if you prefer to write it manually. generate_file_impl By default a capsule or class is translated to one header file ( .h ) and one implementation file ( .cpp ). Set this property to false to prevent generation of the implementation file, for example if you prefer to write it manually. rule_config This property is used for configuring validation rules for an Art element. Read more about this here . version TODO generate_descriptor By default a type descriptor will be generated for each class . The TargetRTS uses the type descriptor to know how to initialize, copy, move, destroy, encode or decode an instance of that class. Set this property to false for classes that don't need a type descriptor. Set it to manual if the class needs a type descriptor but you want to implement it manually rather than using the implementation that is generated by default. Note that even if you set this property to true so that a default type descriptor is generated, you can still override individual type descriptor functions for the class. kind By default a class is translated to a C++ class. You can use this property to instead translate it to a struct or union . generate_class If set to false no C++ code will be generated for the class. generate_statemachine If set to false code generation for the class' state machine will be suppressed. You can use this if the state machine is informal, and you prefer to implement it manually in another way. const_target_param_for_decode By default a decode function uses a non-const target parameter. This is because usually a decode implementation must call non-const functions on the decoded object to populate it with data from the decoding. However, if it doesn't need to call such functions you can set this property so that the target parameter is declared as const. default_constructor_generate If set to false a default (i.e. parameterless) constructor will not be generated for the class. default_constructor_explicit If set to true the default (i.e. parameterless) constructor will be declared as explicit. default_constructor_inline If set to true the default (i.e. parameterless) constructor will be declared as inline. It's implementation will then be generated into the header file. default_constructor_default If set to true the default (i.e. parameterless) constructor will be declared as defaulted. This tells the compiler to synthesize a default constructor even if one normally would not be synthesized (for example because there is a user-defined constructor with parameters). default_constructor_delete If set to true the default (i.e. parameterless) constructor will be declared as deleted? This will cause the compiler to generate an error if it is invoked. This can be used for preventing objects of the class to be created. default_constructor_visibility This property can be used for setting the visibility of the default (i.e. parameterless) constructor. By default it will be public but you can change it either to protected or private . registration This property specifies how to register an unwired port at runtime. The default is automatic which means the port will be registered automatically when the container capsule instance is initialized. The value automatic_locked has the same meaning but the registration will be \"locked\" so that any future attempt to deregister it, or register it under a different name, will fail. Set the property to application to programmatically register the port using the functions registerSPP() and registerSAP() respectively. registration_name This property specifies the name to use when registering a port at runtime. By default the port name is used, but it can be overridden using this property. const_rtdata_param If set to false the rtdata parameter in the transition function will be non-const. It can therefore be modified, which for example can avoid copying received message data and instead move it using its move constructor or move assignment operator. frequent Triggers for which this property is true will lead to generated code that handles these triggers faster than other triggers. This is done by placing their if-statements early in the rtsBehavior function to ensure that as little code as possible needs to execute when dispatching a message for a frequent trigger.","title":"The Art Language"},{"location":"art-lang/#concepts-and-terminology","text":"In Art the concept of a capsule is central. A capsule is like a C++ class, but with a few differences and extensions. A C++ class is passive in the sense that a caller can access its public member functions and variables at any time. Hence a C++ object always executes in the context of the caller, and when a member function is called, the caller is blocked until it returns. A capsule, however, is active and has its own execution context. This means that we never call a capsule member function or access a capsule member variable from outside the capsule itself. Instead we communicate with the capsule by sending events to it. Each capsule has a queue of events it has received and the events will be dispatched to the capsule one by one. The sender of the event is not blocked, as the event will be handled by the capsule asynchronously when it is later dispatched. The picture below shows 3 capsule instances each holding a queue with events that have been received, but not yet dispatched. Note that this picture is conceptual. In a real implementation several performance optimizations are applied, for example it's common to let a single thread drive more than one capsule instance, and several capsule instances can share a common event queue. But from a conceptual point of view each capsule has its own queue of events that are waiting to be dispatched to it. Events have a priority which determines how they are ordered in the queue. Events with high priority are placed before events with lower priority, and if two events have the same priority they are ordered according to when they arrive. A capsule may have ports. A port is typed by a protocol which defines the events that may be sent in to the port (these are known as in-events ), as well as the events the capsule itself may send out through the port for others to receive (these are called out-events ). Ports can be used both for internal and external communication. A port used for external communication is called a service port . Together the service ports constitute the communication interface of the capsule, and decides what \"services\" the capsule provides for other capsules to use. A simple capsule which only handles a small number of events, may be able to handle all these events using a single state machine. However, when new ports are added (or new events in protocols typing existing ports), the capsule interface grows and the state machine has to grow with it, since there will be more events for it to handle. Eventually a point is reached where it will not be practical for a capsule to handle any more events in its own state machine, because it has grown too large or complex. If not before, this is the time to define a composite structure for the capsule. A composite structure is created by decomposing a capsule using capsule parts. A capsule part (or for simplicity just part ) is typed by another capsule and is a way for a capsule to delegate some of its responsibilities to other capsules. Such a decomposition is purely an implementation detail that is not visible from the outside of the capsule. When you send an event to a capsule you cannot know if the capsule will handle the event itself, or if it will forward the event to another capsule typing one of its capsule parts. The ability to decompose a capsule into parts is important for managing complexity. When a capsule has grown too big and complex you can decompose it into capsule parts without changing the communication interface of the capsule. Ports of capsules typing capsule parts are connected to each other by means of connectors. A connector is a conceptual construct for showing how events are routed in the internal structure of a capsule. At run-time connectors don't exist, and ports are directly connected to each other. Because of this, it's not mandatory to use connectors. You can also choose to dynamically connect (and disconnect) ports at run-time. Although this provides for more flexibility, it has the drawback of making it impossible to statically visualize the communication paths of a capsule. Ports that connect statically to other ports via connectors are called wired ports. Ports that are connected dynamically without use of static connectors are called unwired ports. The picture below shows the structure of a capsule Top which consists of two capsule parts ping and pong each holding a capsule instance (a Pinger capsule and a Ponger capsule respectively). The connector between the wired ports p on these capsules makes it possible for these capsules to communicate with each other. Communication can also happen using the unwired ports q1 and q2 if they are connected at run-time. The picture also shows that the capsule Ponger is further decomposed using a capsule part inner . All events sent to port p of Ponger will be further routed to port i of the Internal capsule. Regardless if ports are statically connected by connectors (wired ports), or dynamically connected at run-time (unwired ports), they must be compatible with each other. This means that the out-events of one port must match the in-events of the other port, for the ports to be possible to connect. This constraint ensures that events are never lost when traveling between two connected ports. To make it possible to describe the events that may travel between two connected ports using a single protocol, it's possible to make one of the ports conjugated . For a conjugated port the meaning of in-events and out-events are swapped, so that the in-events are the events that may be sent out through the port, and the out-events are the ports that may be sent to the port. In the picture above port q1 is non-conjugated ( ) while port q2 is conjugated ( ). Both capsule parts and ports may have multiplicity. You can think about a capsule part with multiplicity > 1 as an array that holds capsule instances at run-time. In the same way you can think about a port with multiplicity > 1 as an array that holds connections to port instances at run-time. The multiplicity of ports and parts must match when connecting two ports with each other. Once again, this constraint ensures that events will not be lost when traveling between the connected ports at run-time. XXX PICTURE SHOWING PARTS+PORTS WITH MULTIPLICITY XXX In addition to regular C++ member functions a capsule may have a state machine as its behavior. A state machine describes how an instance of the capsule may move between different states through its life-time. A transition that connects a source state with a target state may be triggered when an event from a capsule's event queue is dispatched. Several conditions must hold true for the transition to trigger. For example, the event must match a trigger that specifies the expected type of event and the port on which it was received. It's also possible to associate a boolean guard condition with the transition and/or with the trigger which must be true for the transition to trigger. A transition may have an effect , which is a piece of C++ code that executes when the transition gets triggered. The picture below shows a state machine containing three states and three transitions. The presence of transition guard code is shown with a yellow dot and the presence of transition effect code is shown with a blue dot. Both these are C++ code snippets that are embedded in the Art file. When a capsule instance is created (this is sometimes referred to as capsule incarnation ), it's state machine starts to execute by triggering the transition that goes out from the initial state (the big blue circle in the above diagram). Each state machine must have exactly one such initial state with an outgoing transition. Since this initial transition is triggered automatically when the capsule instance is created it cannot have any constraints like mentioned above. The initial transition is an example of a non-triggered transition since it cannot have triggers. The path from the source state to the target state can sometimes consist of more than one transition. In that case only the first of these is a triggered transition that may have triggers that specify when it will trigger. Once the first transition in this path has triggered, subsequent non-triggered transitions will always execute, one by another according to how they are connected in the state machine. However, also non-triggered transitions (with the exception of the initial transition) may have guards. Such guards are usually evaluated before the triggered transition triggers to ensure that they all are enabled, so that it's guaranteed that the target state can be reached. There is one exception to this rule, for transitions that leave a choice . Such guards are only evaluated once the choice has been reached to dynamically decide which outgoing transition to take next. This also means that guards of such transitions must be mutually exclusive, or there is a risk that the state machine will get stuck in the choice. In the state machine shown below the transitions t2 and t5 are triggered transitions, while other transitions are non-triggered. Transition t5 can only be triggered if either the guard of t7 or t6 is true, while t2 can be triggered even if neither the guard of t3 nor t4 is true. The target of transition t5 is a junction which is used for either splitting or merging transition paths depending on evaluated guard conditions. A state may be decomposed by a sub state machine. Such a state is called a composite state and a state machine that has composite states is called a hierarchical state machine . Transitions enter a composite state through an entry point and exit it through an exit point . Usually an entry point is connected to a nested state inside the state machine of the composite state, but it can also connect to a deep history . Reaching the deep history of a composite state means that all sub states that were previously active will become active again. Hence, deep history is a way to restore a composite state so all its nested states will be reactivated again recursively. The picture below shows a state machine with a composite state Composite containing two nested states S1 and S2 . When this state machine starts to execute state S1 first becomes active since Composite is entered using the ep1 entry point. Later, when leaving S2 through the ex1 exit point, state X becomes active. Then when leaving X through the transition that connects to the ep2 entry point the state S1 once again becomes active since ep2 is connected to the deep history. Of course, whenever a nested state is active, the enclosing composite state is also active. At any point in time a state machine has an active state configuration , which consists of the set of currently active states. A state may have an entry action and/or exit action which is a C++ code snippet that gets executed whenever the state is entered or exited. Note that state entry actions for nested states also run when those states are entered because of a deep history. In state diagrams the presence of entry and/or exit actions are shown by icons just below the state name. In the state machine shown below state S1 has an entry action, state S2 has an exit action and state S3 has both an entry and an exit action. A transition where the source and target state is the same state is called a self-transition . A special kind of self-transition is an internal transition , which is a transition that when triggered doesn't leave the current state. Hence, when an internal transition is triggered the active state configuration remains unchanged, and neither the entry nor exit action of the state gets executed. In the state machine shown below the state has two self-transitions; t which is a regular self-transition (a.k.a. external self-transition ) and it which is an internal transition. Since a state may have a large number of internal transitions they are not shown inside the state symbol, but if you select the state symbol you can see them in the Properties view. State machines can not only be defined for capsules but also for regular classes. This can be useful if you want a plain passive C++ class to have a state machine. Contrary to a capsule a class may not have ports and doesn't execute in its own context. It's therefore common to associate such a class with a capsule that it can use for sending events through its ports. Transitions of a passive class state machine are triggered by calling trigger operations on the class. Such operations have no code, but just trigger transitions in the class state machine. The realtime application needs to designate one capsule as the top capsule . This is done in the transformation configuration , which is a file containing all the properties used for building the application (e.g. code generator options, compiler settings etc.). There is no language construct in Art for defining a top capsule; any capsule that you define can act as the top capsule. However, in practise you typically decide at an early stage which capsule that will be the top capsule. If you build a library rather than an executable you don't have a top capsule. The top capsule is the entry point of the realtime application. When it starts to execute one instance of the top capsule will be automatically created, and its state machine starts to execute.","title":"Concepts and Terminology"},{"location":"art-lang/#embedded-c-code","text":"Art uses C++ as action and expression language. It also uses C++ for defining types, variables and functions. A C++ code snippet can be embedded into Art at many places by enclosing it with backticks. Here is an example of how to write the code that should execute when a transition triggers: S1 -> S2 on timer.timeout ` std::cout << \"Hello World!\" << std::endl; `; Here is another example that shows how to include some C++ code as the header preface of a capsule: capsule BrewControl { [[rt::impl_preface]] ` #include <iostream> ` }; Code snippets can not only be associated with Art language constructs as in the above two examples, but can also be placed at the Art file level. There are two such file-level code snippets: Declarations (rt::decl) May contain arbitrary C++ declarations. All these code snippets will be generated into a C++ header file with the same name as the Art file. Implementations (rt::impl) May contain arbitrary C++ implementations. All these code snippets will be generated into a C++ implementation file with the same name as the Art file. As an example, assume we have an Art file sample.art with the following contents [[rt::decl]] ` typedef C* Cptr; Cptr func1(); ` [[rt::impl]] ` Cptr func1() { return nullptr; } ` Two C++ files will be generated from this Art file: sample.h typedef C* Cptr; Cptr func1(); sample.cpp #include \"sample.h\" Cptr func1() { return nullptr; } File-level code snippets are useful whenever you need to include some C++ code in your application that doesn't naturally belong to any particular Art element. They can for example be used for declaring and implementing utility functions or types that are needed by many different Art elements. All C++ files that are generated from Art elements in an Art file that contains file-level code snippets will automatically include the header file that is generated for those code snippets. If you want to use the C++ declarations also from another generated file, you need to manually add an #include for that header file using a code snippet on the Art element that corresponds to that generated file. For example, a protocol defined in sample.art can use the type Cptr directly without adding an #include . protocol MyEvents { out alert(`Cptr`); }; However, a capsule defined in sample2.art needs to include sample.h to make that type available. capsule Cx { [[rt::header_preface]] ` #include \"sample.h\" ` [[rt::decl]] ` protected: Cptr m_ptr; ` // ... }; Here an rt::header_preface code snippet is used for making the generated capsule header file include sample.h while an rt::decl code snippet is used for declaring a member variable m_ptr for the capsule. See the documentation of the different Art elements in the Art Language Reference to learn about what code snippets that are available for each kind of Art element.","title":"Embedded C++ Code"},{"location":"art-lang/#textual-and-graphical-notations","text":"The Art language is a textual language, but many parts of it also have a graphical notation. For example, a state machine can be shown using a graphical state diagram, and the composite structure of a capsule can be shown in a structure diagram. Relationships between capsules, protocols and classes, such as inheritance, can be shown in class diagrams. Below are examples of these three kinds of diagrams:","title":"Textual and Graphical Notations"},{"location":"art-lang/#syntax","text":"Art uses a syntax that should look familiar to developers with knowledge about languages like C++ and Java. Declarations are terminated with a semicolon ; Multiple elements declared in the same language construct uses comma , for separating the elements Curly brackets {} are used for grouping nested elements Square brackets [] are used for specifying cardinality (i.e. multiplicity) of elements A dot ( . ) is used as scope resolution operator Line // and block /* */ comments may be freely used for commenting","title":"Syntax"},{"location":"art-lang/#names-and-keywords","text":"Names of Art elements must be valid C++ identifiers since they will be used as names of C++ definitions in generated code. Names also must not clash with names used in the TargetRTS. Don't worry. The Art language editor will let you know if you choose a name that won't work. Just like any language, Art has certain keywords that are reserved and which cannot be used as names. These keywords are listed below: Art keywords behavior capsule choice class connect entry entrypoint exclude exclude exit exitpoint fixed history in initial junction notify on optional out part plugin port protocol publish redefine service state statemachine subscribe template trigger typename unwired when with Art is a case-sensitive language and names may use any capitalization. However, just like with most languages, there are conventions for how to capitalize names. Those conventions are described below where each Art language construct is described in detail.","title":"Names and Keywords"},{"location":"art-lang/#comments","text":"The same kinds of comments as in C++ can be used, i.e. line and block comments. // line comment /* block comment */ /* multi-line block comment */","title":"Comments"},{"location":"art-lang/#capsule","text":"A capsule defines an active class with its own execution context. It may have ports through which it can receive events . A capsule has a state machine that describes how instances of the capsule transitions between different states in the response to received events. Names of capsules are typically nouns, often describing something that performs some form of activity. For example \"Controller\", \"TrafficLight\" or \"FaultHandler\". By convention names of capsules start with uppercase. Embedded C++ code can be used for declaring member variables, member functions, nested types etc for the capsule. Here is an example of a capsule with a simple state machine and a member variable. capsule Elevator { [[rt::decl]] ` unsigned int currentLevel = 0; ` statemachine { state Waiting; initial -> Waiting; }; }; Note Capsule member variables and member functions may be private or protected, but should usually not be public. To avoid threading issues all communication with a capsule should be done using events, and therefore public members are not recommended. An exception is capsule constructors which need to be accessible from other capsules that create instances of the capsule using a capsule factory. If you anyway let a capsule have public members you need to ensure they are only accessed from the same thread that runs the capsule. The example above uses an rt::decl code snippet for declaring a capsule member variable. Here is the list of all code snippets that can be used for a capsule: Code snippet C++ mapping Example of use rt::header_preface Inserted at the top of the capsule class header file Adding #includes rt::header_ending Inserted at the bottom of the capsule class header file Declaring a type alias for the capsule class rt::impl_preface Inserted at the top of the capsule class implementation file Adding #includes rt::impl_ending Inserted at the bottom of the capsule class implementation file Undefining a macro only used in a capsule implementation rt::decl Inserted into the capsule class header file (inside the class) Declaring a capsule member variable or function rt::impl Inserted into the capsule class implementation file Implement a capsule member function","title":"Capsule"},{"location":"art-lang/#capsule-constructor","text":"Just like a regular class a capsule may have constructors. A capsule constructor is declared using an rt::decl code snippet and defined using an rt::impl code snippet. All capsule constructors have two mandatory parameters: rtg_rts This is the controller ( RTController* ) which will execute an instance of the capsule rtg_ref This is the part ( RTActorRef* ) into which the capsule instance will be inserted After these parameters you can add your own parameters, to pass arbitrary initialization data to the capsule instance. Below is an example where a capsule MyCap has a reference variable m_c . To initialize this variable a capsule constructor is used. capsule MyCap { [[rt::decl]] ` public: MyCap(RTController*, RTActorRef*, MyClass&); private: MyClass& m_c; ` [[rt::impl]] ` MyCap(RTController* rtg_rts, RTActorRef* rtg_ref, MyClass& c) :RTActor(rtg_rts, rtg_ref), m_c(c) { } ` // ... }; Note that a capsule constructor must call the RTActor constructor in its initializer..","title":"Capsule Constructor"},{"location":"art-lang/#protocol-and-event","text":"A protocol defines events that may be sent in to a port (so called in-events) and events that may be sent out from the same port (so called out-events). By grouping events into protocols, and then typing ports with such protocols, we can precisely define which events the capsule may send and receive through that port. By convention names of protocols start with uppercase, while names of events start with lowercase and use camelCase if the name consists of multiple words. A protocol event may have a parameter, which enables it to carry data. You declare a parameter for an event by specifying the C++ type of the data to be carried by the event. Note An event can have at most one parameter. If you need to send multiple data objects with an event you can declare an event parameter of struct or class type. Here is an example of a protocol that defines some in-events and some out-events: protocol MachineEvents { in start(); in startDeferred(`unsigned long` /* milliseconds */); out success(); out error(`std::string` /* error message */); in relayEvent(); out relayEvent(); }; The event relayEvent above is both an in-event and an out-event. Such symmetric events are useful in protocols typing ports the may receive and send the same events (for example a port that just forwards received events to another port). By convention a symmetric event is declared on a single line. At run-time we often talk about a message rather than an event. A message is an instance of an event, similar to how a capsule instance is an instance of a capsule. In other words, a message is a run-time concept while an event is a design-time concept.","title":"Protocol and Event"},{"location":"art-lang/#port","text":"A port defines a named point of communication for a capsule. A port is typed by a protocol which defines the events that may be sent in to (in-events) and out from (out-events) the port. A port may be conjugated in order to swap the meaning of in-events and out-events. That is, a capsule may send out-events on its non-conjugated ports, but in-events for its conjugated ports. A port becomes conjugated if you add a tilde (~) after its name. Ports are often named to describe the role or purpose of the communication that takes place on them. Note that when a capsule wants to send an event to another capsule it's the port name that is referenced, rather than the name of the receiver capsule (which the sender capsule shouldn't need to know about). By convention names of ports start with lowercase and use camelCase if the name consists of multiple words. Here is an example of a capsule with a few ports. Note that RTist in Code provides several predefined protocols that can be used right away, for example Timing . Also note that you can declare multiple ports on a single line if the ports are of the same kind ( p1 and p2 below are both service ports). capsule Machine { service port control : MachineEvents; behavior port timer : Timing; // predefined Timing protocol service behavior port control2 : CtrlEvents; service port p1~ : MoreEvents, p2~ : OtherEvents; // ... }; Service ports constitute the externally visible communication interface for a capsule, and together they define which events can be sent to the capsule, and which events the capsule can send out for other capsules to receive. In a structure diagram the service ports are shown on the border of a capsule or part symbol. A behavior port is logically connected to the behavior (i.e. state machine ) of a capsule. This means that an event that a capsule receives on a behavior port will be handled by the state machine of that capsule. A non-behavior port, however, will simply route an event to another port to which it is connected. Every sent event will ultimately reach a behavior port (provided ports are properly connected), and the state machine of the capsule owning that behavior port will handle the event. In a structure diagram, behavior ports are connected to a small ellipse which represents the capsule state machine. Note that ports can also be shown in a class diagram.","title":"Port"},{"location":"art-lang/#port-multiplicity","text":"At run-time an instance of a port can be connected to a port instance on another capsule. Such connections is what make a sent event be routed from the port on which it is sent, through a number of non-behavior ports, until it finally reaches a behavior port. By default a port has single multiplicity (1) meaning that at most one such connection can be established. However, you can specify a non-single multiplicity for a port to allow for more connections to be created at run-time. In the example below a Server capsule has a port with multiplicity 100. At run-time an instance of that Server capsule can be connected to 100 different client ports, each of which can send events to the server. capsule Server { service port clients : ComEvents[100]; // ... }; In a structure diagrams a port is shown as \"stacked\" if it has non-single multiplicity. You can also use a C++ expression to specify the port multiplicity. This can for example be useful if the multiplicity is defined in C++ as a macro, a template parameter or a constexpr. For example: capsule Server { service port clients : ComEvents[`NBR_CLIENTS`]; // ... };","title":"Port Multiplicity"},{"location":"art-lang/#notification-port","text":"Every protocol contains two implicit events rtBound and rtUnbound. A port can choose to receive those events whenever a connection for the port is established (rtBound) or dropped (rtUnbound) at run-time. Declare a port as a notification port to receive these events. capsule Server { service notify port clients : ComEvents[100]; // ... }; Port notifications are useful in dynamic systems when capsules need to wait until other capsules are ready, before they can start to communicate with those capsules. For example, a client may need to wait until a server is ready before it sends a request to that server. In the same way it's often useful to get notified when a connection is dropped, since that means communication on that port should no longer take place.","title":"Notification Port"},{"location":"art-lang/#unwired-port","text":"Ports are by default wired, meaning that they should be connected with connectors to specify statically how events will be routed. Having a static connector structure defined has the benefit that it becomes possible to look at a capsule's structure diagram to see how events received by the capsule will be routed at run-time. However, in some dynamic systems it's not possible to describe this statically. Ports may be connected and disconnected dynamically and the run-time connections between port instances may hence vary over time. If you need this flexibility you can declare ports as unwired. Here is an example of an application where a client capsule can connect to different kinds of server capsules. Sometimes it may be connected to server1 and sometimes to server2 . It is therefore not possible to describe the connections of Top statically using connectors, and we can instead declare the ports as unwired. capsule Top { part client : Client; part server1 : Server; part server2 : Server; // ... }; capsule Client { service behavior unwired port p : Protocol; // ... }; capsule Server { service behavior unwired port p~ : Protocol; // ... }; Note Only use unwired ports when required. It's strongly recommended to use wired ports whenever possible to enable the visualization of the connector structure in a structure diagram. When unwired ports are required you should write a comment that describes how they will be connected at run-time, since this often cannot easily be concluded by looking at the C++ code of the capsule. An unwired port is always a behavior port. In a structure diagram an unwired port is drawn with a hollow ellipse, while a wired behavior port is drawn with a filled ellipse. In the structure diagram below port q is wired while port p is unwired. An unwired port is either a service access point (SAP) or a service provision point (SPP) depending on the role it plays in a dynamic connection with another unwired port. The capsule that owns the SAP port uses it to subscribe to a service that is published by another capsule by means of an SPP port. The capsule with the SAP port is often called \"client\" or \"subscriber\" while the capsule with the SPP port is often called \"server\" or \"publisher\". Unwired ports get connected by means of registering them under a service name that should be unique in the application. Registration of unwired ports can either happen automatically when the container capsule instance is created, or programmatically at a later point in time. It's also possible to deregister unwired ports in order to disconnect them. You can specify how an unwired port should be registered by means of the following properties: registration specifies when an unwired port should be registered registration_name specifies the service name with which the port should be registered If you choose to register an unwired port programmatically (using the TargetRTS functions registerSPP and registerSAP ) you decide at registration time whether the port should be an SAP or SPP port. However, if you choose to instead let the port be registered automatically you need to declare the port as either a subscribe (SAP) or publish (SPP) port. Here is the same example again, but now with automatic registration of the unwired ports using the service name myService : capsule Client { subscribe behavior port sap [[rt::properties( registration_name = \"myService\") ]] : Protocol; // ... }; capsule Server { publish behavior port spp~ [[rt::properties( registration_name = \"myService\") ]] : Protocol; // ... }; Note that the keyword unwired is implicit when you declare a port as either a subscribe or publish port.","title":"Unwired Port"},{"location":"art-lang/#connector","text":"Connectors describe how events are routed within a capsule by connecting ports in its composite structure. They make it possible to see in a structure diagram which parts of a capsule that can communicate with each other. Each connector connects exactly two ports with each other. A connected port may either be a port of the capsule itself, or a port of a capsule that types one of its capsule parts. A few constraints decide if it's possible to connect two ports: 1) The ports must be wired. Unwired ports cannot be connected. 2) The ports must be typed by the same protocol. 3) The ports' conjugations must match. If the ports are at the same level in the capsule's structure (e.g. both ports belong to capsules typing capsule parts owned by the same capsule), then the connected ports must have the opposite conjugation. This is because events that are sent out from one of the ports must be able to be received by the other port. However, if the ports are at different levels in the capsule's structure (e.g. one of them belongs to a capsule typing a capsule part owned by the capsule and the other belongs to the capsule itself), then the ports must have the same conjugation. This is because in this case events are simply delegated from one capsule to another. The example below shows the structure diagram of a capsule Top where we can see two connectors. capsule Top { part ping : Pinger, pong : Ponger; connect ping.p1 with pong.p2; // ... }; capsule Internal { service behavior port i~ : PROTO; // ... }; capsule Pinger { service behavior port p1 : PROTO; // ... }; capsule Ponger { service behavior port p2~ : PROTO; part inner : Internal; connect p2 with inner.i; // ... }; The connector between p1 and p2 goes between two ports on the same level which is why these ports must have opposite conjugation. The connector between p2 and i goes between two ports at different levels which is why these ports must have the same conjugation. The non-behavior port p2 is a so called relay port (it just relays all events it receives to another port) and the connector between p2 and i is sometimes called a delegation connector to describe the fact that capsule Ponger uses it for delegating some of its responsiblities to the capsule Inner . Note that relay ports can be optimized away so they don't exist at run-time (i.e. at run-time port p1 can be directly connected to i ). A connector doesn't have a direction, so it doesn't matter in which order it connects the two ports. That is, connecting X with Y is equivalent to connecting Y with X.","title":"Connector"},{"location":"art-lang/#part","text":"A capsule can be decomposed by means of parts (also called \"capsule parts\" to emphasize that they are parts of a capsule). A part is a container that at run-time may hold one or many capsule instances. The part has a multiplicity that specifies the maximum number of capsule instances it can contain at run-time, and it has a type which is another capsule. All capsule instances must either be of that specific capsule type, or of a capsule type that inherits from it. It's common to name parts according to the capsule that types them. For example, a part typed by a capsule Controller may be called controller , ctrl or perhaps theController . By convention part names start with lowercase and use camelCase if the name consists of multiple words. There are three kinds of parts which determine how and when they will be populated with capsule instances. 1) Fixed part In a fixed part capsule instances are created automatically when the container capsule is created, and destroyed when the container is destroyed. Fixed parts by default have multiplicity 1. Such a part will always contain one and only one instance of the capsule that types the part. 2) Optional part In an optional part capsule instances don't have a strong lifetime relationship with the container capsule as is the case for fixed parts. The capsule instances can be created programmatically using the Frame service of the TargetRTS at some point after the container capsule has been created, and they can be destroyed before the container capsule is destroyed. However, at the latest they will be automatically destroyed when the container is destroyed. Optional parts by default have multiplicity 0..1. This means that it may either contain zero or one capsule instance at any point in time. The presence of zero in the multiplicity is what makes the part optional. 3) Plugin part A plugin part is similar to an optional part in that it is populated by capsule instances programmatically. However, the capsule instances are not created in the plugin part but instead imported into the plugin part from another part. Typically such a capsule instance is first created into an optional part, and then at some later point in time imported into a plugin part. Later it can be deported (i.e. removed) from the plugin part and perhaps imported into another plugin part. This makes it possible to create very dynamic composite structures where the same capsule instance can play different roles in different parts over time. Moving a capsule instance by deporting it from one plugin part and then importing it in another plugin part is more efficient than destroying the capsule instance in one optional part and then creating another capsule instance in another optional part. Plugin parts are typically used together with unwired ports . In general it's possible to import a capsule instance into more than one plugin part at the same time, but it can only be imported if its ports are not already bound in its current location. Plugin parts by default have multiplicity 0..1. In the example below the capsule C contains a few parts of different kinds and multiplicities. Note that you may declare multiple parts on the same line if they are of the same kind (both c and d below are optional parts). capsule C { part a : D; fixed part b : D[4]; optional part c : D, d : D[0..5]; plugin part e : D; part f : D[`COUNT`]; // ... }; Part a is fixed with multiplicity 1 since neither kind nor multiplicity is specified for it. Part b is also fixed (using the \"fixed\" keyword for more clarity) and with multiplicity 4. When an instance of capsule C is created 5 instances of capsule D will be automatically created. One of these instances will be inserted into part a and the others into part b . These instances will remain there until the C capsule instance is destroyed. Part c is optional with multiplicity 0..1. At run-time it can contain at most one instance of capsule D . Part d is also optional but can contain up to 5 instances of D as specified by its multiplicity 0..5. Part e is plugin with the default multiplicity 0..1. At run-time at most one instance of capsule D can be imported into it. That instance must already have been created in another part, for example part c . Part f uses a C++ expression for specifying the multiplicity. This can for example be useful if the multiplicity is defined in C++ as a macro, a template parameter or a constexpr. Parts can be shown in a structure diagram: Parts are shown as \"stacked\" if they have non-single multiplicity. Optional parts are shown with a \"diagonal\" background pattern, while plugin parts are shown with a \"double diagonal\" background pattern. Parts can also be shown in a class diagram: In the above diagram the filled diamonds show that there is a strong life-time relationship between a C instance and the instances of D that are located in the fixed and optional parts a , b , c and d , while this is not the case for the instance located in the plugin part d as shown by the hollow diamond.","title":"Part"},{"location":"art-lang/#part-with-capsule-factory","text":"If the capsule that types a part has a capsule constructor with custom constructor parameters, you can define a capsule factory for the part. Such a capsule factory consists of two code snippets that define how an instance of that capsule should be created and destroyed. rt::createFunction Defines how to create an instance of the capsule. For example, which constructor arguments to pass, which thread to use for running the created capsule instance, at which index to insert the capsule instance into the part (in case it has multiplicity > 1) etc. rt::destroyFunction Defines how to destroy an instance of the capsule. By default it's destroyed using the new operator. Here is an example where a part defines a capsule factory that specifies a create function. The create function gets the mandatory constructor parameters rtg_rts and rtg_ref as arguments, as well as an index argument that specifies the index where the created capsule instance would be inserted by default. part engine : Engine [[rt::createFunction]] ` return new Engine(rtg_rts, rtg_ref, true /* custom constructor arg */); `; Note that you may want to create a capsule factory for a part also for other reasons than passing custom constructor parameters. For example, you may want to change the default thread ( RTController* ) that should execute the created capsule instance, or you may want to instantiate an inherited capsule rather than the capsule that types the part.","title":"Part with Capsule Factory"},{"location":"art-lang/#state-machine","text":"State machines are used for specifying the behavior of capsules . It is also possible to provide a state machine for a passive class; see Class with State Machine for more information about that. In this chapter we focus on state machines in capsules. A state machine consists of states and transitions. During its lifetime a capsule instance transitions between the various states of its state machine, as a consequence of receiving messages on its behavior ports. When transitioning between two states one or several code snippets may execute. Such code may for example send messages to other capsule instances, something that may cause transitions to execute in their state machines. A state machine may also have pseudo states , which just like states may be connected with transitions, but that unlike states are not places where the state machine should stay for some time. For example, most pseudo states like junctions and entry/exit points merely act as connection points that make it possible to execute more than one transition when transitioning between two states. The notable exception is the choice in which actually the state machine may get stuck for ever, but this is something that should not happen in a correctly designed state machine.","title":"State Machine"},{"location":"art-lang/#state","text":"The states of a state machine are the places where the state machine may stay for some time while waiting for another message to arrive. States should have names that describe what is happening while the state machine stays there, or what has happened for the state machine to arrive there. For example, \"WaitForInit\", \"Processing\" or \"Terminated\". By convention state names start with uppercase. You can declare multiple states on the same line using a comma-separated list of state names. It can be good to write a comment in front of the state name, if you want to elaborate more on its meaning that what is possible in the name itself. Here is an example of a state machine with some states: capsule TrafficLight { statemachine { state WaitUntilServerReady, CycleLight; state /* pedestrians are crossing the street */ PedestriansCrossing; initial -> WaitUntilServerReady; WaitUntilServerReady -> CycleLight; CycleLight -> PedestriansCrossing; }; }; A state comment is not visible in a state diagram, but show up in a tooltip when putting the cursor on a reference to the state. They can thereby make it easier to understand a state machine. States may be nested to create a hierarchical state machine .","title":"State"},{"location":"art-lang/#entry-and-exit-action","text":"A state may have an entry and/or exit action which is a code snippet that runs whenever the state is entered and/or exited. state Walk { entry ` server.walk().send(); `; exit ` server.stop().send(); `; };","title":"Entry and Exit Action"},{"location":"art-lang/#transition","text":"A transition connects a source state (or pseudo state) to a target state (or pseudo state). When a capsule instance handles a message that was received on one of its behavior ports, one or several transitions may execute. It's not required to give a name to a transition, but it's possible and often makes the state machine easier to understand. At least triggered transitions (i.e. transitions where the source is a state) should have a name. A transition name can be choosen to describe what needs to have happened for the transition to execute, for example \"requestReceived\", \"timeout\" etc. By convention transition names start with lowercase and use camelCase if the name consists of multiple words. A triggered transition has one or several triggers which define when the transition can be triggered. Each trigger specifies a port and an event. The trigger can only trigger its transition if the received message is an instance of the specified event, and was received on the specified port. In addition it's possible to provide guard conditions that must be fulfilled for the trigger to trigger its transition. Such a guard condition can be specified for the transition, but also for each individual trigger. Here is an example of a capsule state machine with two triggered transitions requestReceived and timeout . It also contains an initial transition that has no name. capsule MyCap { statemachine { state Waiting, Processing; initial -> Waiting; requestReceived: Waiting -> Processing on com1.request, com2.request when ` return canHandleNow(); ` ` log.log(\"Handling request\"); log.commit(); handle(msg); `; timeout: Waiting -> Waiting on timer.timeout[`return zCount < 10;`]; }; }; Note the following: Triggers are specified as PORT.EVENT after the keyword on . You may specify multiple triggers separated by comma ( , ). A guard condition for the transition is specified after the when keyword, while a guard condition for an individual trigger is specified in square brackets ( [] ) after the trigger. A guard condition is actually a C++ statement that returns the boolean guard condition. Note Guard conditions should execute fast and have no side-effects. They are called frequently to decide which transition to execute when a message has arrived.","title":"Transition"},{"location":"art-lang/#initial-transition","text":"Every state machine needs exactly one initial transition. When the state machine starts to run, the first thing that happens is that the initial transition executes and takes the state machine to its first state. Therefore, an initial transition is a non-triggered transition and also cannot have a guard condition. But it can of course have an effect code snippet. The source of the initial transition is the initial pseudo state which is declared using the initial keyword. Just like for any transition it's optional to give a name to the initial transition (in fact it's often left unnamed). For capsule instances that are programmatically created (i.e. located in optional capsule parts) you can provide initialization data at the time of creation. This is a data object that can be accessed in the effect code of the initial transition. Here is an example: initial -> WaitForServerInit ` RTpchar str = *((RTpchar*) rtdata); `; Note Any type of data object can be passed as initialization data which means that rtdata is an untyped pointer that has to be casted to the expected type. A more type-safe way of passing initialization data is to define a constructor for a capsule. A capsule constructor can take any number of arguments, while with rtdata only one data object can be passed (even if you of course can group several data objects into a struct or class to circumvent this limitation). With capsule constructors you can pass initialization data also for capsule instances that are located in fixed parts. By default rtdata cannot be modified (it has type const void* ). However, by setting the const_rtdata_param property to false on the initial transition, you can make it non-const. One reason for doing this could be that the initial transition effect code wants to pass some data back to the code that creates the capsule instance. However, you must be very careful if you do this since this will only work if the creating code runs in the same thread that runs the initial transition. A more legitimate reason could be that you want to move the initialization data into a capsule variable, so you can access it later. Moving data can be more efficient than copying it. [[rt::properties(const_rtdata_param=false)]] initial -> Waiting ` pC = std::move(*((MyClass*) rtdata)); `;","title":"Initial Transition"},{"location":"art-lang/#internal-transition","text":"An internal transition doesn't change the active state and therefore doesn't have a target state. An internal transition is always a triggered transition. You define an internal transition inside the state to which it belongs. Here is an example: state Done { unexpected: on myPort.* ` std::cout << \"Unexpected event received! << std::endl; `; }; Note the usage of an asterisk ( * ) to specify that any event received on myPort will trigger the internal transition when the state machine is in the Done state. Such \"receive-any\" events can of course be used for a trigger of any transition, but can in particular be useful for internal transitions that should handle all messages received on a port that are not handled by other triggered transitions leaving substates of the state. If another event is added to the port's protocol in the future, such a trigger will handle the new event too without a need for being updated. Internal transitions are examples of so called self-transitions. To learn about other types of self-transitions see this chapter .","title":"Internal Transition"},{"location":"art-lang/#frequent-transition","text":"Sometimes you may have a state where one or a few outgoing transitions can be expected to execute much more frequently than others. You can then set a frequent property on the transition trigger that you expect will trigger the transition frequently. The Art compiler uses this information to optimize generated C++ code so that such transition triggers are evaluated before other triggers that are expected to trigger the transition less frequently. interrupted: Working -> Stopped on [[rt::properties( frequent=true )]] external.interrupt ` // Interrupted while working... `; Note The frequent property relies on optimization features in the C++ compiler that may or may not be available depending on which target compiler that is used. Only use frequent transitions if profiling has shown that you have a need to do this optimization.","title":"Frequent Transition"},{"location":"art-lang/#choice-and-junction","text":"Choices and junctions are pseudo states that make it possible to split transition flows in a state machine. That is, one incoming transition may be split into multiple outgoing transitions. Which of the outgoing transitions that will execute is decided by evaluating their guard conditions. For a junction the guard conditions are evaluated already before leaving the currently active state. Only if there exists a path of transitions where all guards are fulfilled, will the active state be exited and the transitions can execute. Otherwise the state machine stays in its current state and attempts to find another path of transitions to execute. For a choice the guard conditions are evaluated after leaving the current state, when reaching the choice itself. The outgoing transition which has a fulfilled guard will execute next. Note It's important that there always is an outgoing transition for a choice with a fulfilled guard condition. Otherwise the state machine will get stuck in the choice without any chance of getting out of it. Choices and junctions must have names, so they can be referenced as the source or target of transitions. You can choose to use a name that gives a hint about what conditions that are checked in the guards of the outgoing transitions. For example, isEnabled for a choice that checks a boolean condition and checkValue when the condition has some other type. If you follow this approach you can then name the outgoing transitions accordingly. For example true and false for a choice that checks a boolean condition. By convention choice and junction names start with lowercase and use camelCase if consisting of multiple words. Sometimes it may be difficult to come up with a good name and in that case you can choose something short and \"technical\" like j1 , check1 etc. Below is an example of a state machine containing a choice and a junction. statemachine { state First, Second, Third; t1: initial -> First; choice isEnabled; junction checkThreshold; switchTurned: First -> isEnabled; true: isEnabled -> Second when ` return isEnabled(); `; false: isEnabled -> Second when ` else `; timeout: First -> checkThreshold; low: checkThreshold -> Third when ` return t < LIMIT1; `; medium: checkThreshold -> Third when ` return t >= LIMIT1 && t < LIMIT2; `; high: checkThreshold -> Third; }; Note the use of the keyword else for defining an else-guard. An else-guard will be fulfilled when no other guard of other outgoing transitions is fulfilled. For choices it's good practise to always have exactly one transition with an else-guard to ensure that at least one guard condition will be fulfilled. Thereby we avoid the risk of the state machine getting stuck in the choice. Else-guards can also be useful for junction transitions, but there they are more optional. You can also define an else-transition for a choice or junction by simply omitting the guard condition. This is consistent with triggered transitions where the absense of a guard condition is equivalent to a guard condition that always is fulfilled. See the transition high in the above example. Guard conditions should be mutually exclusive so that the order in which they are evaluated doesn't matter. Junctions can also be used for merging multiple incoming transition flows into a single outgoing transition. This can for example be useful if you want to reuse a transition path in the state machine for several triggered transitions. statemachine { state S1, S2; junction j1; initial -> S1; t1: S1 -> j1 on port1.e1 ` // handle e1 `; t2: S1 -> j1 on port2.e2 ` // handle e2 `; t3: S1 -> j1 on port3.e3 ` // handle e3 `; common: j1 -> S2 ` // common code here `; }; Of course, in the above simple example the same code reuse could also be obtained by putting the common code in a capsule member function which is called by each of the incoming transitions. But if the common transition is followed by more non-triggered transitions the above approach is more feasible.","title":"Choice and Junction"},{"location":"art-lang/#hierarchical-state-machine","text":"A state machine is hierarchical if it contains at least one composite state, i.e. a state with a nested state machine. A transition that is triggered in the enclosing state machine (i.e. the state machine that contains the composite state) should enter a composite state by specifying an entry point of the composite state as the target. In the nested state machine another transition can connect that entry point to a state in the nested state machine. A transition in the nested state machine may specify an exit point of the composite state as the target. In the enclosing state machine another transition can connect that exit point to a state in the enclosing state machine. Entry and exit points are pseudo states that need to be named. The names can be chosen to give a hint about when the composite state is entered or exited through them, for example systemStarted or errorDetected . If you want you can prefix the names with ep or ex . It's also common to use short and \"technical\" names like ep1 or ex1 if a more descriptive name doesn't make sense. By convention entry and exit point names start with lowercase and use camelCase if consisting of multiple words. It's also possible to directly enter a composite state without using an entry point. In this case the behavior will depend on whether the composite state is entered for the first time or not. If it is for the first time, the initial transition of the nested state machine will execute after the transition that targets the composite state has executed. Otherwise the composite state will instead be entered using deep history , i.e. by activating the state in the nested state machine that was most recently active (and recursively if that state again is a composite state). Note It's recommended to always enter a composite state using an entry point as the behavior then doesn't depend on if the state was previously entered or not. Below is an example of an hierarchical state machine with a composite state CompositeState that contains a nested state machine. Note that you can declare multiple entry or exit points on the same line. statemachine { initial -> CompositeState.ep1; state CompositeState { state Nested; entrypoint ep1, ep2; exitpoint ex1; initial -> Nested; ep1 -> Nested; Nested -> ex1; ep2 -> history*; }; state Other; CompositeState.ex1 -> Other; Other -> CompositeState.ep2; }; Note that a dot ( . ) is used as scope resolution operator, to make it possible to reference an entry or exit point from the enclosing state machine. Inside the nested state machine the entry and exit points are directly accessible without use of the scope resolution operator (using it there would be an error). It is possible to only connect an entry point on the \"outside\". Entering such an entry point will behave in the same way as entering the composite state without using an entry point (see above). It's therefore not recommended. In the same way it's possible to exit a composite state using an exit point that only is connected on the \"inside\". In this case the composite state is not exited and instead the previously active substate again becomes active (recursively, just like for deep history ). This is also not recommended, unless the transition is a local transition .","title":"Hierarchical State Machine"},{"location":"art-lang/#deep-history","text":"Every nested state machine has an implicit pseudo state with the name history* (in state diagrams it's shown as H* to save space). It can be used as a target for any transition inside the nested state machine. When it is reached, the state machine will restore the previously active substate. If that state again is a composite state, its previously active substate will also be restored. This goes on recursively for all nested state machines (which is why it's called a deep history). In the example above we can see that the transition from ep2 targets the deep history pseudo state. This means that if the Nested substate is active and then the transition to ex1 gets triggered, the state Other becomes active. If then the transition to ep2 gets triggered the CompositeState will be entered using deep history so that the Nested substate will again become active.","title":"Deep History"},{"location":"art-lang/#local-transition","text":"A transition in a nested state machine where the source is an entry point and the target is an exit point, and these entry/exit points only are connected on the \"inside\", is a local transition . A local transition is a self-transition that behaves something in between an internal transition and a regular (a.k.a. external) self-transition. An internal transition defined on a composite state handles a message without exiting neither that composite state, nor any of its substates. However, a local transition will exit the composite state and then enter it again, but it will not do this for the substate that is active in the composite state. Hence, if a composite state has an exit action it will be called for the composite state, but not for the active substate. An external self-transition on the other hand will exit both the composite state and all active substates recursively, and then enter these states again. Exiting happens bottom-up which means that the deepest nested substate will first be exited, then its parent state, and so on until the top composite state is exited. Entering happens in the opposite order, i.e. in a top-down fashion. Let's look at an example to understand the difference between these three kinds of self-transitions: statemachine { initial -> SelfTransitionExample; state SelfTransitionExample { state Nested1 { state Nested2; }; internal: on port1.e1 ` // Internal transition `; entrypoint e1; exitpoint e2; local: e1 -> e2 ` // Local transition `; }; external: SelfTransitionExample -> SelfTransitionExample on port2.e2 ` // External transition `; }; Assume the currently active state configuration is { SelfTransitionExample , Nested1 , Nested2 } when one of the self-transitions get triggered: Internal transition ( internal ) No state is exited and the active state configuration remains unchanged. Local transition ( local ) 1) Nested2 is exited. 2) Nested1 is exited. 3) local executes. 4) Nested1 is entered. 5) Nested2 is entered. External transition ( external ) 1) Nested2 is exited. 2) Nested1 is exited. 3) SelfTransitionExample is exited. 4) external executes. 5) SelfTransitionExample is entered. 6) Nested1 is entered. 7) Nested2 is entered.","title":"Local Transition"},{"location":"art-lang/#class-with-state-machine","text":"Art allows you to create passive classes with state machines. This can be an alternative to using a capsule in case you only need a passive stateful data object, and don't need the ability to send events to it, or to let it execute in its own context. A class with a state machine is more lightweight than a capsule at runtime. Transitions in a class state machine are triggered by calling trigger operations on the class. A trigger operation is similar to a regular member function in C++, but does not have a code behavior of its own. Instead, when you call a trigger operation on an object of a class with a state machine it may trigger a transition in the class' state machine. That transition may have an effect code snippet that will execute. A trigger operation can have parameters which allows you to pass data when calling them. Those parameters can be accessed in the transition that is triggered by it. Below is an example of a class with a state machine with two trigger operations initialize and finalize . Note that you can define multiple trigger operations on the same line. class DataObject { /* Trigger Operations */ trigger initialize(`int` data), finalize(); /* State Machine */ statemachine { state Initial, Initialized, Finalized; initial -> Initial; init: Initial -> Initialized on initialize(`int`) ` // Initialized int i = data; `; Initialized -> Finalized on finalize() ` // Finalized `; }; }; Just like for C++ member functions, trigger operations support overloading. That is, you can have many trigger operations with the same name as long as their full signatures are unique. The signature of a trigger operation consists of its name and the types of all its parameters. When you reference a trigger operation with parameters as a transition trigger, you need to include the types of the parameters (see the trigger for the init transition above). The same transition can be triggered by multiple trigger operations (just like a transition in a capsule state machine can be triggered by multiple events). However, in that case those trigger operations should agree on the names and types of their parameters so that the transition effect code can access them in a way that works regardless of which of the trigger operations that will trigger the transition. Names of classes with state machines by convention start with uppercase, while names of trigger operations and their parameters by convention start with lowercase and use camelCase if the name consists of multiple words. A common design pattern is to let a class-with-statemachine instance be managed by a single capsule instance. This means that the capsule instance is responsible both for creating, using and finally destroying the class-with-statemachine instance. If you follow this pattern it is thread-safe to for example call public member functions defined on the capsule from a transition in the class state machine. This can for example be used as a means for the class state machine to send events through the ports of the capsule (i.e. it can call a capsule member function that sends the event). However, to avoid exposing the full capsule functionality to the class state machine it's recommended to define an interface (i.e. abstract C++ class) which the capsule can implement. This interface can contain only those member functions which the class needs to access from its state machine. A class state machine can use the same constructs as a capsule state machine with a few exceptions: The initial transition cannot access initialization data as can a capsule's initial transition . Instead you can define one or several constructors for the class with parameters needed for passing initialization data when the class-with-statemachine instance is created. See Constructor for more information. Frequent transitions are not supported. The state machine can be hierarchical but the deep history pseudo state is not supported. Instead the shallow history pseudo state can be used. Even if it's possible for a class with a state machine to inherit from another class with a state machine, this doesn't mean that the state machines will be inherited as is the case for capsule inheritance. Read more about this in Inheritance . A class with state machine can have the same code snippets as a capsule.","title":"Class with State Machine"},{"location":"art-lang/#constructor","text":"By default the initial transition of a class state machine executes at the time of constructing the class-with-statemachine instance. This happens because the generated default constructor will call an operation rtg_init1() which contains the code from the initial transition. If you want to wait with \"starting\" the state machine until a later point in time you need to define your own parameterless constructor which doesn't call this function. You can define any constructors you need on a class with a state machine. They are regular C++ constructors and allow to pass initialization data when creating a class-with-statemachine instance. Remember to call the rtg_init1() function in all such constructors, if you want the state machine to start at the time of creating the class-with-statemachine instance. Here is an example of a class with a state machine that has a user-defined constructor: class PC { [[rt::decl]] ` private: double m_data; public: PC(double data); ` [[rt::impl]] ` PC::PC(double data) : m_data(data) { rtg_init1(); } ` statemachine { state First; initial -> First ` // State machine started `; }; };","title":"Constructor"},{"location":"art-lang/#shallow-history","text":"Every nested state machine has an implicit pseudo state with the name history (in state diagrams it's shown as H to save space). It can be used as a target for any transition inside the nested state machine. When it is reached, the state machine will restore the previously active substate. However, if that state again is a composite state it's previously active substate will not be restored. This is in contrast to the deep history for capsule state machines, and is why for a class state machine this pseudo state is referred to as a shallow history. Here is an example: class MyClass { statemachine { state First { entrypoint ep1; ep1 -> history; }; initial -> First.ep1; }; };","title":"Shallow History"},{"location":"art-lang/#inheritance","text":"By using inheritance you can reuse and customize generic ( base ) Art elements into more specific ( derived ) Art elements. An Art element can inherit either from one or several other Art elements, and/or it can inherit from one or several C++ classes. The derived Art element can redefine elements of the base element. The redefining element (located in the derived element) can change one or several properties of the redefined element (located in the base element). This is very similar to how inheritance works in C++, with the difference that in C++ a redefining element has more restrictions on what properties that can be changed in the redefined element. For example, a redefining member function (known as an overridden member function in C++ terminology) must keep the same signature as the redefined member function (known as a virtual base member function in C++ terminology), and can only (in fact, must) change its implementation. In some cases Art inheritance not only allows to redefine inherited elements, but also to completely exclude them. An excluded element is not present in the derived element, so exclusion can be seen as a special form of redefinition where the whole element is removed in the derived element. In C++ it's not possible to exclude any inherited members.","title":"Inheritance"},{"location":"art-lang/#capsule-inheritance","text":"A capsule can inherit from another capsule. Only one base capsule is allowed; multiple inheritance is not supported for capsules. In addition a capsule can inherit from any number of C++ classes (or structs). The derived capsule is type compatible with the base capsule in the sense that if you have a capsule part typed by the base capsule, you can at runtime incarnate it with instances of the derived capsule. Capsule inheritance has multiple dimensions. One dimension is the usual C++ inheritance between classes (remember that a capsule is an active class). In this dimension it is for example possible to redefine (a.k.a override) a virtual member function defined in the base capsule or in another base C++ class. But there is also a second dimension where the state machine of the derived capsule will implicitly inherit from the state machine of the base capsule. This makes it possible to redefine transitions and states. For example, a redefining transition in a derived capsule can change the effect code, the guard condition or the target state or pseudo state. And a redefining state in a derived capsule can change the entry or exit action, as well as any substate or subtransition in case the state is composite and has a nested state machine. It's also possible to completely exclude a state or a transition, either in the top capsule state machine, or in a nested state machine. Below is an example of a capsule D that inherits from another capsule B . In addition the capsule D inherits from two C++ classes IDataManager and IController . capsule B { statemachine { state BS, BS2; Initial: initial -> BS; }; }; capsule D : B, `IDataManager`, `IController` { [[rt::decl]] ` // IDataManager impl public: void manageData() override; // IController impl public: void control() override; ` [[rt::impl]] ` // impl of manageData() and control() ` statemachine { state DS; state exclude BS2; redefine Initial: initial -> DS; }; }; In the example we can see that D overrides functions from the base C++ classes that are assumed to be virtual (or pure virtual). For brevity the implementations of these functions have been omitted but would be placed in the rt::impl code snippet. We can also see an example of a state machine redefinition. The initial transition Initial of B 's state machine is redefined in D 's state machine so that it targets state DS instead of state BS . In the state diagram of D the state BS and the initial pseudo state are drawn with gray color and dashed outline, to show that they are inherited. The transition Initial is also drawn in grayed with dashed outline but with a blue label to show that it's redefining the inherited initial transition. The state BS2 is excluded in D 's state machine. In state diagrams excluded elements are by default shown with a \"crossed\" background, but by setting a diagram preference it's also possible to completely hide them from the diagram. Note that to be able to redefine the initial transition of B it is necessary to give it a name (so that it can be referenced as redefined from D ). This is yet another reason why it's good practise to give names to transitions, even if it's not mandated. But, of course, if you want to prevent anyone from creating a derived capsule with a state machine that redefines a certain transition, you can accomplish that by not giving a name to that transition. In effect, an unnamed transition is final , i.e. cannot be overridden or excluded. The rule that a capsule state machine must have exactly one initial transition also applies to a derived capsule. Therefore, when you introduce inheritance between two existing capsules, you typically first get an error saying that the derived capsule has two initial transitions (one inherited, and one locally defined). You then need to decide if you want to either remove the initial transition in the derived capsule, or (like in the above example) instead redefine the initial transition. Capsule inheritance also has a third dimension, which relates to its structure. Parts and ports defined in the base capsule are inherited by the derived capsule. Just like for states and transitions, it's possible to redefine or exclude a part or a port. A redefining port can change the type (i.e. protocol ), multiplicity and the notification property of the redefined port. A redefining part can change the type, multiplicity and kind (fixed, optional or plugin) of the redefined part. Below is an example of a capsule DPPI that inherits from another capsule BPPI . The port port1 and the part part1 is redefined, while the port port2 and part part2 are excluded. capsule BPPI { service port port1 : PR1; port port2 : PR1; part part1 : Cap1; part part2 : Cap1; statemachine { state State; initial -> State; }; }; capsule DPPI : BPPI { service notify port redefine port1 : PR2[10]; optional part redefine part1 : Cap2[0..20]; part exclude part2; port exclude port2; statemachine { state State2; }; };","title":"Capsule Inheritance"},{"location":"art-lang/#class-inheritance","text":"A class with state machine can inherit from other classes with state machines, or from C++ classes (or structs). Multiple inheritance is supported. Contrary to capsule inheritance , class inheritance does not imply inheritance between the state machines in the derived and base classes. This means it's not possible to redefine or exclude states and transitions in an inherited class state machine. Nor is it possible to redefine trigger operations. In fact, the derived class will have two state machines (its own, plus the one inherited from the base class) and these two state machines will execute independently of each other. That is, class inheritance is more a way of aggregating state machines rather than reusing and redefining them. Because of this, it's rather unusual to let two classes with state machines inherit each other. It's more useful to let a class with state machine inherit from other C++ classes. Below is an example of a class with state machine that inherits from two C++ classes DataContainer<CData> and IDisposable . class DataClass : `DataContainer<CData>`, `IDisposable` { [[rt::decl]] ` void dispose() override; // From IDisposable ` [[rt::impl]] ` void DataClass:dispose() { // impl } ` statemachine { state State; initial -> State; }; };","title":"Class Inheritance"},{"location":"art-lang/#protocol-inheritance","text":"A protocol may inherit events from another protocol. Only one base protocol is allowed; multiple inheritance is not supported for protocols. Inherited events can be redefined, but not excluded. A redefining event in a derived protocol can change the type of the event parameter as defined in the base protocol. In the example below, the protocol ExtendedMachineEvents adds one more in-event stop to the inherited MachineEvents protocol. It also redefines the startDeferred event to change its parameter type. protocol MachineEvents { in start(); in startDeferred(`unsigned long` /* milliseconds */); out success(); out error(`std::string` /* error message */); }; protocol ExtendedMachineEvents : MachineEvents { in stop(); in redefine startDeferred(`unsigned long long`); };","title":"Protocol Inheritance"},{"location":"art-lang/#template","text":"A template is a type that is parameterized by means of template parameters to make it more generic. When a template is used (a.k.a. instantiated), actual template parameters must be provided that match the formal template parameters defined in the template. Both capsules and classes can have template parameters. Just like in C++ two kinds of template parameters are supported: Type template parameter Replaced with a type when the template is instantiated. Non-type template parameters Replaced with a non-type, for example a constant value, when the template is instantiated. Template parameters may have defaults that will be used if a matching actual template parameter is not provided when instantiating the template. Below is an example of a capsule and a class with template parameters, some of which have defaults specified. The keywords typename and class can both be used for defining a type template parameter. A non-type template parameter is defined by specifying its type as a C++ code snippet. template <typename T = `int`, `int` p1 = `5`> capsule TemplateCapsule { [[rt::decl]] ` void func(T arg1) { // impl } ` service port mp : MachineEvents[`p1`]; statemachine { state State; initial -> State; }; }; template <typename T, class U, `int` p1> class TemplateClass : `Base<T,U,p1>` { statemachine { state State; initial -> State; }; }; Template parameters can only be used from C++ code snippets, and above you see some examples of how they can be used. It's not possible to instantiate a template in Art itself. For example, even if class Base above was defined as an Art class, a C++ code snippet has to be used since it has template parameters.","title":"Template"},{"location":"art-lang/#property","text":"Properties are name-value pairs that provide a generic mechanism for augmenting Art elements with extra data. Such data can be utilized by tools that operate on a parsed Art file, such as the code generator and semantic checker. Most Art elements can have properties and the syntax for specifying properties is the same regardless of the kind of element. However, different kinds of Art elements can have different properties. For Art elements that have a name, properties are specified right after the name. For elements without name, properties are specified before the element itself. In both cases the syntax looks like this: [[rt::properties( <property name>=<property value>, <property name>=<property value>, ... <property name>=<property value> )]] All properties have a default value, so you only need to specify a property if you want to set it to something else. The default values have been chosen so that you in most cases don't need to specify any properties at all. A property has a type, and its value must conform to that type. The following property types are supported: Boolean Boolean properties have a value that is either true or false . If you want to set a boolean property to true you can use a shorthand syntax where you just specify the property name. For example: capsule CapProp [[rt::properties( generate_file_impl=false, generate_file_header )]] { // ... }; Writing generate_file_header is equivalent to writing generate_file_header=true . However, this particular property has the default value true and hence doesn't need to be set at all. Integer Integer properties have a numeric value (>= 0). Here is an example: protocol XProtocol [[rt::properties( version=1 )]]{ // ... }; String String properties have a string value, enclosed in double quotes. Here is an example: class MC [[rt::properties( rule_config=\"E0022\" )]]{ // ... }; Enumeration A property of enumeration type has a value that references a literal of the enumeration. There are different enumerations used for different properties. The best way to learn about what enumeration literals that are available for a certain property is to use the Content Assist feature in the Art file editor. Place the cursor after the equal sign, and press Ctrl + Space . Here is an example of defining a property of enumeration type: class MC [[rt::properties( kind=struct )]]{ // ... }; Note that in some cases the name of an enumeration literal starts with underscore ( _ ) to prevent it from clashing with the set of Art keywords . Below is a table that lists all properties that can be used on different kinds of Art elements. Each property is described in a section of its own below the table. Art Elements Property Type Default Capsule , Class generate_file_header Boolean true Capsule , Class generate_file_impl Boolean true Capsule , Class , Protocol , Port , Initial transition , Triggered transition Trigger rule_config String \"\" Class , Protocol version Integer 0 Class generate_descriptor Enumeration (true, false, manual) true Class kind Enumeration (_class, struct, union) _class Class generate_class Boolean true Class generate_statemachine Boolean true Class const_target_param_for_decode Boolean false Class default_constructor_generate Boolean true Class default_constructor_explicit Boolean false Class default_constructor_inline Boolean false Class default_constructor_default Boolean false Class default_constructor_delete Boolean false Class default_constructor_visibility Enumeration (public, protected, private) public Port registration Enumeration (automatic, automatic_locked, application) automatic Port registration_name String \"\" Initial transition , Triggered transition const_rtdata_param Boolean true Trigger frequent Boolean false","title":"Property"},{"location":"art-lang/#generate_file_header","text":"By default a capsule or class is translated to one header file ( .h ) and one implementation file ( .cpp ). Set this property to false to prevent generation of the header file, for example if you prefer to write it manually.","title":"generate_file_header"},{"location":"art-lang/#generate_file_impl","text":"By default a capsule or class is translated to one header file ( .h ) and one implementation file ( .cpp ). Set this property to false to prevent generation of the implementation file, for example if you prefer to write it manually.","title":"generate_file_impl"},{"location":"art-lang/#rule_config","text":"This property is used for configuring validation rules for an Art element. Read more about this here .","title":"rule_config"},{"location":"art-lang/#version","text":"TODO","title":"version"},{"location":"art-lang/#generate_descriptor","text":"By default a type descriptor will be generated for each class . The TargetRTS uses the type descriptor to know how to initialize, copy, move, destroy, encode or decode an instance of that class. Set this property to false for classes that don't need a type descriptor. Set it to manual if the class needs a type descriptor but you want to implement it manually rather than using the implementation that is generated by default. Note that even if you set this property to true so that a default type descriptor is generated, you can still override individual type descriptor functions for the class.","title":"generate_descriptor"},{"location":"art-lang/#kind","text":"By default a class is translated to a C++ class. You can use this property to instead translate it to a struct or union .","title":"kind"},{"location":"art-lang/#generate_class","text":"If set to false no C++ code will be generated for the class.","title":"generate_class"},{"location":"art-lang/#generate_statemachine","text":"If set to false code generation for the class' state machine will be suppressed. You can use this if the state machine is informal, and you prefer to implement it manually in another way.","title":"generate_statemachine"},{"location":"art-lang/#const_target_param_for_decode","text":"By default a decode function uses a non-const target parameter. This is because usually a decode implementation must call non-const functions on the decoded object to populate it with data from the decoding. However, if it doesn't need to call such functions you can set this property so that the target parameter is declared as const.","title":"const_target_param_for_decode"},{"location":"art-lang/#default_constructor_generate","text":"If set to false a default (i.e. parameterless) constructor will not be generated for the class.","title":"default_constructor_generate"},{"location":"art-lang/#default_constructor_explicit","text":"If set to true the default (i.e. parameterless) constructor will be declared as explicit.","title":"default_constructor_explicit"},{"location":"art-lang/#default_constructor_inline","text":"If set to true the default (i.e. parameterless) constructor will be declared as inline. It's implementation will then be generated into the header file.","title":"default_constructor_inline"},{"location":"art-lang/#default_constructor_default","text":"If set to true the default (i.e. parameterless) constructor will be declared as defaulted. This tells the compiler to synthesize a default constructor even if one normally would not be synthesized (for example because there is a user-defined constructor with parameters).","title":"default_constructor_default"},{"location":"art-lang/#default_constructor_delete","text":"If set to true the default (i.e. parameterless) constructor will be declared as deleted? This will cause the compiler to generate an error if it is invoked. This can be used for preventing objects of the class to be created.","title":"default_constructor_delete"},{"location":"art-lang/#default_constructor_visibility","text":"This property can be used for setting the visibility of the default (i.e. parameterless) constructor. By default it will be public but you can change it either to protected or private .","title":"default_constructor_visibility"},{"location":"art-lang/#registration","text":"This property specifies how to register an unwired port at runtime. The default is automatic which means the port will be registered automatically when the container capsule instance is initialized. The value automatic_locked has the same meaning but the registration will be \"locked\" so that any future attempt to deregister it, or register it under a different name, will fail. Set the property to application to programmatically register the port using the functions registerSPP() and registerSAP() respectively.","title":"registration"},{"location":"art-lang/#registration_name","text":"This property specifies the name to use when registering a port at runtime. By default the port name is used, but it can be overridden using this property.","title":"registration_name"},{"location":"art-lang/#const_rtdata_param","text":"If set to false the rtdata parameter in the transition function will be non-const. It can therefore be modified, which for example can avoid copying received message data and instead move it using its move constructor or move assignment operator.","title":"const_rtdata_param"},{"location":"art-lang/#frequent","text":"Triggers for which this property is true will lead to generated code that handles these triggers faster than other triggers. This is done by placing their if-statements early in the rtsBehavior function to ensure that as little code as possible needs to execute when dispatching a message for a frequent trigger.","title":"frequent"},{"location":"building/","text":"Transformation Configurations Incremental code generation Navigation from Art to C++ and vice versa Code-to-Art synchronization Building from the UI Building from command-line","title":"Building"},{"location":"ide-guide/","text":"Art editor Outline view Diagrams Type Hierarchy Problems view","title":"Working with Art"},{"location":"installing/","text":"Installing RTist in Code can be installed on top of Visual Studio Code or Eclipse Theia. The latest version of RTist in Code is available on the Visual Studio Marketplace and on the Open VSX Registry . To install that version into Visual Studio Code or Eclipse Theia follow these steps: 1) Click \"Extensions\" in the activity bar to open the Extensions view. 2) Type \"rtist\" in the search field. 3) Click the \"Install\" button to install the RTist in Code extension XXX SCREENSHOT MISSING Once the installation is finished you will see RTist in Code appear in the \"Installed\" section of the Extensions view: Install from VSIX Another way to install RTist in Code is to use a .vsix file. This can be useful if you want to install another version than the latest. You can download .vsix files for all released versions of RTist in Code from both the Visual Studio Marketplace and the Open VSX Registry . Once you have downloaded the .vsix file follow these steps to install it: 1) If you already have a version of RTist in Code installed, you can manually uninstall it first (see Uninstalling ). Note that this step is usually not required since the newly installed version of the extension will automatically replace the old one. 2) Open the menu of the Extensions view and select the command \"Install from VSIX\". 3) In the file dialog that appears, select the .vsix file to install. If the installation completes successfully you should see the following message (the \"Reload Now\" button will only show if you already had another version of RTist in Code installed): If instead the installation fails, this message will tell you the reason. One common reason for failure is that your version of Visual Studio Code or Eclipse Theia is not compatible (i.e. too old) for RTist in Code. If you are unsure about which version of RTist in Code you have installed, you can see the version in the extension's tooltip: It should also be noted that it's possible to directly install any published version of RTist in Code by using the \"Install Another Version\" command that is available in the context menu of an extension shown in the \"Installed\" section. Portable Mode Installation You can install multiple versions of RTist in Code by using the portable mode of Visual Studio Code. See Portable Mode for how to install Visual Studio code in portable mode, which will allow you to install a version of RTist in Code that won't affect other Visual Studio Code installations on the machine. Portable mode also allows to move or copy an installation from one machine to another, which makes it useful in scenarios where installs should be centralized in an organization. Post-Installation Configuration After a successful installation you need to perform a few configuration steps before you can start to use RTist in Code. Setup Java RTist in Code uses a Java language server and hence needs a Java Virtual Machine (JVM). More specifically it requires a Java 11 JVM. If an appropriate JVM cannot be found when the RTist in Code extension is activated (which for example happens the first time you open an Art file), you will receive an error message. RTist in Code follows the steps below in priority order when it looks for an appropriate JVM to use: 1) The configuration setting rtistic.languageServer.jvm is examined. If it specifies a path to a JVM it will be used. You can edit this configuration setting by invoking File - Preferences - Settings and then type the configuration setting id mentioned above in the filter box. This setting needs to be edited in the settings.json file. 2) The environment variable JAVA_HOME is examined. If it specifies a path to a JVM it will be used. 3) An attempt is made to launch the java command without using a path. The first JVM found in the system path, if any, will be used. You may also need to adjust the arguments for the JVM. By default the JVM is launched with the below arguments: -Xverify:none -Xmx4024m To change the JVM arguments set the configuration setting rtistic.languageServer.jvmArgs . Setup License If you want to use all features of RTist in Code you need a license. Setup C++ Build Tools When RTist in Code builds generated C++ code it uses C++ build tools such as a make tool, a C++ compiler, a C++ linker etc. These tools need to be in the path when you start Visual Studio Code or Eclipse Theia. If you have multiple C++ build tools installed, make sure the correct ones are present in the path before launching Visual Studio Code or Eclipse Theia. For example, if you use the Microsoft C++ compiler, it's recommended to launch from a Visual Studio native tools command prompt with the correct version (e.g. 32 bit or 64 bit). Build errors caused by inconsistent versions of C++ build tools being used can be tricky to find. Uninstalling To uninstall RTist in Code follow these steps: 1) Click \"Extensions\" in the left side-bar. 2) Find the RTist in Code extension in the \"Installed\" section, right-click on it, and select the command \"Uninstall\". Once the uninstallation is finished you will no longer see RTist in Code in the \"Installed\" section.","title":"Installing"},{"location":"installing/#installing","text":"RTist in Code can be installed on top of Visual Studio Code or Eclipse Theia. The latest version of RTist in Code is available on the Visual Studio Marketplace and on the Open VSX Registry . To install that version into Visual Studio Code or Eclipse Theia follow these steps: 1) Click \"Extensions\" in the activity bar to open the Extensions view. 2) Type \"rtist\" in the search field. 3) Click the \"Install\" button to install the RTist in Code extension XXX SCREENSHOT MISSING Once the installation is finished you will see RTist in Code appear in the \"Installed\" section of the Extensions view:","title":"Installing"},{"location":"installing/#install-from-vsix","text":"Another way to install RTist in Code is to use a .vsix file. This can be useful if you want to install another version than the latest. You can download .vsix files for all released versions of RTist in Code from both the Visual Studio Marketplace and the Open VSX Registry . Once you have downloaded the .vsix file follow these steps to install it: 1) If you already have a version of RTist in Code installed, you can manually uninstall it first (see Uninstalling ). Note that this step is usually not required since the newly installed version of the extension will automatically replace the old one. 2) Open the menu of the Extensions view and select the command \"Install from VSIX\". 3) In the file dialog that appears, select the .vsix file to install. If the installation completes successfully you should see the following message (the \"Reload Now\" button will only show if you already had another version of RTist in Code installed): If instead the installation fails, this message will tell you the reason. One common reason for failure is that your version of Visual Studio Code or Eclipse Theia is not compatible (i.e. too old) for RTist in Code. If you are unsure about which version of RTist in Code you have installed, you can see the version in the extension's tooltip: It should also be noted that it's possible to directly install any published version of RTist in Code by using the \"Install Another Version\" command that is available in the context menu of an extension shown in the \"Installed\" section.","title":"Install from VSIX"},{"location":"installing/#portable-mode-installation","text":"You can install multiple versions of RTist in Code by using the portable mode of Visual Studio Code. See Portable Mode for how to install Visual Studio code in portable mode, which will allow you to install a version of RTist in Code that won't affect other Visual Studio Code installations on the machine. Portable mode also allows to move or copy an installation from one machine to another, which makes it useful in scenarios where installs should be centralized in an organization.","title":"Portable Mode Installation"},{"location":"installing/#post-installation-configuration","text":"After a successful installation you need to perform a few configuration steps before you can start to use RTist in Code.","title":"Post-Installation Configuration"},{"location":"installing/#setup-java","text":"RTist in Code uses a Java language server and hence needs a Java Virtual Machine (JVM). More specifically it requires a Java 11 JVM. If an appropriate JVM cannot be found when the RTist in Code extension is activated (which for example happens the first time you open an Art file), you will receive an error message. RTist in Code follows the steps below in priority order when it looks for an appropriate JVM to use: 1) The configuration setting rtistic.languageServer.jvm is examined. If it specifies a path to a JVM it will be used. You can edit this configuration setting by invoking File - Preferences - Settings and then type the configuration setting id mentioned above in the filter box. This setting needs to be edited in the settings.json file. 2) The environment variable JAVA_HOME is examined. If it specifies a path to a JVM it will be used. 3) An attempt is made to launch the java command without using a path. The first JVM found in the system path, if any, will be used. You may also need to adjust the arguments for the JVM. By default the JVM is launched with the below arguments: -Xverify:none -Xmx4024m To change the JVM arguments set the configuration setting rtistic.languageServer.jvmArgs .","title":"Setup Java"},{"location":"installing/#setup-license","text":"If you want to use all features of RTist in Code you need a license.","title":"Setup License"},{"location":"installing/#setup-c-build-tools","text":"When RTist in Code builds generated C++ code it uses C++ build tools such as a make tool, a C++ compiler, a C++ linker etc. These tools need to be in the path when you start Visual Studio Code or Eclipse Theia. If you have multiple C++ build tools installed, make sure the correct ones are present in the path before launching Visual Studio Code or Eclipse Theia. For example, if you use the Microsoft C++ compiler, it's recommended to launch from a Visual Studio native tools command prompt with the correct version (e.g. 32 bit or 64 bit). Build errors caused by inconsistent versions of C++ build tools being used can be tricky to find.","title":"Setup C++ Build Tools"},{"location":"installing/#uninstalling","text":"To uninstall RTist in Code follow these steps: 1) Click \"Extensions\" in the left side-bar. 2) Find the RTist in Code extension in the \"Installed\" section, right-click on it, and select the command \"Uninstall\". Once the uninstallation is finished you will no longer see RTist in Code in the \"Installed\" section.","title":"Uninstalling"},{"location":"notices/","text":"Notices Licensed Materials - Property of HCL Limited. \u00a9 Copyright HCL Technologies Limited This information was developed for products and services offered in the US. HCL may not offer the products, services, or features discussed in this document in other countries. Consult your local HCL representative for information on the products and services currently available in your area. Any reference to an HCL product, program, or service is not intended to state or imply that only that HCL product, program, or service may be used. Any functionally equivalent product, program, or service that does not infringe any HCL intellectual property right may be used instead. However, it is the user's responsibility to evaluate and verify the operation of any non-HCL product, program, or service. HCL may have patents or pending patent applications covering subject matter described in this document. The furnishing of this document does not grant you any license to these patents. You can send license inquiries, in writing, to: HCL 330 Potrero Ave. Sunnyvale, CA 94085 USA Attention: Office of the General Counsel For license inquiries regarding double-byte character set (DBCS) information, contact the HCL Intellectual Property Department in your country or send inquiries, in writing, to: HCL 330 Potrero Ave. Sunnyvale, CA 94085 USA Attention: Office of the General Counsel HCL TECHNOLOGIES LTD. PROVIDES THIS PUBLICATION \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Some jurisdictions do not allow disclaimer of express or implied warranties in certain transactions, therefore, this statement may not apply to you. This information could include technical inaccuracies or typographical errors. Changes are periodically made to the information herein; these changes will be incorporated in new editions of the publication. HCL may make improvements and/or changes in the product(s) and/or the program(s) described in this publication at any time without notice. Any references in this information to non-HCL websites are provided for convenience only and do not in any manner serve as an endorsement of those websites. The materials at those websites are not part of the materials for this HCL product and use of those websites is at your own risk. HCL may use or distribute any of the information you provide in any way it believes appropriate without incurring any obligation to you. Licensees of this program who wish to have information about it for the purpose of enabling: (i) the exchange of information between independently created programs and other programs (including this one) and (ii) the mutual use of the information which has been exchanged, should contact: HCL 330 Potrero Ave. Sunnyvale, CA 94085 USA Attention: Office of the General Counsel Such information may be available, subject to appropriate terms and conditions, including in some cases, payment of a fee. The licensed program described in this document and all licensed material available for it are provided by HCL under terms of the HCL Customer Agreement, HCL International Program License Agreement or any equivalent agreement between us. The performance data discussed herein is presented as derived under specific operating conditions. Actual results may vary. Information concerning non-HCL products was obtained from the suppliers of those products, their published announcements or other publicly available sources. HCL has not tested those products and cannot confirm the accuracy of performance, compatibility or any other claims related to non-HCL products. Questions on the capabilities of non-HCL products should be addressed to the suppliers of those products. Statements regarding HCL's future direction or intent are subject to change or withdrawal without notice, and represent goals and objectives only. This information contains examples of data and reports used in daily business operations. To illustrate them as completely as possible, the examples include the names of individuals, companies, brands, and products. All of these names are fictitious and any similarity to actual people or business enterprises is entirely coincidental. COPYRIGHT LICENSE: This information contains sample application programs in source language, which illustrate programming techniques on various operating platforms. You may copy, modify, and distribute these sample programs in any form without payment to HCL, for the purposes of developing, using, marketing or distributing application programs conforming to the application programming interface for the operating platform for which the sample programs are written. These examples have not been thoroughly tested under all conditions. HCL, therefore, cannot guarantee or imply reliability, serviceability, or function of these programs. The sample programs are provided \"AS IS,\" without warranty of any kind. HCL shall not be liable for any damages arising out of your use of the sample programs. Each copy or any portion of these sample programs or any derivative work must include a copyright notice as follows: \u00a9 (your company name) (year). Portions of this code are derived from HCL Technologies Limited. Sample Programs. \u00a9 HCL Technologies Limited . Trademarks HCL Technologies Ltd. and HCL Technologies Ltd. logo, and hcl.com are trademarks or registered trademarks of HCL Technologies Ltd., registered in many jurisdictions worldwide. Other product and service names might be trademarks of HCL or other companies. Terms and conditions for product documentation Permissions for the use of these publications are granted subject to the following terms and conditions. Applicability These terms and conditions are in addition to any terms of use for the HCL website. Personal use You may reproduce these publications for your personal, noncommercial use provided that all proprietary notices are preserved. You may not distribute, display or make derivative work of these publications, or any portion thereof, without the express consent of HCL. Commercial use You may reproduce, distribute and display these publications solely within your enterprise provided that all proprietary notices are preserved. You may not make derivative works of these publications, or reproduce, distribute or display these publications or any portion thereof outside your enterprise, without the express consent of HCL. Rights Except as expressly granted in this permission, no other permissions, licenses or rights are granted, either express or implied, to the publications or any information, data, software or other intellectual property contained therein. HCL reserves the right to withdraw the permissions granted herein whenever, in its discretion, the use of the publications is detrimental to its interest or, as determined by HCL, the above instructions are not being properly followed. You may not download, export or re-export this information except in full compliance with all applicable laws and regulations, including all United States export laws and regulations. HCL MAKES NO GUARANTEE ABOUT THE CONTENT OF THESE PUBLICATIONS. THE PUBLICATIONS ARE PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.","title":"Notices"},{"location":"notices/#notices","text":"Licensed Materials - Property of HCL Limited. \u00a9 Copyright HCL Technologies Limited This information was developed for products and services offered in the US. HCL may not offer the products, services, or features discussed in this document in other countries. Consult your local HCL representative for information on the products and services currently available in your area. Any reference to an HCL product, program, or service is not intended to state or imply that only that HCL product, program, or service may be used. Any functionally equivalent product, program, or service that does not infringe any HCL intellectual property right may be used instead. However, it is the user's responsibility to evaluate and verify the operation of any non-HCL product, program, or service. HCL may have patents or pending patent applications covering subject matter described in this document. The furnishing of this document does not grant you any license to these patents. You can send license inquiries, in writing, to: HCL 330 Potrero Ave. Sunnyvale, CA 94085 USA Attention: Office of the General Counsel For license inquiries regarding double-byte character set (DBCS) information, contact the HCL Intellectual Property Department in your country or send inquiries, in writing, to: HCL 330 Potrero Ave. Sunnyvale, CA 94085 USA Attention: Office of the General Counsel HCL TECHNOLOGIES LTD. PROVIDES THIS PUBLICATION \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Some jurisdictions do not allow disclaimer of express or implied warranties in certain transactions, therefore, this statement may not apply to you. This information could include technical inaccuracies or typographical errors. Changes are periodically made to the information herein; these changes will be incorporated in new editions of the publication. HCL may make improvements and/or changes in the product(s) and/or the program(s) described in this publication at any time without notice. Any references in this information to non-HCL websites are provided for convenience only and do not in any manner serve as an endorsement of those websites. The materials at those websites are not part of the materials for this HCL product and use of those websites is at your own risk. HCL may use or distribute any of the information you provide in any way it believes appropriate without incurring any obligation to you. Licensees of this program who wish to have information about it for the purpose of enabling: (i) the exchange of information between independently created programs and other programs (including this one) and (ii) the mutual use of the information which has been exchanged, should contact: HCL 330 Potrero Ave. Sunnyvale, CA 94085 USA Attention: Office of the General Counsel Such information may be available, subject to appropriate terms and conditions, including in some cases, payment of a fee. The licensed program described in this document and all licensed material available for it are provided by HCL under terms of the HCL Customer Agreement, HCL International Program License Agreement or any equivalent agreement between us. The performance data discussed herein is presented as derived under specific operating conditions. Actual results may vary. Information concerning non-HCL products was obtained from the suppliers of those products, their published announcements or other publicly available sources. HCL has not tested those products and cannot confirm the accuracy of performance, compatibility or any other claims related to non-HCL products. Questions on the capabilities of non-HCL products should be addressed to the suppliers of those products. Statements regarding HCL's future direction or intent are subject to change or withdrawal without notice, and represent goals and objectives only. This information contains examples of data and reports used in daily business operations. To illustrate them as completely as possible, the examples include the names of individuals, companies, brands, and products. All of these names are fictitious and any similarity to actual people or business enterprises is entirely coincidental. COPYRIGHT LICENSE: This information contains sample application programs in source language, which illustrate programming techniques on various operating platforms. You may copy, modify, and distribute these sample programs in any form without payment to HCL, for the purposes of developing, using, marketing or distributing application programs conforming to the application programming interface for the operating platform for which the sample programs are written. These examples have not been thoroughly tested under all conditions. HCL, therefore, cannot guarantee or imply reliability, serviceability, or function of these programs. The sample programs are provided \"AS IS,\" without warranty of any kind. HCL shall not be liable for any damages arising out of your use of the sample programs. Each copy or any portion of these sample programs or any derivative work must include a copyright notice as follows: \u00a9 (your company name) (year). Portions of this code are derived from HCL Technologies Limited. Sample Programs. \u00a9 HCL Technologies Limited .","title":"Notices"},{"location":"notices/#trademarks","text":"HCL Technologies Ltd. and HCL Technologies Ltd. logo, and hcl.com are trademarks or registered trademarks of HCL Technologies Ltd., registered in many jurisdictions worldwide. Other product and service names might be trademarks of HCL or other companies.","title":"Trademarks"},{"location":"notices/#terms-and-conditions-for-product-documentation","text":"Permissions for the use of these publications are granted subject to the following terms and conditions.","title":"Terms and conditions for product documentation"},{"location":"notices/#applicability","text":"These terms and conditions are in addition to any terms of use for the HCL website.","title":"Applicability"},{"location":"notices/#personal-use","text":"You may reproduce these publications for your personal, noncommercial use provided that all proprietary notices are preserved. You may not distribute, display or make derivative work of these publications, or any portion thereof, without the express consent of HCL.","title":"Personal use"},{"location":"notices/#commercial-use","text":"You may reproduce, distribute and display these publications solely within your enterprise provided that all proprietary notices are preserved. You may not make derivative works of these publications, or reproduce, distribute or display these publications or any portion thereof outside your enterprise, without the express consent of HCL.","title":"Commercial use"},{"location":"notices/#rights","text":"Except as expressly granted in this permission, no other permissions, licenses or rights are granted, either express or implied, to the publications or any information, data, software or other intellectual property contained therein. HCL reserves the right to withdraw the permissions granted herein whenever, in its discretion, the use of the publications is detrimental to its interest or, as determined by HCL, the above instructions are not being properly followed. You may not download, export or re-export this information except in full compliance with all applicable laws and regulations, including all United States export laws and regulations. HCL MAKES NO GUARANTEE ABOUT THE CONTENT OF THESE PUBLICATIONS. THE PUBLICATIONS ARE PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.","title":"Rights"},{"location":"overview/","text":"RTist in Code lets you create stateful, event-driven realtime applications in C++. It runs as an extension of Visual Studio Code or Eclipse Theia. Follow the installation instructions for installing it. RTist in Code supports the Art language which is an extension of the C++ language. It provides high-level concepts useful when designing stateful, event-driven realtime applications. It is a textual language, but also provides a graphical notation that includes class, state and structure diagrams. RTist in Code translates Art files into C++ code which can be compiled on any target system. The generated code makes use of the Target RunTime System which is a C++ library that implements the concepts of the Art language.","title":"Overview"},{"location":"target-rts/","text":"The Target RunTime System (or TargetRTS for short) is a C++ library that is used by the code that is generated by RTist in Code. When building the realtime application from the generated code, it links with a TargetRTS library that has been prebuilt for the platform (hardware, operating system etc) on which the realtime application will run. The TargetRTS provides C++ implementations for the concepts of the Art language . The APIs of these implementations are used by the generated code, but also by the embedded C++ code that you write inside the Art files. This documentation serves the following purposes: Provide a general understanding of how the TargetRTS is structured and how it implements important concepts from the Art language. Document the C++ APIs that you can use in embedded C++ code inside an Art file Describe how to build the TargetRTS for a new target platform, including ways to customize it as required","title":"Target RunTime System"},{"location":"validation/","text":"Overview of Validation When validation runs Related elements Using the Problems view Quick fix Configuring Validation Validation can be configured to change which rules that should run, and what severity they should report found problems with. By default every validation rule is enabled and uses a predefined severity level. Validation rules can be configured either globally by means of a setting, or locally by means of a property rule_config . In both cases the rule configuration consists of a comma-separated list of 5 letter strings where the first letter specifies if the rule is disabled and it's severity (X,I,W,E) and remaining letters specify the rule id. For example, the rule configuration X0003,I0004,W0009,E0005 means the following: The rule ART_0003_nameShouldStartWithUpperCase is disabled The rule ART_0004_nameShouldStartWithLowerCase has its severity set to Information The rule ART_0009_invalidProperty has its severity set to Warning The rule ART_0005_choiceWithoutElseTransition has its severity set to Error To configure validation rules globally, use the setting Validation: Rule Configuration . A global configuration will apply for all Art files in the workspace, and all Art elements within those files, unless a local rule configuration has been set on an element. To configure validation rules locally, set the property rule_config on an Art element. It will affect the validation of that Art element itself, as well as all elements contained within that Art element. Here is an example of how to disable the validation rule ART_0003_nameShouldStartWithUpperCase on a capsule. Note that it also will disable this rule for elements contained within the capsule, such as states. capsule customCapsule // no warning even if capsule name is not capitalized [[rt::properties( rule_config=\"X0003\" )]]{ statemachine { state customState; // no warning here too initial -> customState; }; }; Validation Rules This chapter lists all validation rules which RTist in Code checks your Art application against. All these checks run automatically as soon as you have made a change to an Art file (even before saving it). This ensures that errors and potential problems are found as early as possible. ART_0001_invalidNameCpp Severity Reason Quick Fix Error An Art element has a name that is not a valid C++ name. N/A Art elements are translated to C++ elements without changing the elements' names. Hence you need to choose names for Art elements that are valid in C++. For example, C++ keywords cannot be used. If you ignore this error you can expect errors when compiling the generated C++ code. protocol InvalidNameProtocol { in virtual(); // ART_0001 (\"virtual\" is a C++ keyword) }; ART_0002_duplicateNamesInScope Severity Reason Quick Fix Error Two or more Art elements in the same scope have the same names or signatures. N/A Names of Art elements must be unique within the same scope. The following is checked: Top-level elements within an Art file. Note that even top-level elements in different Art files should have unique names since the corresponding C++ elements all will be within the global namespace, but this is currently not checked (but will be detected by the C++ linker). Events of a protocol. Note that in-events and out-events are checked separately, since an in-event and an out-event will have the same name when you define a symmetric event (see Protocol and Event ). Parts of a capsule. Ports of a capsule. States and pseudo states (collectively referred to as \"vertices\") of a state machine. Transitions of a state machine. Trigger operations of a class . Note that several trigger operations may have the same name as long as their signatures are unique. All elements with clashing names or signatures will be reported as related elements. Use this to find the element(s) that need to be renamed. protocol DupProto { in inEvent1(); // ART_0002 in inEvent1(); // ART_0002 out inEvent1(); // OK (symmetric event) }; class DNIS { trigger op1(`int` p); trigger op1(); // OK (signatures are unique) statemachine { state State; initial -> State; }; }; ART_0003_nameShouldStartWithUpperCase Severity Reason Quick Fix Warning An Art element's name doesn't follow the naming convention to start with uppercase. Capitalize Name Just like in most languages Art has certain conventions on how elements should be named. The following elements should have names that start with an uppercase letter: Capsule Class Protocol State A Quick Fix is available that will fix the problem by capitalizing the name. Note, however, that it will only update the element's name, and not all references. If you have references to the element you may instead want to fix the problem by performing a Rename. capsule myCapsule { // ART_0003 statemachine { state sstate; // ART_0003 initial -> sstate; }; }; In this context an underscore ( _ ) is considered a valid upper case character, so all names that start with underscore are accepted by this validation rule. ART_0004_nameShouldStartWithLowerCase Severity Reason Quick Fix Warning An Art element's name doesn't follow the naming convention to start with lowercase. Decapitalize Name Just like in most languages Art has certain conventions on how elements should be named. The following elements should have names that start with a lowercase letter: Event Port Part Trigger operation Choice and junction points Entry and exit points Transition A Quick Fix is available that will fix the problem by decapitalizing the name. Note, however, that it will only update the element's name, and not all references. If you have references to the element you may instead want to fix the problem by performing a Rename. protocol LowerCaseTestProtocol { out MyEvent(); // ART_0004 }; In this context an underscore ( _ ) is considered a valid lower case character, so all names that start with underscore are accepted by this validation rule. ART_0005_choiceWithoutElseTransition Severity Reason Quick Fix Warning A choice lacks an outgoing else-transition. N/A If no outgoing transition of a choice is enabled at runtime (because no outgoing transition has a guard condition that is fulfilled) then the state machine will get stuck in the choice for ever. To avoid this you should ensure that at least one outgoing transition is enabled. A good way to do this is to use 'else' as the guard condition for one of the outgoing transitions. Such an else-transition will then execute if no other outgoing transition of the choice is enabled. capsule ChoiceSample { statemachine { state State; initial -> State; choice x; // ART_0005 State -> x; x -> State when `return getVal() == 5;`; }; }; Note that a transition without any guard condition is equivalent to a transition with a guard condition that is always fulfilled (i.e. a guard condition that returns true). An outgoing transition from a choice or junction without any guard is therefore also an else-transition. ART_0006_choiceWithoutOutgoingTransitions Severity Reason Quick Fix Error A choice has no outgoing transitions. N/A A choice should typically have at least two outgoing transitions to be meaningful. Having only one outgoing transition is possible if it is an else-transition (i.e. a transition with an 'else' guard, or without any guard at all). However, a choice without any outgoing transition is not allowed since the state machine always will get stuck when reaching such a choice. capsule ChoiceSample { statemachine { state State; initial -> State; choice x; // ART_0006 State -> x; }; }; ART_0007_choiceWithTooManyElseTransitions Severity Reason Quick Fix Error A choice has more than one outgoing else-transition. N/A It's good practise to have an outgoing else-transition (i.e. a transition with an 'else' guard, or without any guard at all) for a choice since it will prevent the state machine from getting stuck in the choice at runtime. However, there should not be more than one such else-transition defined, since otherwise it's ambiguous which one of them to trigger in the case none of the other outgoing transitions from the choice are enabled. capsule ChoiceSample { statemachine { state State, State2; initial -> State; choice x; // ART_0007 State -> x; x -> State; x -> State2 when `else`; }; }; ART_0008_initialTransitionCount Severity Reason Quick Fix Error A state machine has too many initial transitions, or no initial transition at all. N/A A state machine of a capsule or class must have exactly one initial transition. A common reason for this error is that you have introduced inheritance between two capsules which both have state machines with an initial transition. Because of that the derived capsule will have two initial transitions (the one it defines itself locally plus the one it inherits from the base capsule). In this case the error can be fixed by either deleting or excluding the initial transition from the derived capsule, or to let it redefine the initial transition from the base capsule. capsule InitTransCap2 { statemachine { state State; initial -> State; }; }; capsule InitTransCap3 : InitTransCap2 { statemachine { state State; initial -> State; // ART_0008 }; }; Note that if the initial transition in the base capsule has no name, the derived capsule cannot exclude or redefine it. It's therefore good practise to name the initial transition if you expect your capsule to be inherited from. ART_0009_invalidProperty Severity Reason Quick Fix Error A non-existing property is set for an element. Remove Property Most Art elements have properties that can be set to change their default values. Different elements have different properties and if you get this error it means you have referenced a non-existing property for an Art element. A Quick Fix is available for removing the setting of the invalid property. Use Content Assist ( Ctrl + Space ) to get a list of valid properties for an Art element. protocol IP_PROTO [[rt::properties( no_property = 4 // ART_0009 (A protocol has no property called \"no_property\") )]] { }; ART_0010_invalidPropertyValue Severity Reason Quick Fix Error A property is set to a value of incorrect type. N/A Most Art elements have properties and every property has a type that is either boolean, integer, string or an enumeration. The type of the value assigned to a property must match the property's type. For example, you cannot assign an integer value to a boolean property. capsule IPV_Cap [[rt::properties( generate_file_header=4 // ART_0010 (\"generate_file_header\" is a boolean property) )]]{ statemachine { state State; initial -> State; }; }; ART_0011_propertySetToDefaultValue Severity Reason Quick Fix Warning A property is set to its default value. Remove Property Most Art elements have properties and every property has a default value. It's unnecessary to explicitly set a property to its default value. A Quick Fix is available for removing the setting of the property. class C_PropDefaultValue [[rt::properties( const_target_param_for_decode=false // ART_0011 )]] { statemachine { state State; initial -> State; }; }; ART_0012_invalidCodeSnippet Severity Reason Quick Fix Error A code snippet is invalid in one way or the other. Remove Code Snippet A code snippet 's kind is specified after the prefix rt:: . Different Art elements may have different kinds of code snippets. Also, some Art elements may have multiple code snippets of a certain kind, while others only may have one code snippet of each kind. A Quick Fix is available for removing the invalid code snippet. [[rt::header_preface]] // ART_0012 (code snippet for capsule/class placed at file level) ` // YourCodeHere ` capsule Name { [[rt::unknown]] // ART_0012 (non-existing kind of code snippet) ` // YourCodeHere ` part x : OtherCap [[rt::createFunction]] ` return new DemoCap(rtg_rts, rtg_ref); ` [[rt::createFunction]] // ART_0012 (duplicated code snippet) ` return new DemoCap(rtg_rts, rtg_ref); `; statemachine { state State; initial -> State; }; }; ART_0013_partMultiplicityError Severity Reason Quick Fix Error The part's lower multiplicity must be less than its upper multiplicity. N/A If a part has a multiplicity that specifies a range (i.e. both a lower and upper multiplicity), then the lower multiplicity must be less than the upper multiplicity. capsule PME_Cap { part myPart : OtherCap [2..2]; // ART_0013 statemachine { state State; initial -> State; }; }; ART_0014_partKindMultiplicityInconsistency Severity Reason Quick Fix Warning The part's kind is inconsistent with its multiplicity. N/A The multiplicity of a capsule part must match the part's kind. The following is checked: A fixed part must have a multiplicity greater than zero. This is because when the container capsule is incarnated at least one capsule instance must be incarnated into the fixed part. An optional part must have a lower multiplicity of zero. This means that when the container capsule is incarnated no capsule instances will be incarnated into the optional part. Hence, this is what makes the part optional. It's only possible to specify the part multiplicity using a C++ expression if the part is fixed. In case any of these inconsistencies is detected, the faulty multiplicity will be ignored and a default multiplicity (see Part ) will be used instead. capsule PKMI_Cap { fixed part myPart : OtherCap [0..2]; // ART_0014 (Fixed part should not have lower multiplicity 0) optional part myPart2 : OtherCap [1..5]; // ART_0014 (Optional part should not have lower multiplicity > 0) optional part myPart3 : OtherCap [`5`]; // ART_0014 (Only a fixed part may have its multiplicity specified with a code expression) statemachine { state State; initial -> State; }; }; ART_0015_internalTransitionOutsideState Severity Reason Quick Fix Error An internal transition is defined outside a state, in the top state machine. N/A An internal transition specifies events that can be handled while a state machine is in a certain state without leaving that state. Hence it's only possible to define an internal transition inside a state. It does not make sense to define an internal transition directly in the top state machine. capsule IntTransOutsideState { service port timer : Timing; statemachine { state State { t1 : on timer.timeout ` `; }; initial -> State; terror : on timer.timeout ` `; // ART_0015 }; }; ART_0016_circularInheritance Severity Reason Quick Fix Error A capsule, class or protocol inherits from itself directly or indirectly. N/A When you use inheritance for capsules, classes and protocols you need to ensure there are no inheritance cycles. Cyclic inheritance means that an element would inherit from itself, directly or indirectly, which is not allowed. Note Both capsules and classes, but not protocols, may have C++ base classes specified by means of C++ code snippets. Such inheritance relationships are not checked by this validation rule, but by the C++ compiler. The elements that form the inheritance cycle will be reported as related elements. Use this to decide how to break the inheritance cycle. protocol PR1 : PR2 { // ART_0016 }; protocol PR2 : PR1 { // ART_0016 }; class C1 { statemachine { state State; initial -> State; }; }; class C2 : C1 { statemachine { state State; initial -> State; }; }; class C3 : C2, C4 { // ART_0016 statemachine { state State; initial -> State; }; }; class C4 : C3 { // ART_0016 statemachine { state State; initial -> State; }; }; ART_0017_circularComposition Severity Reason Quick Fix Error A capsule contains itself through a cycle in the composition hierarchy. N/A Parts of a capsule must form a strict composition hierarchy. At run-time the root of this hierarchy is the top capsule instance, and all other capsule instances in the application must be directly or indirectly owned by that capsule instance. For a fixed part the creation of contained capsule instances happen automatically when the container capsule is incarnated. It's therefore possible to statically analyze the fixed parts and check for cycles in the composition hierarchy. Note Only the static type of fixed capsule parts are used when looking for composition cycles. If a part has a capsule factory that specifies a create function using C++ code, then a different dynamic type may be specified for the created capsule instances for that part. This opens up for more possibilities of introducing cycles in the composition hierarchy that will not be detected by this validation rule. The fixed parts that form the composition cycle will be reported as related elements. Use this to decide how to break the composition cycle. capsule CComp2 { fixed part p2 : CComp3; // ART_0017 statemachine { state State; initial -> State; }; }; capsule CComp3 part p3 : CComp2; // ART_0017 statemachine { state State; initial -> State; }; }; ART_0018_circularTransitions Severity Reason Quick Fix Error A state machine has a cycle in the transitions that execute when leaving a junction. N/A A junction can split an incoming transition flow into multiple outgoing transition flows based on evaluating guard conditions for the outgoing transitions. If care is not taken it's possible to introduce cycles in the outgoing transition flows. Such cycles could lead to infinite recursion when the state machine executes, depending on what guard conditions will be fulfilled at runtime. You should therefore ensure there are no such transition cycles. The transitions that form the cycle will be reported as related elements. Use this to decide how to break the transition cycle. capsule CT_cap { statemachine { // ART_0018 state S1; initial -> S1; junction j1, j2; t1: S1 -> j1; t2: j1 -> j2; t3: j2 -> j1; }; }; ART_0019_unwiredPortBothPublisherAndSubscriber Severity Reason Quick Fix Error An unwired port is declared as being both a subscriber and publisher at the same time. N/A An unwired port can at runtime be connected to another unwired port. One of the connected ports will be a publisher port (a.k.a SPP port) while the other will be a subscriber port (a.k.a SAP port). An unwired port can either be statically declared as being a publisher or subscriber port, or it can be dynamically decided at port registration time if the port should be a publisher or subscriber. The same port can not be both a subscriber and a publisher port at the same time. capsule UnwiredCapsule { subscribe publish port p1 : UnwiredProtocol; // ART_0019 statemachine { state State; initial -> State; }; }; ART_0020_wiredPortWithUnwiredProperties Severity Reason Quick Fix Warning A property that only is applicable for an unwired port is specified for a wired port. N/A An unwired port may have properties that control how it will be registered at runtime (see registration and registration_name ). These properties have no meaning and will be ignored for wired ports. capsule UnwiredCapsule2 { port p1 [[rt::properties( registration_name=\"hi\" )]]: UnwiredProtocol; // ART_0020 statemachine { state State; initial -> State; }; }; ART_0021_unwiredPortRegNameSameAsPortName Severity Reason Quick Fix Warning An unwired port is set to use a registration name that equals the name of the port. N/A When an unwired port is registered a name is used that by default is the name of the port. The property registration_name can be used for specifying another name. It's hence unnecessary to use that property for specifying the name of the port, since it is the default name that anyway would be used. capsule UnwiredCapsule3 { unwired behavior port p1~ [[rt::properties( registration_name = \"p1\" )]] : UnwiredProtocol; // ART_0021 statemachine { state State; initial -> State; }; }; ART_0022_ruleConfigProblem Severity Reason Quick Fix Warning The rule_config property has a malformed value. N/A The rule_config property can be set on Art elements to configure which validation rules to run for that element (and for all elements it contains). It can also be used for setting a custom severity for those rules. The value of the rule_config property should be a comma-separated list of 5 letter strings where the first letter specifies if the rule is disabled and it's severity (X,I,W,E) and remaining letters specify the rule id. See Configuring Validation for more information and examples. capsule RCP [[rt::properties( rule_config=\"X0000\" // ART_0022 (a validation rule with id 0000 does not exist) )]]{ statemachine { state State; initial -> State; }; }; ART_0023_entryExitCodeCount Severity Reason Quick Fix Error A state has too many entry and/or exit actions. N/A A state can at most have one entry and one exit action. Solve this problem by merging all entry and exit actions of the state to a single entry and exit action that performs everything that should be done when the state is entered and exited. capsule CX { statemachine { state Composite { entry // ART_0023 ` entry1(); `; entry // ART_0023 ` entry2(); `; }; initial -> Composite; }; }; ART_0024_unwiredPortNotBehavior Severity Reason Quick Fix Error An unwired port is not defined as a behavior port. Make Behavior Port, Make Wired Port An unwired port cannot be connected to another port by means of a connector . Hence, it's required that an unwired port is defined to be a behavior port. Otherwise it would not be possible for the owner capsule to send and receive events on an unwired port. Two Quick Fixes are available for fixing this problem. Either the port can be turned into a behavior port, or it can be turned into a wired port. capsule Pinger { service unwired port p1 : PROTO; // ART_0024 statemachine { state State1; initial -> State1; }; }; ART_0025_portOnPartConnectionError Severity Reason Quick Fix Error A wired port is not properly connected, or an unwired port is connected. N/A An unwired port must not be connected to another port by means of a connector . Instead you should register such a port dynamically so that it can be connected at runtime with another matching port. A wired port, however, must be connected. If the port is not a behavior port, it must be connected both on the \"inside\" and on the \"outside\" by two connectors. That is because the purpose of such a relay port is to simply relay communication from one port to another. By \"inside\" we mean the composite structure of the capsule that owns the port, and by \"outside\" we mean the composite structure to which the part that is typed by the capsule belongs. If the port is a behavior port, it should only be connected on the \"outside\". capsule Top { part ping : Pinger, // ART_0025 (not connected in capsule Top) pong : Ponger; // ART_0025 (not connected in capsule Top) statemachine { state t21; initial -> t21; }; }; capsule Inner { service behavior port p : PROTO; statemachine { state State; initial -> State; }; }; capsule Pinger { service port p1 : PROTO; part inner : Inner; connect p1 with inner.p; statemachine { state State1; initial -> State1; }; }; capsule Ponger { service behavior port p2~ : PROTO; statemachine { state State1; initial -> State1; }; }; In the above picture we can more easily understand the two errors reported for the Top capsule's two parts ping and pong . Port Ponger::p2 is a behavior port so one connection is expected for that port (but none is present), while port Pinger::p1 is a non-behavior port so two connections are expected for that port (but only one is present, on its \"inside\"). Both problems can be solved by adding a connector in Top which connects these ports on their \"outside\". ART_0026_illegalConnection Severity Reason Quick Fix Error A connector connects two ports with incompatible conjugations. N/A Ports connected by a connector must have compatible conjugations. If the ports are at the same level in the capsule's structure (e.g. both ports belong to capsules typing capsule parts owned by the same capsule), then the connected ports must have the opposite conjugation. This is because events that are sent out from one of the ports must be able to be received by the other port. However, if the ports are at different levels in the capsule's structure (e.g. one of them belongs to a capsule typing a capsule part owned by the capsule and the other belongs to the capsule itself), then the ports must have the same conjugation. This is because in this case events are simply delegated from one capsule to another. capsule Top { part ping : Pinger, pong : Ponger; connect ping.p1 with pong.p2; // ART_0026 (same port conjugations but should be different) statemachine { state t21; initial -> t21; }; }; capsule Inner { service behavior port p : PROTO; statemachine { state State; initial -> State; }; }; capsule Pinger { service port p1~ : PROTO; part inner : Inner; connect p1 with inner.p; // ART_0026 (different port conjugations but should be same) statemachine { state State1; initial -> State1; }; }; capsule Ponger { service behavior port p2~ : PROTO; statemachine { state State1; initial -> State1; }; }; Here we see that both connectors are invalid. Port p2 and port p1 are at the same level in Top 's structure so their conjugations should be different, while port p1 and port p are at different levels in Top 's structure so their conjugations should be the same. ART_0027_incompatibleProtocolsForConnectedPorts Severity Reason Quick Fix Error A connector connects two ports with incompatible protocols. N/A Ports connected by a connector must have compatible protocols. For RTist in Code this means that the protocols must be the same. Note HCL RTist uses a different criteria for protocol compatibility. There two protocols are compatible if all events that can be sent by a port typed by the source protocol can be received by the other port typed by the target protocol. Also in HCL RTist the most common case is that the source and target protocols are the same, but they can also be different as long as all their events (both in-events and out-events) match both by name and parameter data type. This is a legacy behavior which is not recommended, and hence not supported by RTist in Code. protocol PROTO1 { in pong(); out ping(); }; protocol PROTO2 { in pong(); out ping(); }; protocol PROTO3 { in pong(); out ping3(); }; capsule Top { service port p1 : PROTO1; service port p2~ : PROTO2; service port p3~ : PROTO3; connect p1 with p2; // ART_0027 (but OK in HCL RTist) connect p1 with p3; // ART_0027 (also not OK in HCL RTist due to event ping3) statemachine { state t21; initial -> t21; }; }; ART_0028_superfluousTrigger Severity Reason Quick Fix Warning A transition has a trigger which can never be triggered at runtime since there is another trigger on a transition from the same state that is identical. N/A Triggers for outgoing transitions of a state must be different. If two triggers specify the same event and port, and neither of them has a guard condition, then both of them will be enabled at the same time. In this case only one of the triggers will trigger the transition at runtime and the other one is superfluous. You can fix this problem either by removing the superfluous trigger, or to add a guard condition to one or both of the triggers or transitions. This validation rule is not run when the trigger or its transition has a guard, since it's then not possible to statically determine whether a trigger is superfluous or not. capsule Base_27 { service port timer : Timing; statemachine { state BS; initial -> BS; _XTRANS: BS -> BS on timer.timeout; }; }; capsule SC27 : Base_27 { statemachine { state State, State2; redefine _XTRANS : BS -> State on timer.timeout; BS -> State2 on timer.timeout; // ART_0028 State -> State2 on timer.timeout; }; }; ART_0029_transitionToCompositeStateNoEntry Severity Reason Quick Fix Warning A composite state is entered without using an entry point. N/A If a composite state is entered without using an entry point, the behavior may be different the first time the state is entered compared to subsequent times it's entered. The first time the initial transition of the composite state will execute, while after that it will be entered using deep history (i.e. directly activate the substate that was previously active in the composite state). This difference in behavior is not evident just by looking at the state diagram, and can therefore be surprising and cause bugs. It's therefore recommended to always enter a composite state using an entry point. See Hierarchical Statemachines for more information. capsule Cap { statemachine { state BS { entrypoint ep1; initial -> Nested; state Nested; }; _Initial: initial -> BS; // ART_0029 }; }; ART_0030_transitionToCompositeStateNoEntryNoInitialTrans Severity Reason Quick Fix Error A composite state is entered without using an entry point, and its state machine has no initial transition. N/A This validation rule is related to ART_0029_transitionToCompositeStateNoEntry . If a composite state is entered without using an entry point, and the nested state machine of the composite state has no initial transition, then it is undefined what to do when entering the state. This is therefore not allowed. capsule Cap { statemachine { state BS { entrypoint ep1; state Nested; }; _Initial: initial -> BS; // ART_0030 }; }; ART_0031_portBothNonServiceAndNonBehavior Severity Reason Quick Fix Error A port is both a non-service and a non-behavior port at the same time. N/A A port that is not a service port is internal to a capsule. For such a port to be useful it must be a behavior port; otherwise the capsule cannot send and receive events on the port. Hence, a non-service port cannot at the same time be a non-behavior port. capsule C31 { port fp : Proto; // ART_0031 statemachine { state State; initial -> State; }; };","title":"Validation"},{"location":"validation/#overview-of-validation","text":"When validation runs Related elements Using the Problems view Quick fix","title":"Overview of Validation"},{"location":"validation/#configuring-validation","text":"Validation can be configured to change which rules that should run, and what severity they should report found problems with. By default every validation rule is enabled and uses a predefined severity level. Validation rules can be configured either globally by means of a setting, or locally by means of a property rule_config . In both cases the rule configuration consists of a comma-separated list of 5 letter strings where the first letter specifies if the rule is disabled and it's severity (X,I,W,E) and remaining letters specify the rule id. For example, the rule configuration X0003,I0004,W0009,E0005 means the following: The rule ART_0003_nameShouldStartWithUpperCase is disabled The rule ART_0004_nameShouldStartWithLowerCase has its severity set to Information The rule ART_0009_invalidProperty has its severity set to Warning The rule ART_0005_choiceWithoutElseTransition has its severity set to Error To configure validation rules globally, use the setting Validation: Rule Configuration . A global configuration will apply for all Art files in the workspace, and all Art elements within those files, unless a local rule configuration has been set on an element. To configure validation rules locally, set the property rule_config on an Art element. It will affect the validation of that Art element itself, as well as all elements contained within that Art element. Here is an example of how to disable the validation rule ART_0003_nameShouldStartWithUpperCase on a capsule. Note that it also will disable this rule for elements contained within the capsule, such as states. capsule customCapsule // no warning even if capsule name is not capitalized [[rt::properties( rule_config=\"X0003\" )]]{ statemachine { state customState; // no warning here too initial -> customState; }; };","title":"Configuring Validation"},{"location":"validation/#validation-rules","text":"This chapter lists all validation rules which RTist in Code checks your Art application against. All these checks run automatically as soon as you have made a change to an Art file (even before saving it). This ensures that errors and potential problems are found as early as possible.","title":"Validation Rules"},{"location":"validation/#art_0001_invalidnamecpp","text":"Severity Reason Quick Fix Error An Art element has a name that is not a valid C++ name. N/A Art elements are translated to C++ elements without changing the elements' names. Hence you need to choose names for Art elements that are valid in C++. For example, C++ keywords cannot be used. If you ignore this error you can expect errors when compiling the generated C++ code. protocol InvalidNameProtocol { in virtual(); // ART_0001 (\"virtual\" is a C++ keyword) };","title":"ART_0001_invalidNameCpp"},{"location":"validation/#art_0002_duplicatenamesinscope","text":"Severity Reason Quick Fix Error Two or more Art elements in the same scope have the same names or signatures. N/A Names of Art elements must be unique within the same scope. The following is checked: Top-level elements within an Art file. Note that even top-level elements in different Art files should have unique names since the corresponding C++ elements all will be within the global namespace, but this is currently not checked (but will be detected by the C++ linker). Events of a protocol. Note that in-events and out-events are checked separately, since an in-event and an out-event will have the same name when you define a symmetric event (see Protocol and Event ). Parts of a capsule. Ports of a capsule. States and pseudo states (collectively referred to as \"vertices\") of a state machine. Transitions of a state machine. Trigger operations of a class . Note that several trigger operations may have the same name as long as their signatures are unique. All elements with clashing names or signatures will be reported as related elements. Use this to find the element(s) that need to be renamed. protocol DupProto { in inEvent1(); // ART_0002 in inEvent1(); // ART_0002 out inEvent1(); // OK (symmetric event) }; class DNIS { trigger op1(`int` p); trigger op1(); // OK (signatures are unique) statemachine { state State; initial -> State; }; };","title":"ART_0002_duplicateNamesInScope"},{"location":"validation/#art_0003_nameshouldstartwithuppercase","text":"Severity Reason Quick Fix Warning An Art element's name doesn't follow the naming convention to start with uppercase. Capitalize Name Just like in most languages Art has certain conventions on how elements should be named. The following elements should have names that start with an uppercase letter: Capsule Class Protocol State A Quick Fix is available that will fix the problem by capitalizing the name. Note, however, that it will only update the element's name, and not all references. If you have references to the element you may instead want to fix the problem by performing a Rename. capsule myCapsule { // ART_0003 statemachine { state sstate; // ART_0003 initial -> sstate; }; }; In this context an underscore ( _ ) is considered a valid upper case character, so all names that start with underscore are accepted by this validation rule.","title":"ART_0003_nameShouldStartWithUpperCase"},{"location":"validation/#art_0004_nameshouldstartwithlowercase","text":"Severity Reason Quick Fix Warning An Art element's name doesn't follow the naming convention to start with lowercase. Decapitalize Name Just like in most languages Art has certain conventions on how elements should be named. The following elements should have names that start with a lowercase letter: Event Port Part Trigger operation Choice and junction points Entry and exit points Transition A Quick Fix is available that will fix the problem by decapitalizing the name. Note, however, that it will only update the element's name, and not all references. If you have references to the element you may instead want to fix the problem by performing a Rename. protocol LowerCaseTestProtocol { out MyEvent(); // ART_0004 }; In this context an underscore ( _ ) is considered a valid lower case character, so all names that start with underscore are accepted by this validation rule.","title":"ART_0004_nameShouldStartWithLowerCase"},{"location":"validation/#art_0005_choicewithoutelsetransition","text":"Severity Reason Quick Fix Warning A choice lacks an outgoing else-transition. N/A If no outgoing transition of a choice is enabled at runtime (because no outgoing transition has a guard condition that is fulfilled) then the state machine will get stuck in the choice for ever. To avoid this you should ensure that at least one outgoing transition is enabled. A good way to do this is to use 'else' as the guard condition for one of the outgoing transitions. Such an else-transition will then execute if no other outgoing transition of the choice is enabled. capsule ChoiceSample { statemachine { state State; initial -> State; choice x; // ART_0005 State -> x; x -> State when `return getVal() == 5;`; }; }; Note that a transition without any guard condition is equivalent to a transition with a guard condition that is always fulfilled (i.e. a guard condition that returns true). An outgoing transition from a choice or junction without any guard is therefore also an else-transition.","title":"ART_0005_choiceWithoutElseTransition"},{"location":"validation/#art_0006_choicewithoutoutgoingtransitions","text":"Severity Reason Quick Fix Error A choice has no outgoing transitions. N/A A choice should typically have at least two outgoing transitions to be meaningful. Having only one outgoing transition is possible if it is an else-transition (i.e. a transition with an 'else' guard, or without any guard at all). However, a choice without any outgoing transition is not allowed since the state machine always will get stuck when reaching such a choice. capsule ChoiceSample { statemachine { state State; initial -> State; choice x; // ART_0006 State -> x; }; };","title":"ART_0006_choiceWithoutOutgoingTransitions"},{"location":"validation/#art_0007_choicewithtoomanyelsetransitions","text":"Severity Reason Quick Fix Error A choice has more than one outgoing else-transition. N/A It's good practise to have an outgoing else-transition (i.e. a transition with an 'else' guard, or without any guard at all) for a choice since it will prevent the state machine from getting stuck in the choice at runtime. However, there should not be more than one such else-transition defined, since otherwise it's ambiguous which one of them to trigger in the case none of the other outgoing transitions from the choice are enabled. capsule ChoiceSample { statemachine { state State, State2; initial -> State; choice x; // ART_0007 State -> x; x -> State; x -> State2 when `else`; }; };","title":"ART_0007_choiceWithTooManyElseTransitions"},{"location":"validation/#art_0008_initialtransitioncount","text":"Severity Reason Quick Fix Error A state machine has too many initial transitions, or no initial transition at all. N/A A state machine of a capsule or class must have exactly one initial transition. A common reason for this error is that you have introduced inheritance between two capsules which both have state machines with an initial transition. Because of that the derived capsule will have two initial transitions (the one it defines itself locally plus the one it inherits from the base capsule). In this case the error can be fixed by either deleting or excluding the initial transition from the derived capsule, or to let it redefine the initial transition from the base capsule. capsule InitTransCap2 { statemachine { state State; initial -> State; }; }; capsule InitTransCap3 : InitTransCap2 { statemachine { state State; initial -> State; // ART_0008 }; }; Note that if the initial transition in the base capsule has no name, the derived capsule cannot exclude or redefine it. It's therefore good practise to name the initial transition if you expect your capsule to be inherited from.","title":"ART_0008_initialTransitionCount"},{"location":"validation/#art_0009_invalidproperty","text":"Severity Reason Quick Fix Error A non-existing property is set for an element. Remove Property Most Art elements have properties that can be set to change their default values. Different elements have different properties and if you get this error it means you have referenced a non-existing property for an Art element. A Quick Fix is available for removing the setting of the invalid property. Use Content Assist ( Ctrl + Space ) to get a list of valid properties for an Art element. protocol IP_PROTO [[rt::properties( no_property = 4 // ART_0009 (A protocol has no property called \"no_property\") )]] { };","title":"ART_0009_invalidProperty"},{"location":"validation/#art_0010_invalidpropertyvalue","text":"Severity Reason Quick Fix Error A property is set to a value of incorrect type. N/A Most Art elements have properties and every property has a type that is either boolean, integer, string or an enumeration. The type of the value assigned to a property must match the property's type. For example, you cannot assign an integer value to a boolean property. capsule IPV_Cap [[rt::properties( generate_file_header=4 // ART_0010 (\"generate_file_header\" is a boolean property) )]]{ statemachine { state State; initial -> State; }; };","title":"ART_0010_invalidPropertyValue"},{"location":"validation/#art_0011_propertysettodefaultvalue","text":"Severity Reason Quick Fix Warning A property is set to its default value. Remove Property Most Art elements have properties and every property has a default value. It's unnecessary to explicitly set a property to its default value. A Quick Fix is available for removing the setting of the property. class C_PropDefaultValue [[rt::properties( const_target_param_for_decode=false // ART_0011 )]] { statemachine { state State; initial -> State; }; };","title":"ART_0011_propertySetToDefaultValue"},{"location":"validation/#art_0012_invalidcodesnippet","text":"Severity Reason Quick Fix Error A code snippet is invalid in one way or the other. Remove Code Snippet A code snippet 's kind is specified after the prefix rt:: . Different Art elements may have different kinds of code snippets. Also, some Art elements may have multiple code snippets of a certain kind, while others only may have one code snippet of each kind. A Quick Fix is available for removing the invalid code snippet. [[rt::header_preface]] // ART_0012 (code snippet for capsule/class placed at file level) ` // YourCodeHere ` capsule Name { [[rt::unknown]] // ART_0012 (non-existing kind of code snippet) ` // YourCodeHere ` part x : OtherCap [[rt::createFunction]] ` return new DemoCap(rtg_rts, rtg_ref); ` [[rt::createFunction]] // ART_0012 (duplicated code snippet) ` return new DemoCap(rtg_rts, rtg_ref); `; statemachine { state State; initial -> State; }; };","title":"ART_0012_invalidCodeSnippet"},{"location":"validation/#art_0013_partmultiplicityerror","text":"Severity Reason Quick Fix Error The part's lower multiplicity must be less than its upper multiplicity. N/A If a part has a multiplicity that specifies a range (i.e. both a lower and upper multiplicity), then the lower multiplicity must be less than the upper multiplicity. capsule PME_Cap { part myPart : OtherCap [2..2]; // ART_0013 statemachine { state State; initial -> State; }; };","title":"ART_0013_partMultiplicityError"},{"location":"validation/#art_0014_partkindmultiplicityinconsistency","text":"Severity Reason Quick Fix Warning The part's kind is inconsistent with its multiplicity. N/A The multiplicity of a capsule part must match the part's kind. The following is checked: A fixed part must have a multiplicity greater than zero. This is because when the container capsule is incarnated at least one capsule instance must be incarnated into the fixed part. An optional part must have a lower multiplicity of zero. This means that when the container capsule is incarnated no capsule instances will be incarnated into the optional part. Hence, this is what makes the part optional. It's only possible to specify the part multiplicity using a C++ expression if the part is fixed. In case any of these inconsistencies is detected, the faulty multiplicity will be ignored and a default multiplicity (see Part ) will be used instead. capsule PKMI_Cap { fixed part myPart : OtherCap [0..2]; // ART_0014 (Fixed part should not have lower multiplicity 0) optional part myPart2 : OtherCap [1..5]; // ART_0014 (Optional part should not have lower multiplicity > 0) optional part myPart3 : OtherCap [`5`]; // ART_0014 (Only a fixed part may have its multiplicity specified with a code expression) statemachine { state State; initial -> State; }; };","title":"ART_0014_partKindMultiplicityInconsistency"},{"location":"validation/#art_0015_internaltransitionoutsidestate","text":"Severity Reason Quick Fix Error An internal transition is defined outside a state, in the top state machine. N/A An internal transition specifies events that can be handled while a state machine is in a certain state without leaving that state. Hence it's only possible to define an internal transition inside a state. It does not make sense to define an internal transition directly in the top state machine. capsule IntTransOutsideState { service port timer : Timing; statemachine { state State { t1 : on timer.timeout ` `; }; initial -> State; terror : on timer.timeout ` `; // ART_0015 }; };","title":"ART_0015_internalTransitionOutsideState"},{"location":"validation/#art_0016_circularinheritance","text":"Severity Reason Quick Fix Error A capsule, class or protocol inherits from itself directly or indirectly. N/A When you use inheritance for capsules, classes and protocols you need to ensure there are no inheritance cycles. Cyclic inheritance means that an element would inherit from itself, directly or indirectly, which is not allowed. Note Both capsules and classes, but not protocols, may have C++ base classes specified by means of C++ code snippets. Such inheritance relationships are not checked by this validation rule, but by the C++ compiler. The elements that form the inheritance cycle will be reported as related elements. Use this to decide how to break the inheritance cycle. protocol PR1 : PR2 { // ART_0016 }; protocol PR2 : PR1 { // ART_0016 }; class C1 { statemachine { state State; initial -> State; }; }; class C2 : C1 { statemachine { state State; initial -> State; }; }; class C3 : C2, C4 { // ART_0016 statemachine { state State; initial -> State; }; }; class C4 : C3 { // ART_0016 statemachine { state State; initial -> State; }; };","title":"ART_0016_circularInheritance"},{"location":"validation/#art_0017_circularcomposition","text":"Severity Reason Quick Fix Error A capsule contains itself through a cycle in the composition hierarchy. N/A Parts of a capsule must form a strict composition hierarchy. At run-time the root of this hierarchy is the top capsule instance, and all other capsule instances in the application must be directly or indirectly owned by that capsule instance. For a fixed part the creation of contained capsule instances happen automatically when the container capsule is incarnated. It's therefore possible to statically analyze the fixed parts and check for cycles in the composition hierarchy. Note Only the static type of fixed capsule parts are used when looking for composition cycles. If a part has a capsule factory that specifies a create function using C++ code, then a different dynamic type may be specified for the created capsule instances for that part. This opens up for more possibilities of introducing cycles in the composition hierarchy that will not be detected by this validation rule. The fixed parts that form the composition cycle will be reported as related elements. Use this to decide how to break the composition cycle. capsule CComp2 { fixed part p2 : CComp3; // ART_0017 statemachine { state State; initial -> State; }; }; capsule CComp3 part p3 : CComp2; // ART_0017 statemachine { state State; initial -> State; }; };","title":"ART_0017_circularComposition"},{"location":"validation/#art_0018_circulartransitions","text":"Severity Reason Quick Fix Error A state machine has a cycle in the transitions that execute when leaving a junction. N/A A junction can split an incoming transition flow into multiple outgoing transition flows based on evaluating guard conditions for the outgoing transitions. If care is not taken it's possible to introduce cycles in the outgoing transition flows. Such cycles could lead to infinite recursion when the state machine executes, depending on what guard conditions will be fulfilled at runtime. You should therefore ensure there are no such transition cycles. The transitions that form the cycle will be reported as related elements. Use this to decide how to break the transition cycle. capsule CT_cap { statemachine { // ART_0018 state S1; initial -> S1; junction j1, j2; t1: S1 -> j1; t2: j1 -> j2; t3: j2 -> j1; }; };","title":"ART_0018_circularTransitions"},{"location":"validation/#art_0019_unwiredportbothpublisherandsubscriber","text":"Severity Reason Quick Fix Error An unwired port is declared as being both a subscriber and publisher at the same time. N/A An unwired port can at runtime be connected to another unwired port. One of the connected ports will be a publisher port (a.k.a SPP port) while the other will be a subscriber port (a.k.a SAP port). An unwired port can either be statically declared as being a publisher or subscriber port, or it can be dynamically decided at port registration time if the port should be a publisher or subscriber. The same port can not be both a subscriber and a publisher port at the same time. capsule UnwiredCapsule { subscribe publish port p1 : UnwiredProtocol; // ART_0019 statemachine { state State; initial -> State; }; };","title":"ART_0019_unwiredPortBothPublisherAndSubscriber"},{"location":"validation/#art_0020_wiredportwithunwiredproperties","text":"Severity Reason Quick Fix Warning A property that only is applicable for an unwired port is specified for a wired port. N/A An unwired port may have properties that control how it will be registered at runtime (see registration and registration_name ). These properties have no meaning and will be ignored for wired ports. capsule UnwiredCapsule2 { port p1 [[rt::properties( registration_name=\"hi\" )]]: UnwiredProtocol; // ART_0020 statemachine { state State; initial -> State; }; };","title":"ART_0020_wiredPortWithUnwiredProperties"},{"location":"validation/#art_0021_unwiredportregnamesameasportname","text":"Severity Reason Quick Fix Warning An unwired port is set to use a registration name that equals the name of the port. N/A When an unwired port is registered a name is used that by default is the name of the port. The property registration_name can be used for specifying another name. It's hence unnecessary to use that property for specifying the name of the port, since it is the default name that anyway would be used. capsule UnwiredCapsule3 { unwired behavior port p1~ [[rt::properties( registration_name = \"p1\" )]] : UnwiredProtocol; // ART_0021 statemachine { state State; initial -> State; }; };","title":"ART_0021_unwiredPortRegNameSameAsPortName"},{"location":"validation/#art_0022_ruleconfigproblem","text":"Severity Reason Quick Fix Warning The rule_config property has a malformed value. N/A The rule_config property can be set on Art elements to configure which validation rules to run for that element (and for all elements it contains). It can also be used for setting a custom severity for those rules. The value of the rule_config property should be a comma-separated list of 5 letter strings where the first letter specifies if the rule is disabled and it's severity (X,I,W,E) and remaining letters specify the rule id. See Configuring Validation for more information and examples. capsule RCP [[rt::properties( rule_config=\"X0000\" // ART_0022 (a validation rule with id 0000 does not exist) )]]{ statemachine { state State; initial -> State; }; };","title":"ART_0022_ruleConfigProblem"},{"location":"validation/#art_0023_entryexitcodecount","text":"Severity Reason Quick Fix Error A state has too many entry and/or exit actions. N/A A state can at most have one entry and one exit action. Solve this problem by merging all entry and exit actions of the state to a single entry and exit action that performs everything that should be done when the state is entered and exited. capsule CX { statemachine { state Composite { entry // ART_0023 ` entry1(); `; entry // ART_0023 ` entry2(); `; }; initial -> Composite; }; };","title":"ART_0023_entryExitCodeCount"},{"location":"validation/#art_0024_unwiredportnotbehavior","text":"Severity Reason Quick Fix Error An unwired port is not defined as a behavior port. Make Behavior Port, Make Wired Port An unwired port cannot be connected to another port by means of a connector . Hence, it's required that an unwired port is defined to be a behavior port. Otherwise it would not be possible for the owner capsule to send and receive events on an unwired port. Two Quick Fixes are available for fixing this problem. Either the port can be turned into a behavior port, or it can be turned into a wired port. capsule Pinger { service unwired port p1 : PROTO; // ART_0024 statemachine { state State1; initial -> State1; }; };","title":"ART_0024_unwiredPortNotBehavior"},{"location":"validation/#art_0025_portonpartconnectionerror","text":"Severity Reason Quick Fix Error A wired port is not properly connected, or an unwired port is connected. N/A An unwired port must not be connected to another port by means of a connector . Instead you should register such a port dynamically so that it can be connected at runtime with another matching port. A wired port, however, must be connected. If the port is not a behavior port, it must be connected both on the \"inside\" and on the \"outside\" by two connectors. That is because the purpose of such a relay port is to simply relay communication from one port to another. By \"inside\" we mean the composite structure of the capsule that owns the port, and by \"outside\" we mean the composite structure to which the part that is typed by the capsule belongs. If the port is a behavior port, it should only be connected on the \"outside\". capsule Top { part ping : Pinger, // ART_0025 (not connected in capsule Top) pong : Ponger; // ART_0025 (not connected in capsule Top) statemachine { state t21; initial -> t21; }; }; capsule Inner { service behavior port p : PROTO; statemachine { state State; initial -> State; }; }; capsule Pinger { service port p1 : PROTO; part inner : Inner; connect p1 with inner.p; statemachine { state State1; initial -> State1; }; }; capsule Ponger { service behavior port p2~ : PROTO; statemachine { state State1; initial -> State1; }; }; In the above picture we can more easily understand the two errors reported for the Top capsule's two parts ping and pong . Port Ponger::p2 is a behavior port so one connection is expected for that port (but none is present), while port Pinger::p1 is a non-behavior port so two connections are expected for that port (but only one is present, on its \"inside\"). Both problems can be solved by adding a connector in Top which connects these ports on their \"outside\".","title":"ART_0025_portOnPartConnectionError"},{"location":"validation/#art_0026_illegalconnection","text":"Severity Reason Quick Fix Error A connector connects two ports with incompatible conjugations. N/A Ports connected by a connector must have compatible conjugations. If the ports are at the same level in the capsule's structure (e.g. both ports belong to capsules typing capsule parts owned by the same capsule), then the connected ports must have the opposite conjugation. This is because events that are sent out from one of the ports must be able to be received by the other port. However, if the ports are at different levels in the capsule's structure (e.g. one of them belongs to a capsule typing a capsule part owned by the capsule and the other belongs to the capsule itself), then the ports must have the same conjugation. This is because in this case events are simply delegated from one capsule to another. capsule Top { part ping : Pinger, pong : Ponger; connect ping.p1 with pong.p2; // ART_0026 (same port conjugations but should be different) statemachine { state t21; initial -> t21; }; }; capsule Inner { service behavior port p : PROTO; statemachine { state State; initial -> State; }; }; capsule Pinger { service port p1~ : PROTO; part inner : Inner; connect p1 with inner.p; // ART_0026 (different port conjugations but should be same) statemachine { state State1; initial -> State1; }; }; capsule Ponger { service behavior port p2~ : PROTO; statemachine { state State1; initial -> State1; }; }; Here we see that both connectors are invalid. Port p2 and port p1 are at the same level in Top 's structure so their conjugations should be different, while port p1 and port p are at different levels in Top 's structure so their conjugations should be the same.","title":"ART_0026_illegalConnection"},{"location":"validation/#art_0027_incompatibleprotocolsforconnectedports","text":"Severity Reason Quick Fix Error A connector connects two ports with incompatible protocols. N/A Ports connected by a connector must have compatible protocols. For RTist in Code this means that the protocols must be the same. Note HCL RTist uses a different criteria for protocol compatibility. There two protocols are compatible if all events that can be sent by a port typed by the source protocol can be received by the other port typed by the target protocol. Also in HCL RTist the most common case is that the source and target protocols are the same, but they can also be different as long as all their events (both in-events and out-events) match both by name and parameter data type. This is a legacy behavior which is not recommended, and hence not supported by RTist in Code. protocol PROTO1 { in pong(); out ping(); }; protocol PROTO2 { in pong(); out ping(); }; protocol PROTO3 { in pong(); out ping3(); }; capsule Top { service port p1 : PROTO1; service port p2~ : PROTO2; service port p3~ : PROTO3; connect p1 with p2; // ART_0027 (but OK in HCL RTist) connect p1 with p3; // ART_0027 (also not OK in HCL RTist due to event ping3) statemachine { state t21; initial -> t21; }; };","title":"ART_0027_incompatibleProtocolsForConnectedPorts"},{"location":"validation/#art_0028_superfluoustrigger","text":"Severity Reason Quick Fix Warning A transition has a trigger which can never be triggered at runtime since there is another trigger on a transition from the same state that is identical. N/A Triggers for outgoing transitions of a state must be different. If two triggers specify the same event and port, and neither of them has a guard condition, then both of them will be enabled at the same time. In this case only one of the triggers will trigger the transition at runtime and the other one is superfluous. You can fix this problem either by removing the superfluous trigger, or to add a guard condition to one or both of the triggers or transitions. This validation rule is not run when the trigger or its transition has a guard, since it's then not possible to statically determine whether a trigger is superfluous or not. capsule Base_27 { service port timer : Timing; statemachine { state BS; initial -> BS; _XTRANS: BS -> BS on timer.timeout; }; }; capsule SC27 : Base_27 { statemachine { state State, State2; redefine _XTRANS : BS -> State on timer.timeout; BS -> State2 on timer.timeout; // ART_0028 State -> State2 on timer.timeout; }; };","title":"ART_0028_superfluousTrigger"},{"location":"validation/#art_0029_transitiontocompositestatenoentry","text":"Severity Reason Quick Fix Warning A composite state is entered without using an entry point. N/A If a composite state is entered without using an entry point, the behavior may be different the first time the state is entered compared to subsequent times it's entered. The first time the initial transition of the composite state will execute, while after that it will be entered using deep history (i.e. directly activate the substate that was previously active in the composite state). This difference in behavior is not evident just by looking at the state diagram, and can therefore be surprising and cause bugs. It's therefore recommended to always enter a composite state using an entry point. See Hierarchical Statemachines for more information. capsule Cap { statemachine { state BS { entrypoint ep1; initial -> Nested; state Nested; }; _Initial: initial -> BS; // ART_0029 }; };","title":"ART_0029_transitionToCompositeStateNoEntry"},{"location":"validation/#art_0030_transitiontocompositestatenoentrynoinitialtrans","text":"Severity Reason Quick Fix Error A composite state is entered without using an entry point, and its state machine has no initial transition. N/A This validation rule is related to ART_0029_transitionToCompositeStateNoEntry . If a composite state is entered without using an entry point, and the nested state machine of the composite state has no initial transition, then it is undefined what to do when entering the state. This is therefore not allowed. capsule Cap { statemachine { state BS { entrypoint ep1; state Nested; }; _Initial: initial -> BS; // ART_0030 }; };","title":"ART_0030_transitionToCompositeStateNoEntryNoInitialTrans"},{"location":"validation/#art_0031_portbothnonserviceandnonbehavior","text":"Severity Reason Quick Fix Error A port is both a non-service and a non-behavior port at the same time. N/A A port that is not a service port is internal to a capsule. For such a port to be useful it must be a behavior port; otherwise the capsule cannot send and receive events on the port. Hence, a non-service port cannot at the same time be a non-behavior port. capsule C31 { port fp : Proto; // ART_0031 statemachine { state State; initial -> State; }; };","title":"ART_0031_portBothNonServiceAndNonBehavior"}]}