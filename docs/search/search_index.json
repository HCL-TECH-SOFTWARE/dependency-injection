{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"art-lang/","text":"Art is a language for developing stateful and event-driven realtime applications. By stateful we mean that the application consists of objects whose behavior can be described with state machines. By event-driven we mean that these objects communicate with each other by sending events, which can cause their state machines to transition from one state to another. The Art language is an extension of C++, that provides high-level concepts not directly found in the C++ language. All these high-level concepts are transformed into C++ code by the Art compiler . Generated code uses a run-time library known as the TargetRTS ( Target RunTime System ). The TargetRTS is a C++ library that acts as a layer between the generated code and the underlying platform (hardware, operating system etc) on which the realtime application runs. Art is well suited for describing both the behavior and structure of a realtime application, but it uses C++ as expression and action language. C++ is also used for declaring types, variables, functions etc. As a rule of thumb, Art uses C++ for everything where C++ is a good fit, and only provides new language concepts where no appropriate constructs exist in C++. This means that if you already know C++, you can quickly learn Art too, and existing C++ code you may have already written can still be used. Concepts and Terminology In Art the concept of a capsule is central. A capsule is like a C++ class, but with a few differences and extensions. A C++ class is passive in the sense that a caller can access its public member functions and variables at any time. Hence a C++ object always executes in the context of the caller, and when a member function is called, the caller is blocked until it returns. A capsule, however, is active and has its own execution context. This means that we never call a capsule member function or access a capsule member variable from outside the capsule itself. Instead we communicate with the capsule by sending events to it. Each capsule has a queue of events it has received and the events will be dispatched to the capsule one by one. The sender of the event is not blocked, as the event will be handled by the capsule asynchronously when it is later dispatched. The picture below shows 3 capsule instances each holding a queue with events that have been received, but not yet dispatched. Note that this picture is conceptual. In a real implementation several performance optimizations are applied, for example it's common to let a single thread drive more than one capsule instance, and several capsule instances can share a common event queue. But from a conceptual point of view each capsule has its own queue of events that are waiting to be dispatched to it. Events have a priority which determines how they are ordered in the queue. Events with high priority are placed before events with lower priority, and if two events have the same priority they are ordered according to when they arrive. A capsule may have ports. A port is typed by a protocol which defines the events that may be sent in to the port (these are known as in-events ), as well as the events the capsule itself may send out through the port for others to receive (these are called out-events ). Ports can be used both for internal and external communication. A port used for external communication is called a service port . Together the service ports constitute the communication interface of the capsule, and decides what \"services\" the capsule provides for other capsules to use. A simple capsule which only handles a small number of events, may be able to handle all these events using a single state machine. However, when new ports are added (or new events in protocols typing existing ports), the capsule interface grows and the state machine has to grow with it, since there will be more events for it to handle. Eventually a point is reached where it will not be practical for a capsule to handle any more events in its own state machine, because it has grown too large or complex. If not before, this is the time to define a composite structure for the capsule. A composite structure is created by decomposing a capsule using capsule parts. A capsule part (or for simplicity just part ) is typed by another capsule and is a way for a capsule to delegate some of its responsibilities to other capsules. Such a decomposition is purely an implementation detail that is not visible from the outside of the capsule. When you send an event to a capsule you cannot know if the capsule will handle the event itself, or if it will forward the event to another capsule typing one of its capsule parts. The ability to decompose a capsule into parts is important for managing complexity. When a capsule has grown too big and complex you can decompose it into capsule parts without changing the communication interface of the capsule. Ports of capsules typing capsule parts are connected to each other by means of connectors. A connector is a conceptual construct for showing how events are routed in the internal structure of a capsule. At run-time connectors don't exist, and ports are directly connected to each other. Because of this, it's not mandatory to use connectors. You can also choose to dynamically connect (and disconnect) ports at run-time. Although this provides for more flexibility, it has the drawback of making it impossible to statically visualize the communication paths of a capsule. Ports that connect statically to other ports via connectors are called wired ports. Ports that are connected dynamically without use of static connectors are called unwired ports. The picture below shows the structure of a capsule Top which consists of two capsule parts ping and pong each holding a capsule instance (a Pinger capsule and a Ponger capsule respectively). The connector between the wired ports p on these capsules makes it possible for these capsules to communicate with each other. Communication can also happen using the unwired ports q1 and q2 if they are connected at run-time. The picture also shows that the capsule Ponger is further decomposed using a capsule part inner . All events sent to port p of Ponger will be further routed to port i of the Internal capsule. Regardless if ports are statically connected by connectors (wired ports), or dynamically connected at run-time (unwired ports), they must be compatible with each other. This means that the out-events of one port must match the in-events of the other port, for the ports to be possible to connect. This constraint ensures that events are never lost when traveling between two connected ports. To make it possible to describe the events that may travel between two connected ports using a single protocol, it's possible to make one of the ports conjugated . For a conjugated port the meaning of in-events and out-events are swapped, so that the in-events are the events that may be sent out through the port, and the out-events are the ports that may be sent to the port. In the picture above port q1 is non-conjugated ( ) while port q2 is conjugated ( ). Both capsule parts and ports may have multiplicity. You can think about a capsule part with multiplicity > 1 as an array that holds capsule instances at run-time. In the same way you can think about a port with multiplicity > 1 as an array that holds connections to port instances at run-time. The multiplicity of ports and parts must match when connecting two ports with each other. Once again, this constraint ensures that events will not be lost when traveling between the connected ports at run-time. The picture below shows a capsule with a part and a port that both have multiplicity > 1. In structure diagrams such parts and ports are shown as \"stacked boxes\". In addition to regular C++ member functions a capsule may have a state machine as its behavior. A state machine describes how an instance of the capsule may move between different states through its life-time. A transition that connects a source state with a target state may be triggered when an event from a capsule's event queue is dispatched. Several conditions must hold true for the transition to trigger. For example, the event must match a trigger that specifies the expected type of event and the port on which it was received. It's also possible to associate a boolean guard condition with the transition and/or with the trigger which must be true for the transition to trigger. A transition may have an effect , which is a piece of C++ code that executes when the transition gets triggered. The picture below shows a state machine containing three states and three transitions. The presence of transition guard code is shown with a yellow dot and the presence of transition effect code is shown with a blue dot. Both these are C++ code snippets that are embedded in the Art file. When a capsule instance is created (this is sometimes referred to as capsule incarnation ), it's state machine starts to execute by triggering the transition that goes out from the initial state (the big blue circle in the above diagram). Each state machine must have exactly one such initial state with an outgoing transition. Since this initial transition is triggered automatically when the capsule instance is created it cannot have any constraints like mentioned above. The initial transition is an example of a non-triggered transition since it cannot have triggers. The path from the source state to the target state can sometimes consist of more than one transition. In that case only the first of these is a triggered transition that may have triggers that specify when it will trigger. Once the first transition in this path has triggered, subsequent non-triggered transitions will always execute, one by another according to how they are connected in the state machine. However, also non-triggered transitions (with the exception of the initial transition) may have guards. Such guards are usually evaluated before the triggered transition triggers to ensure that they all are enabled, so that it's guaranteed that the target state can be reached. There is one exception to this rule, for transitions that leave a choice . Such guards are only evaluated once the choice has been reached to dynamically decide which outgoing transition to take next. This also means that guards of such transitions must be mutually exclusive, or there is a risk that the state machine will get stuck in the choice. In the state machine shown below the transitions t2 and t5 are triggered transitions, while other transitions are non-triggered. Transition t5 can only be triggered if either the guard of t7 or t6 is true, while t2 can be triggered even if neither the guard of t3 nor t4 is true. The target of transition t5 is a junction which is used for either splitting or merging transition paths depending on evaluated guard conditions. A state may be decomposed by a sub state machine. Such a state is called a composite state and a state machine that has composite states is called a hierarchical state machine . Transitions enter a composite state through an entry point and exit it through an exit point . Usually an entry point is connected to a nested state inside the state machine of the composite state, but it can also connect to a deep history . Reaching the deep history of a composite state means that all sub states that were previously active will become active again. Hence, deep history is a way to restore a composite state so all its nested states will be reactivated again recursively. The picture below shows a state machine with a composite state Composite containing two nested states S1 and S2 . When this state machine starts to execute state S1 first becomes active since Composite is entered using the ep1 entry point. Later, when leaving S2 through the ex1 exit point, state X becomes active. Then when leaving X through the transition that connects to the ep2 entry point the state S1 once again becomes active since ep2 is connected to the deep history. Of course, whenever a nested state is active, the enclosing composite state is also active. At any point in time a state machine has an active state configuration , which consists of the set of currently active states. A state may have an entry action and/or exit action which is a C++ code snippet that gets executed whenever the state is entered or exited. Note that state entry actions for nested states also run when those states are entered because of a deep history. In state diagrams the presence of entry and/or exit actions are shown by icons just below the state name. In the state machine shown below state S1 has an entry action, state S2 has an exit action and state S3 has both an entry and an exit action. A transition where the source and target state is the same state is called a self-transition . A special kind of self-transition is an internal transition , which is a transition that when triggered doesn't leave the current state. Hence, when an internal transition is triggered the active state configuration remains unchanged, and neither the entry nor exit action of the state gets executed. In the state machine shown below the state has two self-transitions; t which is a regular self-transition (a.k.a. external self-transition ) and it which is an internal transition. Since a state may have a large number of internal transitions they are not shown inside the state symbol, but if you select the state symbol you can see them in the Properties view. An icon is shown on those states that contain internal transitions. State machines can not only be defined for capsules but also for regular classes. This can be useful if you want a plain passive C++ class to have a state machine. Contrary to a capsule a class may not have ports and doesn't execute in its own context. It's therefore common to associate such a class with a capsule that it can use for sending events through its ports. Transitions of a passive class state machine are triggered by calling trigger operations on the class. Such operations have no code, but just trigger transitions in the class state machine. The realtime application needs to designate one capsule as the top capsule . This is done in the transformation configuration , which is a file containing all the properties used for building the application (e.g. code generator options, compiler settings etc.). There is no language construct in Art for defining a top capsule; any capsule that you define can act as the top capsule. However, in practise you typically decide at an early stage which capsule that will be the top capsule. If you build a library rather than an executable you don't have a top capsule. The top capsule is the entry point of the realtime application. When it starts to execute one instance of the top capsule will be automatically created, and its state machine starts to execute. Embedded C++ Code Art uses C++ as action and expression language. It also uses C++ for defining types, variables and functions. A C++ code snippet can be embedded into Art at many places by enclosing it with backticks. Here is an example of how to write the code that should execute when a transition triggers: S1 -> S2 on timer.timeout ` std::cout << \"Hello World!\" << std::endl; `; Here is another example that shows how to include some C++ code as the implementation preface of a capsule: capsule BrewControl { [[rt::impl_preface]] ` #include <iostream> ` }; Code snippets can not only be associated with Art language constructs as in the above two examples, but can also be placed at the Art file level. There are two such file-level code snippets: Declarations (rt::decl) May contain arbitrary C++ declarations. All these code snippets will be generated into a C++ header file with the same name as the Art file. Implementations (rt::impl) May contain arbitrary C++ implementations. All these code snippets will be generated into a C++ implementation file with the same name as the Art file. As an example, assume we have an Art file sample.art with the following contents [[rt::decl]] ` typedef C* Cptr; Cptr func1(); ` [[rt::impl]] ` Cptr func1() { return nullptr; } ` Two C++ files will be generated from this Art file: sample.art.h typedef C* Cptr; Cptr func1(); sample.art.cpp #include \"sample.art.h\" Cptr func1() { return nullptr; } File-level code snippets are useful whenever you need to include some C++ code in your application that doesn't naturally belong to any particular Art element. They can for example be used for declaring and implementing utility functions or types that are needed by many different Art elements. To use the declared elements from an Art element, you need to add an #include for the generated header file using a code snippet on the Art element. Note that an #include is needed even if the Art element is located in the same Art file as the declared elements it wants to use. Below is an example that shows how a protocol and a capsule can use the type Cptr defined in sample.art by adding #include s: protocol MyEvents { [[rt::header_preface]] ` #include \"sample.art.h\" ` out alert(`Cptr`); }; capsule Cx { [[rt::header_preface]] ` #include \"sample.art.h\" ` [[rt::decl]] ` protected: Cptr m_ptr; ` // ... }; Here an rt::header_preface code snippet is used for making the generated capsule and protocol header files include sample.art.h while an rt::decl code snippet is used for declaring a member variable m_ptr for the capsule. See the documentation of the different Art elements in the Art Language Reference to learn about what code snippets that are available for each kind of Art element. Textual and Graphical Notations The Art language is a textual language, but many parts of it also have a graphical notation. For example, a state machine can be shown using a graphical state diagram, and the composite structure of a capsule can be shown in a structure diagram. Relationships between capsules, protocols and classes, such as inheritance, can be shown in class diagrams. Below are examples of these three kinds of diagrams: Syntax Art uses a syntax that should look familiar to developers with knowledge about languages like C++ and Java. Declarations are terminated with a semicolon ; Multiple elements declared in the same language construct uses comma , for separating the elements Curly brackets {} are used for grouping nested elements Square brackets [] are used for specifying cardinality (i.e. multiplicity) of elements A dot ( . ) is used as scope resolution operator Line // and block /* */ comments may be freely used for commenting Names and Keywords Names of Art elements must be valid C++ identifiers since they will be used as names of C++ definitions in generated code. Names also must not clash with names used in the TargetRTS. Don't worry. The Art language editor will let you know if you choose a name that won't work. Just like any language, Art has certain keywords that are reserved and which cannot be used as names. These keywords are listed below: Art keywords behavior capsule choice class connect entry entrypoint exclude exclude exit exitpoint fixed history in initial junction notify on optional out part plugin port protocol publish redefine service state statemachine subscribe template trigger typename unwired when with Art is a case-sensitive language and names may use any capitalization. However, just like with most languages, there are conventions for how to capitalize names. Those conventions are described below where each Art language construct is described in detail. Comments The same kinds of comments as in C++ can be used, i.e. line and block comments. // line comment /* block comment */ /* multi-line block comment */ Capsule A capsule defines an active class with its own execution context. It may have ports through which it can receive events . A capsule has a state machine that describes how instances of the capsule transitions between different states in the response to received events. Names of capsules are typically nouns, often describing something that performs some form of activity. For example \"Controller\", \"TrafficLight\" or \"FaultHandler\". By convention names of capsules start with uppercase. Embedded C++ code can be used for declaring member variables, member functions, nested types etc for the capsule. Here is an example of a capsule with a simple state machine and a member variable. capsule Elevator { [[rt::decl]] ` unsigned int currentLevel = 0; ` statemachine { state Waiting; initial -> Waiting; }; }; Note Capsule member variables and member functions may be private or protected, but should usually not be public. To avoid threading issues all communication with a capsule should be done using events, and therefore public members are not recommended. An exception is capsule constructors which need to be accessible from other capsules that create instances of the capsule using a capsule factory. If you anyway let a capsule have public members you need to ensure they are only accessed from the same thread that runs the capsule. The example above uses an rt::decl code snippet for declaring a capsule member variable. Here is the list of all code snippets that can be used for a capsule: Code snippet C++ mapping Example of use rt::header_preface Inserted at the top of the capsule class header file Adding #includes rt::header_ending Inserted at the bottom of the capsule class header file Declaring a type alias for the capsule class rt::impl_preface Inserted at the top of the capsule class implementation file Adding #includes rt::impl_ending Inserted at the bottom of the capsule class implementation file Undefining a macro only used in a capsule implementation rt::decl Inserted into the capsule class header file (inside the class) Declaring a capsule member variable or function rt::impl Inserted into the capsule class implementation file Implement a capsule member function Capsule Constructor Just like a regular class a capsule may have constructors. A capsule constructor is declared using an rt::decl code snippet and defined using an rt::impl code snippet. All capsule constructors have two mandatory parameters: rtg_rts This is the controller ( RTController* ) which will execute an instance of the capsule rtg_ref This is the part ( RTActorRef* ) into which the capsule instance will be inserted After these parameters you can add your own parameters, to pass arbitrary initialization data to the capsule instance. Below is an example where a capsule MyCap has a reference variable m_c . To initialize this variable a capsule constructor is used. capsule MyCap { [[rt::decl]] ` public: MyCap(RTController*, RTActorRef*, MyClass&); private: MyClass& m_c; ` [[rt::impl]] ` MyCap(RTController* rtg_rts, RTActorRef* rtg_ref, MyClass& c) :RTActor(rtg_rts, rtg_ref), m_c(c) { } ` // ... }; Note that a capsule constructor must call the RTActor constructor in its initializer.. Protocol and Event A protocol defines events that may be sent in to a port (so called in-events) and events that may be sent out from the same port (so called out-events). By grouping events into protocols, and then typing ports with such protocols, we can precisely define which events the capsule may send and receive through that port. By convention names of protocols start with uppercase, while names of events start with lowercase and use camelCase if the name consists of multiple words. A protocol event may have a parameter, which enables it to carry data. You declare a parameter for an event by specifying the C++ type of the data to be carried by the event. Note An event can have at most one parameter. If you need to send multiple data objects with an event you can declare an event parameter of struct or class type. The following code snippets can be used for a protocol: Code snippet C++ mapping Example of use rt::header_preface Inserted at the top of the protocol class header file Adding #includes rt::header_ending Inserted at the end (or near the end) of the protocol class header file Undefining a local macro that was defined in rt::header_preface Here is an example of a protocol that defines some in-events and some out-events: protocol MachineEvents { in start(); in startDeferred(`unsigned long` /* milliseconds */); out success(); out error(`std::string` /* error message */); in relayEvent(); out relayEvent(); }; The event relayEvent above is both an in-event and an out-event. Such symmetric events are useful in protocols typing ports the may receive and send the same events (for example a port that just forwards received events to another port). By convention a symmetric event is declared on a single line. At run-time we often talk about a message rather than an event. A message is an instance of an event, similar to how a capsule instance is an instance of a capsule. In other words, a message is a run-time concept while an event is a design-time concept. Port A port defines a named point of communication for a capsule. A port is typed by a protocol which defines the events that may be sent in to (in-events) and out from (out-events) the port. A port may be conjugated in order to swap the meaning of in-events and out-events. That is, a capsule may send out-events on its non-conjugated ports, but in-events for its conjugated ports. A port becomes conjugated if you add a tilde (~) after its name. Ports are often named to describe the role or purpose of the communication that takes place on them. Note that when a capsule wants to send an event to another capsule it's the port name that is referenced, rather than the name of the receiver capsule (which the sender capsule shouldn't need to know about). By convention names of ports start with lowercase and use camelCase if the name consists of multiple words. Here is an example of a capsule with a few ports. Note that RTist in Code provides several predefined protocols that can be used right away, for example Timing . Also note that you can declare multiple ports on a single line if the ports are of the same kind ( p1 and p2 below are both service ports). capsule Machine { service port control : MachineEvents; behavior port timer : Timing; // predefined Timing protocol service behavior port control2 : CtrlEvents; service port p1~ : MoreEvents, p2~ : OtherEvents; // ... }; Service ports constitute the externally visible communication interface for a capsule, and together they define which events can be sent to the capsule, and which events the capsule can send out for other capsules to receive. In a structure diagram the service ports are shown on the border of a capsule or part symbol. A behavior port is logically connected to the behavior (i.e. state machine ) of a capsule. This means that an event that a capsule receives on a behavior port will be handled by the state machine of that capsule. A non-behavior port, however, will simply route an event to another port to which it is connected. Every sent event will ultimately reach a behavior port (provided ports are properly connected), and the state machine of the capsule owning that behavior port will handle the event. In a structure diagram, behavior ports are connected to a small ellipse which represents the capsule state machine. Note that ports can also be shown in a class diagram. Port Multiplicity At run-time an instance of a port can be connected to a port instance on another capsule. Such connections is what make a sent event be routed from the port on which it is sent, through a number of non-behavior ports, until it finally reaches a behavior port. By default a port has single multiplicity (1) meaning that at most one such connection can be established. However, you can specify a non-single multiplicity for a port to allow for more connections to be created at run-time. In the example below a Server capsule has a port with multiplicity 100. At run-time an instance of that Server capsule can be connected to 100 different client ports, each of which can send events to the server. capsule Server { service port clients : ComEvents[100]; // ... }; In a structure diagrams a port is shown as \"stacked\" if it has non-single multiplicity. You can also use a C++ expression to specify the port multiplicity. This can for example be useful if the multiplicity is defined in C++ as a macro, a template parameter or a constexpr. For example: capsule Server { service port clients : ComEvents[`NBR_CLIENTS`]; // ... }; Notification Port Every protocol contains two implicit events rtBound and rtUnbound. A port can choose to receive those events whenever a connection for the port is established (rtBound) or dropped (rtUnbound) at run-time. Declare a port as a notification port to receive these events. capsule Server { service notify port clients : ComEvents[100]; // ... }; Port notifications are useful in dynamic systems when capsules need to wait until other capsules are ready, before they can start to communicate with those capsules. For example, a client may need to wait until a server is ready before it sends a request to that server. In the same way it's often useful to get notified when a connection is dropped, since that means communication on that port should no longer take place. Unwired Port Ports are by default wired, meaning that they should be connected with connectors to specify statically how events will be routed. Having a static connector structure defined has the benefit that it becomes possible to look at a capsule's structure diagram to see how events received by the capsule will be routed at run-time. However, in some dynamic systems it's not possible to describe this statically. Ports may be connected and disconnected dynamically and the run-time connections between port instances may hence vary over time. If you need this flexibility you can declare ports as unwired. Here is an example of an application where a client capsule can connect to different kinds of server capsules. Sometimes it may be connected to server1 and sometimes to server2 . It is therefore not possible to describe the connections of Top statically using connectors, and we can instead declare the ports as unwired. capsule Top { part client : Client; part server1 : Server; part server2 : Server; // ... }; capsule Client { service behavior unwired port p : Protocol; // ... }; capsule Server { service behavior unwired port p~ : Protocol; // ... }; Note Only use unwired ports when required. It's strongly recommended to use wired ports whenever possible to enable the visualization of the connector structure in a structure diagram. When unwired ports are required you should write a comment that describes how they will be connected at run-time, since this often cannot easily be concluded by looking at the C++ code of the capsule. An unwired port is always a behavior port. In a structure diagram an unwired port is drawn with a hollow ellipse, while a wired behavior port is drawn with a filled ellipse. In the structure diagram below port q is wired while port p is unwired. An unwired port is either a service access point (SAP) or a service provision point (SPP) depending on the role it plays in a dynamic connection with another unwired port. The capsule that owns the SAP port uses it to subscribe to a service that is published by another capsule by means of an SPP port. The capsule with the SAP port is often called \"client\" or \"subscriber\" while the capsule with the SPP port is often called \"server\" or \"publisher\". Unwired ports get connected by means of registering them under a service name that should be unique in the application. Registration of unwired ports can either happen automatically when the container capsule instance is created, or programmatically at a later point in time. It's also possible to deregister unwired ports in order to disconnect them. You can specify how an unwired port should be registered by means of the following properties: registration specifies when an unwired port should be registered registration_name specifies the service name with which the port should be registered If you choose to register an unwired port programmatically (using the TargetRTS functions registerSPP and registerSAP ) you decide at registration time whether the port should be an SAP or SPP port. However, if you choose to instead let the port be registered automatically you need to declare the port as either a subscribe (SAP) or publish (SPP) port. Here is the same example again, but now with automatic registration of the unwired ports using the service name myService : capsule Client { subscribe behavior port sap [[rt::properties( registration_name = \"myService\") ]] : Protocol; // ... }; capsule Server { publish behavior port spp~ [[rt::properties( registration_name = \"myService\") ]] : Protocol; // ... }; Note that the keyword unwired is implicit when you declare a port as either a subscribe or publish port. Connector Connectors describe how events are routed within a capsule by connecting ports in its composite structure. They make it possible to see in a structure diagram which parts of a capsule that can communicate with each other. Each connector connects exactly two ports with each other. A connected port may either be a port of the capsule itself, or a port of a capsule that types one of its capsule parts. A few constraints decide if it's possible to connect two ports: 1) The ports must be wired. Unwired ports cannot be connected. 2) The ports must be typed by the same protocol. 3) The ports' conjugations must match. If the ports are at the same level in the capsule's structure (e.g. both ports belong to capsules typing capsule parts owned by the same capsule), then the connected ports must have the opposite conjugation. This is because events that are sent out from one of the ports must be able to be received by the other port. However, if the ports are at different levels in the capsule's structure (e.g. one of them belongs to a capsule typing a capsule part owned by the capsule and the other belongs to the capsule itself), then the ports must have the same conjugation. This is because in this case events are simply delegated from one capsule to another. The example below shows the structure diagram of a capsule Top where we can see two connectors. capsule Top { part ping : Pinger, pong : Ponger; connect ping.p1 with pong.p2; // ... }; capsule Internal { service behavior port i~ : PROTO; // ... }; capsule Pinger { service behavior port p1 : PROTO; // ... }; capsule Ponger { service behavior port p2~ : PROTO; part inner : Internal; connect p2 with inner.i; // ... }; The connector between p1 and p2 goes between two ports on the same level which is why these ports must have opposite conjugation. The connector between p2 and i goes between two ports at different levels which is why these ports must have the same conjugation. The non-behavior port p2 is a so called relay port (it just relays all events it receives to another port) and the connector between p2 and i is sometimes called a delegation connector to describe the fact that capsule Ponger uses it for delegating some of its responsiblities to the capsule Inner . Note that relay ports can be optimized away so they don't exist at run-time (i.e. at run-time port p1 can be directly connected to i ). A connector doesn't have a direction, so it doesn't matter in which order it connects the two ports. That is, connecting X with Y is equivalent to connecting Y with X. Part A capsule can be decomposed by means of parts (also called \"capsule parts\" to emphasize that they are parts of a capsule). A part is a container that at run-time may hold one or many capsule instances. The part has a multiplicity that specifies the maximum number of capsule instances it can contain at run-time, and it has a type which is another capsule. All capsule instances must either be of that specific capsule type, or of a capsule type that inherits from it. It's common to name parts according to the capsule that types them. For example, a part typed by a capsule Controller may be called controller , ctrl or perhaps theController . By convention part names start with lowercase and use camelCase if the name consists of multiple words. There are three kinds of parts which determine how and when they will be populated with capsule instances. 1) Fixed part In a fixed part capsule instances are created automatically when the container capsule is created, and destroyed when the container is destroyed. Fixed parts by default have multiplicity 1. Such a part will always contain one and only one instance of the capsule that types the part. 2) Optional part In an optional part capsule instances don't have a strong lifetime relationship with the container capsule as is the case for fixed parts. The capsule instances can be created programmatically using the Frame service of the TargetRTS at some point after the container capsule has been created, and they can be destroyed before the container capsule is destroyed. However, at the latest they will be automatically destroyed when the container is destroyed. Optional parts by default have multiplicity 0..1. This means that it may either contain zero or one capsule instance at any point in time. The presence of zero in the multiplicity is what makes the part optional. 3) Plugin part A plugin part is similar to an optional part in that it is populated by capsule instances programmatically. However, the capsule instances are not created in the plugin part but instead imported into the plugin part from another part. Typically such a capsule instance is first created into an optional part, and then at some later point in time imported into a plugin part. Later it can be deported (i.e. removed) from the plugin part and perhaps imported into another plugin part. This makes it possible to create very dynamic composite structures where the same capsule instance can play different roles in different parts over time. Moving a capsule instance by deporting it from one plugin part and then importing it in another plugin part is more efficient than destroying the capsule instance in one optional part and then creating another capsule instance in another optional part. Plugin parts are typically used together with unwired ports . In general it's possible to import a capsule instance into more than one plugin part at the same time, but it can only be imported if its ports are not already bound in its current location. Plugin parts by default have multiplicity 0..1. In the example below the capsule C contains a few parts of different kinds and multiplicities. Note that you may declare multiple parts on the same line if they are of the same kind (both c and d below are optional parts). capsule C { part a : D; fixed part b : D[4]; optional part c : D, d : D[0..5]; plugin part e : D; part f : D[`COUNT`]; // ... }; Part a is fixed with multiplicity 1 since neither kind nor multiplicity is specified for it. Part b is also fixed (using the \"fixed\" keyword for more clarity) and with multiplicity 4. When an instance of capsule C is created 5 instances of capsule D will be automatically created. One of these instances will be inserted into part a and the others into part b . These instances will remain there until the C capsule instance is destroyed. Part c is optional with multiplicity 0..1. At run-time it can contain at most one instance of capsule D . Part d is also optional but can contain up to 5 instances of D as specified by its multiplicity 0..5. Part e is plugin with the default multiplicity 0..1. At run-time at most one instance of capsule D can be imported into it. That instance must already have been created in another part, for example part c . Part f uses a C++ expression for specifying the multiplicity. This can for example be useful if the multiplicity is defined in C++ as a macro, a template parameter or a constexpr. Parts can be shown in a structure diagram: Parts are shown as \"stacked\" if they have non-single multiplicity. Optional parts are shown with a \"diagonal\" background pattern, while plugin parts are shown with a \"double diagonal\" background pattern. Parts can also be shown in a class diagram: In the above diagram the filled diamonds show that there is a strong life-time relationship between a C instance and the instances of D that are located in the fixed and optional parts a , b , c and d , while this is not the case for the instance located in the plugin part d as shown by the hollow diamond. Part with Capsule Factory If the capsule that types a part has a capsule constructor with custom constructor parameters, you can define a capsule factory for the part. Such a capsule factory consists of two code snippets that define how an instance of that capsule should be created and destroyed. rt::createFunction Defines how to create an instance of the capsule. For example, which constructor arguments to pass, which thread to use for running the created capsule instance, at which index to insert the capsule instance into the part (in case it has multiplicity > 1) etc. rt::destroyFunction Defines how to destroy an instance of the capsule. By default it's destroyed using the delete operator. Here is an example where a part defines a capsule factory that specifies a create function. The create function gets the mandatory constructor parameters rtg_rts and rtg_ref as arguments, as well as an index argument that specifies the index where the created capsule instance would be inserted by default. part engine : Engine [[rt::createFunction]] ` return new Engine(rtg_rts, rtg_ref, true /* custom constructor arg */); `; Note that you may want to create a capsule factory for a part also for other reasons than passing custom constructor parameters. For example, you may want to change the default thread ( RTController* ) that should execute the created capsule instance, or you may want to instantiate an inherited capsule rather than the capsule that types the part. State Machine State machines are used for specifying the behavior of capsules . It is also possible to provide a state machine for a passive class; see Class with State Machine for more information about that. In this chapter we focus on state machines in capsules. A state machine consists of states and transitions. During its lifetime a capsule instance transitions between the various states of its state machine, as a consequence of receiving messages on its behavior ports. When transitioning between two states one or several code snippets may execute. Such code may for example send messages to other capsule instances, something that may cause transitions to execute in their state machines. A state machine may also have pseudo states , which just like states may be connected with transitions, but that unlike states are not places where the state machine should stay for some time. For example, most pseudo states like junctions and entry/exit points merely act as connection points that make it possible to execute more than one transition when transitioning between two states. The notable exception is the choice in which actually the state machine may get stuck for ever, but this is something that should not happen in a correctly designed state machine. State The states of a state machine are the places where the state machine may stay for some time while waiting for another message to arrive. States should have names that describe what is happening while the state machine stays there, or what has happened for the state machine to arrive there. For example, \"WaitForInit\", \"Processing\" or \"Terminated\". By convention state names start with uppercase. You can declare multiple states on the same line using a comma-separated list of state names. It can be good to write a comment in front of the state name, if you want to elaborate more on its meaning that what is possible in the name itself. Here is an example of a state machine with some states: capsule TrafficLight { statemachine { state WaitUntilServerReady, CycleLight; state /* pedestrians are crossing the street */ PedestriansCrossing; initial -> WaitUntilServerReady; WaitUntilServerReady -> CycleLight; CycleLight -> PedestriansCrossing; }; }; A state comment is not visible in a state diagram, but show up in a tooltip when putting the cursor on a reference to the state. They can thereby make it easier to understand a state machine. States may be nested to create a hierarchical state machine . Entry and Exit Action A state may have an entry and/or exit action which is a code snippet that runs whenever the state is entered and/or exited. state Walk { entry ` server.walk().send(); `; exit ` server.stop().send(); `; }; Transition A transition connects a source state (or pseudo state) to a target state (or pseudo state). When a capsule instance handles a message that was received on one of its behavior ports, one or several transitions may execute. It's not required to give a name to a transition, but it's possible and often makes the state machine easier to understand. At least triggered transitions (i.e. transitions where the source is a state) should have a name. A transition name can be choosen to describe what needs to have happened for the transition to execute, for example \"requestReceived\", \"timeout\" etc. By convention transition names start with lowercase and use camelCase if the name consists of multiple words. A triggered transition has one or several triggers which define when the transition can be triggered. Each trigger specifies a port and an event. The trigger can only trigger its transition if the received message is an instance of the specified event, and was received on the specified port. In addition it's possible to provide guard conditions that must be fulfilled for the trigger to trigger its transition. Such a guard condition can be specified for the transition, but also for each individual trigger. Here is an example of a capsule state machine with two triggered transitions requestReceived and timeout . It also contains an initial transition that has no name. capsule MyCap { statemachine { state Waiting, Processing; initial -> Waiting; requestReceived: Waiting -> Processing on com1.request, com2.request when ` return canHandleNow(); ` ` log.log(\"Handling request\"); log.commit(); handle(msg); `; timeout: Waiting -> Waiting on timer.timeout[`return zCount < 10;`]; }; }; Note the following: Triggers are specified as PORT.EVENT after the keyword on . You may specify multiple triggers separated by comma ( , ). A guard condition for the transition is specified after the when keyword, while a guard condition for an individual trigger is specified in square brackets ( [] ) after the trigger. A guard condition is actually a C++ statement that returns the boolean guard condition. Note Guard conditions should execute fast and have no side-effects. They are called frequently to decide which transition to execute when a message has arrived. Initial Transition Every state machine needs exactly one initial transition. When the state machine starts to run, the first thing that happens is that the initial transition executes and takes the state machine to its first state. Therefore, an initial transition is a non-triggered transition and also cannot have a guard condition. But it can of course have an effect code snippet. The source of the initial transition is the initial pseudo state which is declared using the initial keyword. Just like for any transition it's optional to give a name to the initial transition (in fact it's often left unnamed). For capsule instances that are programmatically created (i.e. located in optional capsule parts) you can provide initialization data at the time of creation. This is a data object that can be accessed in the effect code of the initial transition. Here is an example: initial -> WaitForServerInit ` RTpchar str = *((RTpchar*) rtdata); `; Note Any type of data object can be passed as initialization data which means that rtdata is an untyped pointer that has to be casted to the expected type. A more type-safe way of passing initialization data is to define a constructor for a capsule. A capsule constructor can take any number of arguments, while with rtdata only one data object can be passed (even if you of course can group several data objects into a struct or class to circumvent this limitation). With capsule constructors you can pass initialization data also for capsule instances that are located in fixed parts. By default rtdata cannot be modified (it has type const void* ). However, by setting the const_rtdata_param property to false on the initial transition, you can make it non-const. One reason for doing this could be that the initial transition effect code wants to pass some data back to the code that creates the capsule instance. However, you must be very careful if you do this since this will only work if the creating code runs in the same thread that runs the initial transition. A more legitimate reason could be that you want to move the initialization data into a capsule variable, so you can access it later. Moving data can be more efficient than copying it. [[rt::properties(const_rtdata_param=false)]] initial -> Waiting ` pC = std::move(*((MyClass*) rtdata)); `; Internal Transition An internal transition doesn't change the active state and therefore doesn't have a target state. An internal transition is always a triggered transition. You define an internal transition inside the state to which it belongs. Here is an example: state Done { unexpected: on myPort.* ` std::cout << \"Unexpected event received! << std::endl; `; }; Note the usage of an asterisk ( * ) to specify that any event received on myPort will trigger the internal transition when the state machine is in the Done state. Such \"receive-any\" events can of course be used for a trigger of any transition, but can in particular be useful for internal transitions that should handle all messages received on a port that are not handled by other triggered transitions leaving substates of the state. If another event is added to the port's protocol in the future, such a trigger will handle the new event too without a need for being updated. Internal transitions are examples of so called self-transitions. To learn about other types of self-transitions see this chapter . Frequent Transition Sometimes you may have a state where one or a few outgoing transitions can be expected to execute much more frequently than others. You can then set a frequent property on the transition trigger that you expect will trigger the transition frequently. The Art compiler uses this information to optimize generated C++ code so that such transition triggers are evaluated before other triggers that are expected to trigger the transition less frequently. interrupted: Working -> Stopped on [[rt::properties( frequent=true )]] external.interrupt ` // Interrupted while working... `; Note The frequent property relies on optimization features in the C++ compiler that may or may not be available depending on which target compiler that is used. Only use frequent transitions if profiling has shown that you have a need to do this optimization. Choice and Junction Choices and junctions are pseudo states that make it possible to split transition flows in a state machine. That is, one incoming transition may be split into multiple outgoing transitions. Which of the outgoing transitions that will execute is decided by evaluating their guard conditions. For a junction the guard conditions are evaluated already before leaving the currently active state. Only if there exists a path of transitions where all guards are fulfilled, will the active state be exited and the transitions can execute. Otherwise the state machine stays in its current state and attempts to find another path of transitions to execute. For a choice the guard conditions are evaluated after leaving the current state, when reaching the choice itself. The outgoing transition which has a fulfilled guard will execute next. Note It's important that there always is an outgoing transition for a choice with a fulfilled guard condition. Otherwise the state machine will get stuck in the choice without any chance of getting out of it. Choices and junctions must have names, so they can be referenced as the source or target of transitions. You can choose to use a name that gives a hint about what conditions that are checked in the guards of the outgoing transitions. For example, isEnabled for a choice that checks a boolean condition and checkValue when the condition has some other type. If you follow this approach you can then name the outgoing transitions accordingly. For example true and false for a choice that checks a boolean condition. By convention choice and junction names start with lowercase and use camelCase if consisting of multiple words. Sometimes it may be difficult to come up with a good name and in that case you can choose something short and \"technical\" like j1 , check1 etc. Below is an example of a state machine containing a choice and a junction. statemachine { state First, Second, Third; t1: initial -> First; choice isEnabled; junction checkThreshold; switchTurned: First -> isEnabled; true: isEnabled -> Second when ` return isEnabled(); `; false: isEnabled -> Second when ` else `; timeout: First -> checkThreshold; low: checkThreshold -> Third when ` return t < LIMIT1; `; medium: checkThreshold -> Third when ` return t >= LIMIT1 && t < LIMIT2; `; high: checkThreshold -> Third; }; Note the use of the keyword else for defining an else-guard. An else-guard will be fulfilled when no other guard of other outgoing transitions is fulfilled. For choices it's good practise to always have exactly one transition with an else-guard to ensure that at least one guard condition will be fulfilled. Thereby we avoid the risk of the state machine getting stuck in the choice. Else-guards can also be useful for junction transitions, but there they are more optional. You can also define an else-transition for a choice or junction by simply omitting the guard condition. This is consistent with triggered transitions where the absense of a guard condition is equivalent to a guard condition that always is fulfilled. See the transition high in the above example. Guard conditions should be mutually exclusive so that the order in which they are evaluated doesn't matter. Junctions can also be used for merging multiple incoming transition flows into a single outgoing transition. This can for example be useful if you want to reuse a transition path in the state machine for several triggered transitions. statemachine { state S1, S2; junction j1; initial -> S1; t1: S1 -> j1 on port1.e1 ` // handle e1 `; t2: S1 -> j1 on port2.e2 ` // handle e2 `; t3: S1 -> j1 on port3.e3 ` // handle e3 `; common: j1 -> S2 ` // common code here `; }; Of course, in the above simple example the same code reuse could also be obtained by putting the common code in a capsule member function which is called by each of the incoming transitions. But if the common transition is followed by more non-triggered transitions the above approach is more feasible. Hierarchical State Machine A state machine is hierarchical if it contains at least one composite state, i.e. a state with a nested state machine. A transition that is triggered in the enclosing state machine (i.e. the state machine that contains the composite state) should enter a composite state by specifying an entry point of the composite state as the target. In the nested state machine another transition can connect that entry point to a state in the nested state machine. A transition in the nested state machine may specify an exit point of the composite state as the target. In the enclosing state machine another transition can connect that exit point to a state in the enclosing state machine. Entry and exit points are pseudo states that need to be named. The names can be chosen to give a hint about when the composite state is entered or exited through them, for example systemStarted or errorDetected . If you want you can prefix the names with ep or ex . It's also common to use short and \"technical\" names like ep1 or ex1 if a more descriptive name doesn't make sense. By convention entry and exit point names start with lowercase and use camelCase if consisting of multiple words. It's also possible to directly enter a composite state without using an entry point. In this case the behavior will depend on whether the composite state is entered for the first time or not. If it is for the first time, the initial transition of the nested state machine will execute after the transition that targets the composite state has executed. Otherwise the composite state will instead be entered using deep history , i.e. by activating the state in the nested state machine that was most recently active (and recursively if that state again is a composite state). Note It's recommended to always enter a composite state using an entry point as the behavior then doesn't depend on if the state was previously entered or not. Below is an example of an hierarchical state machine with a composite state CompositeState that contains a nested state machine. Note that you can declare multiple entry or exit points on the same line. statemachine { initial -> CompositeState.ep1; state CompositeState { state Nested; entrypoint ep1, ep2; exitpoint ex1; initial -> Nested; ep1 -> Nested; Nested -> ex1; ep2 -> history*; }; state Other; CompositeState.ex1 -> Other; Other -> CompositeState.ep2; }; Note that a dot ( . ) is used as scope resolution operator, to make it possible to reference an entry or exit point from the enclosing state machine. Inside the nested state machine the entry and exit points are directly accessible without use of the scope resolution operator (using it there would be an error). It is possible to only connect an entry point on the \"outside\". Entering such an entry point will behave in the same way as entering the composite state without using an entry point (see above). It's therefore not recommended. In the same way it's possible to exit a composite state using an exit point that only is connected on the \"inside\". In this case the composite state is not exited and instead the previously active substate again becomes active (recursively, just like for deep history ). This is also not recommended, unless the transition is a local transition . Deep History Every nested state machine has an implicit pseudo state with the name history* (in state diagrams it's shown as H* to save space). It can be used as a target for any transition inside the nested state machine. When it is reached, the state machine will restore the previously active substate. If that state again is a composite state, its previously active substate will also be restored. This goes on recursively for all nested state machines (which is why it's called a deep history). In the example above we can see that the transition from ep2 targets the deep history pseudo state. This means that if the Nested substate is active and then the transition to ex1 gets triggered, the state Other becomes active. If then the transition to ep2 gets triggered the CompositeState will be entered using deep history so that the Nested substate will again become active. Local Transition A transition in a nested state machine where the source is an entry point and the target is an exit point, and these entry/exit points only are connected on the \"inside\", is a local transition . A local transition is a self-transition that behaves something in between an internal transition and a regular (a.k.a. external) self-transition. An internal transition defined on a composite state handles a message without exiting neither that composite state, nor any of its substates. However, a local transition will exit the composite state and then enter it again, but it will not do this for the substate that is active in the composite state. Hence, if a composite state has an exit action it will be called for the composite state, but not for the active substate. An external self-transition on the other hand will exit both the composite state and all active substates recursively, and then enter these states again. Exiting happens bottom-up which means that the deepest nested substate will first be exited, then its parent state, and so on until the top composite state is exited. Entering happens in the opposite order, i.e. in a top-down fashion. Let's look at an example to understand the difference between these three kinds of self-transitions: statemachine { initial -> SelfTransitionExample; state SelfTransitionExample { state Nested1 { state Nested2; }; internal: on port1.e1 ` // Internal transition `; entrypoint e1; exitpoint e2; local: e1 -> e2 ` // Local transition `; }; external: SelfTransitionExample -> SelfTransitionExample on port2.e2 ` // External transition `; }; Assume the currently active state configuration is { SelfTransitionExample , Nested1 , Nested2 } when one of the self-transitions get triggered: Internal transition ( internal ) No state is exited and the active state configuration remains unchanged. Local transition ( local ) 1) Nested2 is exited. 2) Nested1 is exited. 3) local executes. 4) Nested1 is entered. 5) Nested2 is entered. External transition ( external ) 1) Nested2 is exited. 2) Nested1 is exited. 3) SelfTransitionExample is exited. 4) external executes. 5) SelfTransitionExample is entered. 6) Nested1 is entered. 7) Nested2 is entered. Class with State Machine Art allows you to create passive classes with state machines. This can be an alternative to using a capsule in case you only need a passive stateful data object, and don't need the ability to send events to it, or to let it execute in its own context. A class with a state machine is more lightweight than a capsule at runtime. Transitions in a class state machine are triggered by calling trigger operations on the class. A trigger operation is similar to a regular member function in C++, but does not have a code behavior of its own. Instead, when you call a trigger operation on an object of a class with a state machine it may trigger a transition in the class' state machine. That transition may have an effect code snippet that will execute. A trigger operation can have parameters which allows you to pass data when calling them. Those parameters can be accessed in the transition that is triggered by it. Below is an example of a class with a state machine with two trigger operations initialize and finalize . Note that you can define multiple trigger operations on the same line. class DataObject { /* Trigger Operations */ trigger initialize(`int` data), finalize(); /* State Machine */ statemachine { state Initial, Initialized, Finalized; initial -> Initial; init: Initial -> Initialized on initialize(`int`) ` // Initialized int i = data; `; Initialized -> Finalized on finalize() ` // Finalized `; }; }; Just like for C++ member functions, trigger operations support overloading. That is, you can have many trigger operations with the same name as long as their full signatures are unique. The signature of a trigger operation consists of its name and the types of all its parameters. When you reference a trigger operation with parameters as a transition trigger, you need to include the types of the parameters (see the trigger for the init transition above). The same transition can be triggered by multiple trigger operations (just like a transition in a capsule state machine can be triggered by multiple events). However, in that case those trigger operations should agree on the names and types of their parameters so that the transition effect code can access them in a way that works regardless of which of the trigger operations that will trigger the transition. Names of classes with state machines by convention start with uppercase, while names of trigger operations and their parameters by convention start with lowercase and use camelCase if the name consists of multiple words. A common design pattern is to let a class-with-statemachine instance be managed by a single capsule instance. This means that the capsule instance is responsible both for creating, using and finally destroying the class-with-statemachine instance. If you follow this pattern it is thread-safe to for example call public member functions defined on the capsule from a transition in the class state machine. This can for example be used as a means for the class state machine to send events through the ports of the capsule (i.e. it can call a capsule member function that sends the event). However, to avoid exposing the full capsule functionality to the class state machine it's recommended to define an interface (i.e. abstract C++ class) which the capsule can implement. This interface can contain only those member functions which the class needs to access from its state machine. A class state machine can use the same constructs as a capsule state machine with a few exceptions: The initial transition cannot access initialization data as can a capsule's initial transition . Instead you can define one or several constructors for the class with parameters needed for passing initialization data when the class-with-statemachine instance is created. See Constructor for more information. Frequent transitions are not supported. The state machine can be hierarchical but the deep history pseudo state is not supported. Instead the shallow history pseudo state can be used. Even if it's possible for a class with a state machine to inherit from another class with a state machine, this doesn't mean that the state machines will be inherited as is the case for capsule inheritance. Read more about this in Inheritance . A class with state machine can have the same code snippets as a capsule. Constructor By default the initial transition of a class state machine executes at the time of constructing the class-with-statemachine instance. This happens because the generated default constructor will call an operation rtg_init1() which contains the code from the initial transition. If you want to wait with \"starting\" the state machine until a later point in time you need to define your own parameterless constructor which doesn't call this function. You can define any constructors you need on a class with a state machine. They are regular C++ constructors and allow to pass initialization data when creating a class-with-statemachine instance. Remember to call the rtg_init1() function in all such constructors, if you want the state machine to start at the time of creating the class-with-statemachine instance. Here is an example of a class with a state machine that has a user-defined constructor: class PC { [[rt::decl]] ` private: double m_data; public: PC(double data); ` [[rt::impl]] ` PC::PC(double data) : m_data(data) { rtg_init1(); } ` statemachine { state First; initial -> First ` // State machine started `; }; }; Shallow History Every nested state machine has an implicit pseudo state with the name history (in state diagrams it's shown as H to save space). It can be used as a target for any transition inside the nested state machine. When it is reached, the state machine will restore the previously active substate. However, if that state again is a composite state it's previously active substate will not be restored. This is in contrast to the deep history for capsule state machines, and is why for a class state machine this pseudo state is referred to as a shallow history. Here is an example: class MyClass { statemachine { state First { entrypoint ep1; ep1 -> history; }; initial -> First.ep1; }; }; Inheritance By using inheritance you can reuse and customize generic ( base ) Art elements into more specific ( derived ) Art elements. An Art element can inherit either from one or several other Art elements, and/or it can inherit from one or several C++ classes. The derived Art element can redefine elements of the base element. The redefining element (located in the derived element) can change one or several properties of the redefined element (located in the base element). This is very similar to how inheritance works in C++, with the difference that in C++ a redefining element has more restrictions on what properties that can be changed in the redefined element. For example, a redefining member function (known as an overridden member function in C++ terminology) must keep the same signature as the redefined member function (known as a virtual base member function in C++ terminology), and can only (in fact, must) change its implementation. In some cases Art inheritance not only allows to redefine inherited elements, but also to completely exclude them. An excluded element is not present in the derived element, so exclusion can be seen as a special form of redefinition where the whole element is removed in the derived element. In C++ it's not possible to exclude any inherited members. Capsule Inheritance A capsule can inherit from another capsule. Only one base capsule is allowed; multiple inheritance is not supported for capsules. In addition a capsule can inherit from any number of C++ classes (or structs). The derived capsule is type compatible with the base capsule in the sense that if you have a capsule part typed by the base capsule, you can at runtime incarnate it with instances of the derived capsule. Capsule inheritance has multiple dimensions. One dimension is the usual C++ inheritance between classes (remember that a capsule is an active class). In this dimension it is for example possible to redefine (a.k.a override) a virtual member function defined in the base capsule or in another base C++ class. But there is also a second dimension where the state machine of the derived capsule will implicitly inherit from the state machine of the base capsule. This makes it possible to redefine transitions and states. For example, a redefining transition in a derived capsule can change the effect code, the guard condition or the target state or pseudo state. And a redefining state in a derived capsule can change the entry or exit action, as well as any substate or subtransition in case the state is composite and has a nested state machine. It's also possible to completely exclude a state or a transition, either in the top capsule state machine, or in a nested state machine. Below is an example of a capsule D that inherits from another capsule B . In addition the capsule D inherits from two C++ classes IDataManager and IController . capsule B { statemachine { state BS, BS2; Initial: initial -> BS; }; }; capsule D : B, `IDataManager`, `IController` { [[rt::decl]] ` // IDataManager impl public: void manageData() override; // IController impl public: void control() override; ` [[rt::impl]] ` // impl of manageData() and control() ` statemachine { state DS; state exclude BS2; redefine Initial: initial -> DS; }; }; In the example we can see that D overrides functions from the base C++ classes that are assumed to be virtual (or pure virtual). For brevity the implementations of these functions have been omitted but would be placed in the rt::impl code snippet. We can also see an example of a state machine redefinition. The initial transition Initial of B 's state machine is redefined in D 's state machine so that it targets state DS instead of state BS . In the state diagram of D the state BS and the initial pseudo state are drawn with gray color and dashed outline, to show that they are inherited. The transition Initial is also drawn in grayed with dashed outline but with a blue label to show that it's redefining the inherited initial transition. The state BS2 is excluded in D 's state machine. In state diagrams excluded elements are by default shown with a \"crossed\" background, but by setting a diagram preference it's also possible to completely hide them from the diagram. Note that to be able to redefine the initial transition of B it is necessary to give it a name (so that it can be referenced as redefined from D ). This is yet another reason why it's good practise to give names to transitions, even if it's not mandated. But, of course, if you want to prevent anyone from creating a derived capsule with a state machine that redefines a certain transition, you can accomplish that by not giving a name to that transition. In effect, an unnamed transition is final , i.e. cannot be overridden or excluded. The rule that a capsule state machine must have exactly one initial transition also applies to a derived capsule. Therefore, when you introduce inheritance between two existing capsules, you typically first get an error saying that the derived capsule has two initial transitions (one inherited, and one locally defined). You then need to decide if you want to either remove the initial transition in the derived capsule, or (like in the above example) instead redefine the initial transition. Capsule inheritance also has a third dimension, which relates to its structure. Parts and ports defined in the base capsule are inherited by the derived capsule. Just like for states and transitions, it's possible to redefine or exclude a part or a port. A redefining port can change the type (i.e. protocol ), multiplicity and the notification property of the redefined port. A redefining part can change the type, multiplicity and kind (fixed, optional or plugin) of the redefined part. Below is an example of a capsule DPPI that inherits from another capsule BPPI . The port port1 and the part part1 is redefined, while the port port2 and part part2 are excluded. capsule BPPI { service port port1 : PR1; port port2 : PR1; part part1 : Cap1; part part2 : Cap1; statemachine { state State; initial -> State; }; }; capsule DPPI : BPPI { service notify port redefine port1 : PR2[10]; optional part redefine part1 : Cap2[0..20]; part exclude part2; port exclude port2; statemachine { state State2; }; }; Class Inheritance A class with state machine can inherit from other classes with state machines, or from C++ classes (or structs). Multiple inheritance is supported. Contrary to capsule inheritance , class inheritance does not imply inheritance between the state machines in the derived and base classes. This means it's not possible to redefine or exclude states and transitions in an inherited class state machine. Nor is it possible to redefine trigger operations. In fact, the derived class will have two state machines (its own, plus the one inherited from the base class) and these two state machines will execute independently of each other. That is, class inheritance is more a way of aggregating state machines rather than reusing and redefining them. Because of this, it's rather unusual to let two classes with state machines inherit each other. It's more useful to let a class with state machine inherit from other C++ classes. Below is an example of a class with state machine that inherits from two C++ classes DataContainer<CData> and IDisposable . class DataClass : `DataContainer<CData>`, `IDisposable` { [[rt::decl]] ` void dispose() override; // From IDisposable ` [[rt::impl]] ` void DataClass:dispose() { // impl } ` statemachine { state State; initial -> State; }; }; Protocol Inheritance A protocol may inherit events from another protocol. Only one base protocol is allowed; multiple inheritance is not supported for protocols. Inherited events can be redefined, but not excluded. A redefining event in a derived protocol can change the type of the event parameter as defined in the base protocol. In the example below, the protocol ExtendedMachineEvents adds one more in-event stop to the inherited MachineEvents protocol. It also redefines the startDeferred event to change its parameter type. protocol MachineEvents { in start(); in startDeferred(`unsigned long` /* milliseconds */); out success(); out error(`std::string` /* error message */); }; protocol ExtendedMachineEvents : MachineEvents { in stop(); in redefine startDeferred(`unsigned long long`); }; Template A template is a type that is parameterized by means of template parameters to make it more generic. When a template is used (a.k.a. instantiated), actual template parameters must be provided that match the formal template parameters defined in the template. Both capsules and classes can have template parameters. Just like in C++ two kinds of template parameters are supported: Type template parameter Replaced with a type when the template is instantiated. Non-type template parameters Replaced with a non-type, for example a constant value, when the template is instantiated. Template parameters may have defaults that will be used if a matching actual template parameter is not provided when instantiating the template. Below is an example of a capsule and a class with template parameters, some of which have defaults specified. The keywords typename and class can both be used for defining a type template parameter. A non-type template parameter is defined by specifying its type as a C++ code snippet. template <typename T = `int`, `int` p1 = `5`> capsule TemplateCapsule { [[rt::decl]] ` void func(T arg1) { // impl } ` service port mp : MachineEvents[`p1`]; statemachine { state State; initial -> State; }; }; template <typename T, class U, `int` p1> class TemplateClass : `Base<T,U,p1>` { statemachine { state State; initial -> State; }; }; Template parameters can only be used from C++ code snippets, and above you see some examples of how they can be used. It's not possible to instantiate a template in Art itself. For example, even if class Base above was defined as an Art class, a C++ code snippet has to be used since it has template parameters. Property Properties are name-value pairs that provide a generic mechanism for augmenting Art elements with extra data. Such data can be utilized by tools that operate on a parsed Art file, such as the code generator and semantic checker. Most Art elements can have properties and the syntax for specifying properties is the same regardless of the kind of element. However, different kinds of Art elements can have different properties. For Art elements that have a name, properties are specified right after the name. For elements without name, properties are specified before the element itself. In both cases the syntax looks like this: [[rt::properties( <property name>=<property value>, <property name>=<property value>, ... <property name>=<property value> )]] All properties have a default value, so you only need to specify a property if you want to set it to something else. The default values have been chosen so that you in most cases don't need to specify any properties at all. A property has a type, and its value must conform to that type. The following property types are supported: Boolean Boolean properties have a value that is either true or false . If you want to set a boolean property to true you can use a shorthand syntax where you just specify the property name. For example: capsule CapProp [[rt::properties( generate_file_impl=false, generate_file_header )]] { // ... }; Writing generate_file_header is equivalent to writing generate_file_header=true . However, this particular property has the default value true and hence doesn't need to be set at all. Integer Integer properties have a numeric value (>= 0). Here is an example: protocol XProtocol [[rt::properties( version=1 )]]{ // ... }; String String properties have a string value, enclosed in double quotes. Here is an example: class MC [[rt::properties( rule_config=\"E0022\" )]]{ // ... }; Enumeration A property of enumeration type has a value that references a literal of the enumeration. There are different enumerations used for different properties. The best way to learn about what enumeration literals that are available for a certain property is to use the Content Assist feature in the Art file editor. Place the cursor after the equal sign, and press Ctrl + Space . Here is an example of defining a property of enumeration type: class MC [[rt::properties( kind=struct )]]{ // ... }; Note that in some cases the name of an enumeration literal starts with underscore ( _ ) to prevent it from clashing with the set of Art keywords . Below is a table that lists all properties that can be used on different kinds of Art elements. Each property is described in a section of its own below the table. Art Elements Property Type Default Capsule , Class generate_file_header Boolean true Capsule , Class generate_file_impl Boolean true Capsule , Class , Protocol , Port , Initial transition , Triggered transition Trigger rule_config String \"\" Class , Protocol version Integer 0 Class generate_descriptor Enumeration (true, false, manual) true Class kind Enumeration (_class, struct, union) _class Class generate_class Boolean true Class generate_statemachine Boolean true Class const_target_param_for_decode Boolean false Class default_constructor_generate Boolean true Class default_constructor_explicit Boolean false Class default_constructor_inline Boolean false Class default_constructor_default Boolean false Class default_constructor_delete Boolean false Class default_constructor_visibility Enumeration (public, protected, private) public Port registration Enumeration (automatic, automatic_locked, application) automatic Port registration_name String \"\" Initial transition , Triggered transition const_rtdata_param Boolean true Transition , State , Choice , Junction , Entry Point , Exit Point color String \"\" Trigger frequent Boolean false generate_file_header By default a capsule or class is translated to one header file ( .h ) and one implementation file ( .cpp ). Set this property to false to prevent generation of the header file, for example if you prefer to write it manually. generate_file_impl By default a capsule or class is translated to one header file ( .h ) and one implementation file ( .cpp ). Set this property to false to prevent generation of the implementation file, for example if you prefer to write it manually. rule_config This property is used for configuring validation rules for an Art element. Read more about this here . version TODO generate_descriptor By default a type descriptor will be generated for each class . The TargetRTS uses the type descriptor to know how to initialize, copy, move, destroy, encode or decode an instance of that class. Set this property to false for classes that don't need a type descriptor. Set it to manual if the class needs a type descriptor but you want to implement it manually rather than using the implementation that is generated by default. Note that even if you set this property to true so that a default type descriptor is generated, you can still override individual type descriptor functions for the class. kind By default a class is translated to a C++ class. You can use this property to instead translate it to a struct or union . generate_class If set to false no C++ code will be generated for the class. generate_statemachine If set to false code generation for the class' state machine will be suppressed. You can use this if the state machine is informal, and you prefer to implement it manually in another way. const_target_param_for_decode By default a decode function uses a non-const target parameter. This is because usually a decode implementation must call non-const functions on the decoded object to populate it with data from the decoding. However, if it doesn't need to call such functions you can set this property so that the target parameter is declared as const. default_constructor_generate If set to false a default (i.e. parameterless) constructor will not be generated for the class. default_constructor_explicit If set to true the default (i.e. parameterless) constructor will be declared as explicit. default_constructor_inline If set to true the default (i.e. parameterless) constructor will be declared as inline. It's implementation will then be generated into the header file. default_constructor_default If set to true the default (i.e. parameterless) constructor will be declared as defaulted. This tells the compiler to synthesize a default constructor even if one normally would not be synthesized (for example because there is a user-defined constructor with parameters). default_constructor_delete If set to true the default (i.e. parameterless) constructor will be declared as deleted? This will cause the compiler to generate an error if it is invoked. This can be used for preventing objects of the class to be created. default_constructor_visibility This property can be used for setting the visibility of the default (i.e. parameterless) constructor. By default it will be public but you can change it either to protected or private . registration This property specifies how to register an unwired port at runtime. The default is automatic which means the port will be registered automatically when the container capsule instance is initialized. The value automatic_locked has the same meaning but the registration will be \"locked\" so that any future attempt to deregister it, or register it under a different name, will fail. Set the property to application to programmatically register the port using the functions registerSPP() and registerSAP() respectively. registration_name This property specifies the name to use when registering a port at runtime. By default the port name is used, but it can be overridden using this property. const_rtdata_param If set to false the rtdata parameter in the transition function will be non-const. It can therefore be modified, which for example can avoid copying received message data and instead move it using its move constructor or move assignment operator. color Specifies which color to use for an Art element in a diagram. Colors should be specified as RGB values using 6 hexadecimal digits. For example, \"#ff00ff\". The Art text editor will help you set an appropriate color by means of a color picker. Note that you can also set the color directly from the diagram. Select a symbol or line and then set the color property using the Properties view (under \"Appearance\"). frequent Triggers for which this property is true will lead to generated code that handles these triggers faster than other triggers. This is done by placing their if-statements early in the rtsBehavior function to ensure that as little code as possible needs to execute when dispatching a message for a frequent trigger.","title":"The Art Language"},{"location":"art-lang/#concepts-and-terminology","text":"In Art the concept of a capsule is central. A capsule is like a C++ class, but with a few differences and extensions. A C++ class is passive in the sense that a caller can access its public member functions and variables at any time. Hence a C++ object always executes in the context of the caller, and when a member function is called, the caller is blocked until it returns. A capsule, however, is active and has its own execution context. This means that we never call a capsule member function or access a capsule member variable from outside the capsule itself. Instead we communicate with the capsule by sending events to it. Each capsule has a queue of events it has received and the events will be dispatched to the capsule one by one. The sender of the event is not blocked, as the event will be handled by the capsule asynchronously when it is later dispatched. The picture below shows 3 capsule instances each holding a queue with events that have been received, but not yet dispatched. Note that this picture is conceptual. In a real implementation several performance optimizations are applied, for example it's common to let a single thread drive more than one capsule instance, and several capsule instances can share a common event queue. But from a conceptual point of view each capsule has its own queue of events that are waiting to be dispatched to it. Events have a priority which determines how they are ordered in the queue. Events with high priority are placed before events with lower priority, and if two events have the same priority they are ordered according to when they arrive. A capsule may have ports. A port is typed by a protocol which defines the events that may be sent in to the port (these are known as in-events ), as well as the events the capsule itself may send out through the port for others to receive (these are called out-events ). Ports can be used both for internal and external communication. A port used for external communication is called a service port . Together the service ports constitute the communication interface of the capsule, and decides what \"services\" the capsule provides for other capsules to use. A simple capsule which only handles a small number of events, may be able to handle all these events using a single state machine. However, when new ports are added (or new events in protocols typing existing ports), the capsule interface grows and the state machine has to grow with it, since there will be more events for it to handle. Eventually a point is reached where it will not be practical for a capsule to handle any more events in its own state machine, because it has grown too large or complex. If not before, this is the time to define a composite structure for the capsule. A composite structure is created by decomposing a capsule using capsule parts. A capsule part (or for simplicity just part ) is typed by another capsule and is a way for a capsule to delegate some of its responsibilities to other capsules. Such a decomposition is purely an implementation detail that is not visible from the outside of the capsule. When you send an event to a capsule you cannot know if the capsule will handle the event itself, or if it will forward the event to another capsule typing one of its capsule parts. The ability to decompose a capsule into parts is important for managing complexity. When a capsule has grown too big and complex you can decompose it into capsule parts without changing the communication interface of the capsule. Ports of capsules typing capsule parts are connected to each other by means of connectors. A connector is a conceptual construct for showing how events are routed in the internal structure of a capsule. At run-time connectors don't exist, and ports are directly connected to each other. Because of this, it's not mandatory to use connectors. You can also choose to dynamically connect (and disconnect) ports at run-time. Although this provides for more flexibility, it has the drawback of making it impossible to statically visualize the communication paths of a capsule. Ports that connect statically to other ports via connectors are called wired ports. Ports that are connected dynamically without use of static connectors are called unwired ports. The picture below shows the structure of a capsule Top which consists of two capsule parts ping and pong each holding a capsule instance (a Pinger capsule and a Ponger capsule respectively). The connector between the wired ports p on these capsules makes it possible for these capsules to communicate with each other. Communication can also happen using the unwired ports q1 and q2 if they are connected at run-time. The picture also shows that the capsule Ponger is further decomposed using a capsule part inner . All events sent to port p of Ponger will be further routed to port i of the Internal capsule. Regardless if ports are statically connected by connectors (wired ports), or dynamically connected at run-time (unwired ports), they must be compatible with each other. This means that the out-events of one port must match the in-events of the other port, for the ports to be possible to connect. This constraint ensures that events are never lost when traveling between two connected ports. To make it possible to describe the events that may travel between two connected ports using a single protocol, it's possible to make one of the ports conjugated . For a conjugated port the meaning of in-events and out-events are swapped, so that the in-events are the events that may be sent out through the port, and the out-events are the ports that may be sent to the port. In the picture above port q1 is non-conjugated ( ) while port q2 is conjugated ( ). Both capsule parts and ports may have multiplicity. You can think about a capsule part with multiplicity > 1 as an array that holds capsule instances at run-time. In the same way you can think about a port with multiplicity > 1 as an array that holds connections to port instances at run-time. The multiplicity of ports and parts must match when connecting two ports with each other. Once again, this constraint ensures that events will not be lost when traveling between the connected ports at run-time. The picture below shows a capsule with a part and a port that both have multiplicity > 1. In structure diagrams such parts and ports are shown as \"stacked boxes\". In addition to regular C++ member functions a capsule may have a state machine as its behavior. A state machine describes how an instance of the capsule may move between different states through its life-time. A transition that connects a source state with a target state may be triggered when an event from a capsule's event queue is dispatched. Several conditions must hold true for the transition to trigger. For example, the event must match a trigger that specifies the expected type of event and the port on which it was received. It's also possible to associate a boolean guard condition with the transition and/or with the trigger which must be true for the transition to trigger. A transition may have an effect , which is a piece of C++ code that executes when the transition gets triggered. The picture below shows a state machine containing three states and three transitions. The presence of transition guard code is shown with a yellow dot and the presence of transition effect code is shown with a blue dot. Both these are C++ code snippets that are embedded in the Art file. When a capsule instance is created (this is sometimes referred to as capsule incarnation ), it's state machine starts to execute by triggering the transition that goes out from the initial state (the big blue circle in the above diagram). Each state machine must have exactly one such initial state with an outgoing transition. Since this initial transition is triggered automatically when the capsule instance is created it cannot have any constraints like mentioned above. The initial transition is an example of a non-triggered transition since it cannot have triggers. The path from the source state to the target state can sometimes consist of more than one transition. In that case only the first of these is a triggered transition that may have triggers that specify when it will trigger. Once the first transition in this path has triggered, subsequent non-triggered transitions will always execute, one by another according to how they are connected in the state machine. However, also non-triggered transitions (with the exception of the initial transition) may have guards. Such guards are usually evaluated before the triggered transition triggers to ensure that they all are enabled, so that it's guaranteed that the target state can be reached. There is one exception to this rule, for transitions that leave a choice . Such guards are only evaluated once the choice has been reached to dynamically decide which outgoing transition to take next. This also means that guards of such transitions must be mutually exclusive, or there is a risk that the state machine will get stuck in the choice. In the state machine shown below the transitions t2 and t5 are triggered transitions, while other transitions are non-triggered. Transition t5 can only be triggered if either the guard of t7 or t6 is true, while t2 can be triggered even if neither the guard of t3 nor t4 is true. The target of transition t5 is a junction which is used for either splitting or merging transition paths depending on evaluated guard conditions. A state may be decomposed by a sub state machine. Such a state is called a composite state and a state machine that has composite states is called a hierarchical state machine . Transitions enter a composite state through an entry point and exit it through an exit point . Usually an entry point is connected to a nested state inside the state machine of the composite state, but it can also connect to a deep history . Reaching the deep history of a composite state means that all sub states that were previously active will become active again. Hence, deep history is a way to restore a composite state so all its nested states will be reactivated again recursively. The picture below shows a state machine with a composite state Composite containing two nested states S1 and S2 . When this state machine starts to execute state S1 first becomes active since Composite is entered using the ep1 entry point. Later, when leaving S2 through the ex1 exit point, state X becomes active. Then when leaving X through the transition that connects to the ep2 entry point the state S1 once again becomes active since ep2 is connected to the deep history. Of course, whenever a nested state is active, the enclosing composite state is also active. At any point in time a state machine has an active state configuration , which consists of the set of currently active states. A state may have an entry action and/or exit action which is a C++ code snippet that gets executed whenever the state is entered or exited. Note that state entry actions for nested states also run when those states are entered because of a deep history. In state diagrams the presence of entry and/or exit actions are shown by icons just below the state name. In the state machine shown below state S1 has an entry action, state S2 has an exit action and state S3 has both an entry and an exit action. A transition where the source and target state is the same state is called a self-transition . A special kind of self-transition is an internal transition , which is a transition that when triggered doesn't leave the current state. Hence, when an internal transition is triggered the active state configuration remains unchanged, and neither the entry nor exit action of the state gets executed. In the state machine shown below the state has two self-transitions; t which is a regular self-transition (a.k.a. external self-transition ) and it which is an internal transition. Since a state may have a large number of internal transitions they are not shown inside the state symbol, but if you select the state symbol you can see them in the Properties view. An icon is shown on those states that contain internal transitions. State machines can not only be defined for capsules but also for regular classes. This can be useful if you want a plain passive C++ class to have a state machine. Contrary to a capsule a class may not have ports and doesn't execute in its own context. It's therefore common to associate such a class with a capsule that it can use for sending events through its ports. Transitions of a passive class state machine are triggered by calling trigger operations on the class. Such operations have no code, but just trigger transitions in the class state machine. The realtime application needs to designate one capsule as the top capsule . This is done in the transformation configuration , which is a file containing all the properties used for building the application (e.g. code generator options, compiler settings etc.). There is no language construct in Art for defining a top capsule; any capsule that you define can act as the top capsule. However, in practise you typically decide at an early stage which capsule that will be the top capsule. If you build a library rather than an executable you don't have a top capsule. The top capsule is the entry point of the realtime application. When it starts to execute one instance of the top capsule will be automatically created, and its state machine starts to execute.","title":"Concepts and Terminology"},{"location":"art-lang/#embedded-c-code","text":"Art uses C++ as action and expression language. It also uses C++ for defining types, variables and functions. A C++ code snippet can be embedded into Art at many places by enclosing it with backticks. Here is an example of how to write the code that should execute when a transition triggers: S1 -> S2 on timer.timeout ` std::cout << \"Hello World!\" << std::endl; `; Here is another example that shows how to include some C++ code as the implementation preface of a capsule: capsule BrewControl { [[rt::impl_preface]] ` #include <iostream> ` }; Code snippets can not only be associated with Art language constructs as in the above two examples, but can also be placed at the Art file level. There are two such file-level code snippets: Declarations (rt::decl) May contain arbitrary C++ declarations. All these code snippets will be generated into a C++ header file with the same name as the Art file. Implementations (rt::impl) May contain arbitrary C++ implementations. All these code snippets will be generated into a C++ implementation file with the same name as the Art file. As an example, assume we have an Art file sample.art with the following contents [[rt::decl]] ` typedef C* Cptr; Cptr func1(); ` [[rt::impl]] ` Cptr func1() { return nullptr; } ` Two C++ files will be generated from this Art file: sample.art.h typedef C* Cptr; Cptr func1(); sample.art.cpp #include \"sample.art.h\" Cptr func1() { return nullptr; } File-level code snippets are useful whenever you need to include some C++ code in your application that doesn't naturally belong to any particular Art element. They can for example be used for declaring and implementing utility functions or types that are needed by many different Art elements. To use the declared elements from an Art element, you need to add an #include for the generated header file using a code snippet on the Art element. Note that an #include is needed even if the Art element is located in the same Art file as the declared elements it wants to use. Below is an example that shows how a protocol and a capsule can use the type Cptr defined in sample.art by adding #include s: protocol MyEvents { [[rt::header_preface]] ` #include \"sample.art.h\" ` out alert(`Cptr`); }; capsule Cx { [[rt::header_preface]] ` #include \"sample.art.h\" ` [[rt::decl]] ` protected: Cptr m_ptr; ` // ... }; Here an rt::header_preface code snippet is used for making the generated capsule and protocol header files include sample.art.h while an rt::decl code snippet is used for declaring a member variable m_ptr for the capsule. See the documentation of the different Art elements in the Art Language Reference to learn about what code snippets that are available for each kind of Art element.","title":"Embedded C++ Code"},{"location":"art-lang/#textual-and-graphical-notations","text":"The Art language is a textual language, but many parts of it also have a graphical notation. For example, a state machine can be shown using a graphical state diagram, and the composite structure of a capsule can be shown in a structure diagram. Relationships between capsules, protocols and classes, such as inheritance, can be shown in class diagrams. Below are examples of these three kinds of diagrams:","title":"Textual and Graphical Notations"},{"location":"art-lang/#syntax","text":"Art uses a syntax that should look familiar to developers with knowledge about languages like C++ and Java. Declarations are terminated with a semicolon ; Multiple elements declared in the same language construct uses comma , for separating the elements Curly brackets {} are used for grouping nested elements Square brackets [] are used for specifying cardinality (i.e. multiplicity) of elements A dot ( . ) is used as scope resolution operator Line // and block /* */ comments may be freely used for commenting","title":"Syntax"},{"location":"art-lang/#names-and-keywords","text":"Names of Art elements must be valid C++ identifiers since they will be used as names of C++ definitions in generated code. Names also must not clash with names used in the TargetRTS. Don't worry. The Art language editor will let you know if you choose a name that won't work. Just like any language, Art has certain keywords that are reserved and which cannot be used as names. These keywords are listed below: Art keywords behavior capsule choice class connect entry entrypoint exclude exclude exit exitpoint fixed history in initial junction notify on optional out part plugin port protocol publish redefine service state statemachine subscribe template trigger typename unwired when with Art is a case-sensitive language and names may use any capitalization. However, just like with most languages, there are conventions for how to capitalize names. Those conventions are described below where each Art language construct is described in detail.","title":"Names and Keywords"},{"location":"art-lang/#comments","text":"The same kinds of comments as in C++ can be used, i.e. line and block comments. // line comment /* block comment */ /* multi-line block comment */","title":"Comments"},{"location":"art-lang/#capsule","text":"A capsule defines an active class with its own execution context. It may have ports through which it can receive events . A capsule has a state machine that describes how instances of the capsule transitions between different states in the response to received events. Names of capsules are typically nouns, often describing something that performs some form of activity. For example \"Controller\", \"TrafficLight\" or \"FaultHandler\". By convention names of capsules start with uppercase. Embedded C++ code can be used for declaring member variables, member functions, nested types etc for the capsule. Here is an example of a capsule with a simple state machine and a member variable. capsule Elevator { [[rt::decl]] ` unsigned int currentLevel = 0; ` statemachine { state Waiting; initial -> Waiting; }; }; Note Capsule member variables and member functions may be private or protected, but should usually not be public. To avoid threading issues all communication with a capsule should be done using events, and therefore public members are not recommended. An exception is capsule constructors which need to be accessible from other capsules that create instances of the capsule using a capsule factory. If you anyway let a capsule have public members you need to ensure they are only accessed from the same thread that runs the capsule. The example above uses an rt::decl code snippet for declaring a capsule member variable. Here is the list of all code snippets that can be used for a capsule: Code snippet C++ mapping Example of use rt::header_preface Inserted at the top of the capsule class header file Adding #includes rt::header_ending Inserted at the bottom of the capsule class header file Declaring a type alias for the capsule class rt::impl_preface Inserted at the top of the capsule class implementation file Adding #includes rt::impl_ending Inserted at the bottom of the capsule class implementation file Undefining a macro only used in a capsule implementation rt::decl Inserted into the capsule class header file (inside the class) Declaring a capsule member variable or function rt::impl Inserted into the capsule class implementation file Implement a capsule member function","title":"Capsule"},{"location":"art-lang/#capsule-constructor","text":"Just like a regular class a capsule may have constructors. A capsule constructor is declared using an rt::decl code snippet and defined using an rt::impl code snippet. All capsule constructors have two mandatory parameters: rtg_rts This is the controller ( RTController* ) which will execute an instance of the capsule rtg_ref This is the part ( RTActorRef* ) into which the capsule instance will be inserted After these parameters you can add your own parameters, to pass arbitrary initialization data to the capsule instance. Below is an example where a capsule MyCap has a reference variable m_c . To initialize this variable a capsule constructor is used. capsule MyCap { [[rt::decl]] ` public: MyCap(RTController*, RTActorRef*, MyClass&); private: MyClass& m_c; ` [[rt::impl]] ` MyCap(RTController* rtg_rts, RTActorRef* rtg_ref, MyClass& c) :RTActor(rtg_rts, rtg_ref), m_c(c) { } ` // ... }; Note that a capsule constructor must call the RTActor constructor in its initializer..","title":"Capsule Constructor"},{"location":"art-lang/#protocol-and-event","text":"A protocol defines events that may be sent in to a port (so called in-events) and events that may be sent out from the same port (so called out-events). By grouping events into protocols, and then typing ports with such protocols, we can precisely define which events the capsule may send and receive through that port. By convention names of protocols start with uppercase, while names of events start with lowercase and use camelCase if the name consists of multiple words. A protocol event may have a parameter, which enables it to carry data. You declare a parameter for an event by specifying the C++ type of the data to be carried by the event. Note An event can have at most one parameter. If you need to send multiple data objects with an event you can declare an event parameter of struct or class type. The following code snippets can be used for a protocol: Code snippet C++ mapping Example of use rt::header_preface Inserted at the top of the protocol class header file Adding #includes rt::header_ending Inserted at the end (or near the end) of the protocol class header file Undefining a local macro that was defined in rt::header_preface Here is an example of a protocol that defines some in-events and some out-events: protocol MachineEvents { in start(); in startDeferred(`unsigned long` /* milliseconds */); out success(); out error(`std::string` /* error message */); in relayEvent(); out relayEvent(); }; The event relayEvent above is both an in-event and an out-event. Such symmetric events are useful in protocols typing ports the may receive and send the same events (for example a port that just forwards received events to another port). By convention a symmetric event is declared on a single line. At run-time we often talk about a message rather than an event. A message is an instance of an event, similar to how a capsule instance is an instance of a capsule. In other words, a message is a run-time concept while an event is a design-time concept.","title":"Protocol and Event"},{"location":"art-lang/#port","text":"A port defines a named point of communication for a capsule. A port is typed by a protocol which defines the events that may be sent in to (in-events) and out from (out-events) the port. A port may be conjugated in order to swap the meaning of in-events and out-events. That is, a capsule may send out-events on its non-conjugated ports, but in-events for its conjugated ports. A port becomes conjugated if you add a tilde (~) after its name. Ports are often named to describe the role or purpose of the communication that takes place on them. Note that when a capsule wants to send an event to another capsule it's the port name that is referenced, rather than the name of the receiver capsule (which the sender capsule shouldn't need to know about). By convention names of ports start with lowercase and use camelCase if the name consists of multiple words. Here is an example of a capsule with a few ports. Note that RTist in Code provides several predefined protocols that can be used right away, for example Timing . Also note that you can declare multiple ports on a single line if the ports are of the same kind ( p1 and p2 below are both service ports). capsule Machine { service port control : MachineEvents; behavior port timer : Timing; // predefined Timing protocol service behavior port control2 : CtrlEvents; service port p1~ : MoreEvents, p2~ : OtherEvents; // ... }; Service ports constitute the externally visible communication interface for a capsule, and together they define which events can be sent to the capsule, and which events the capsule can send out for other capsules to receive. In a structure diagram the service ports are shown on the border of a capsule or part symbol. A behavior port is logically connected to the behavior (i.e. state machine ) of a capsule. This means that an event that a capsule receives on a behavior port will be handled by the state machine of that capsule. A non-behavior port, however, will simply route an event to another port to which it is connected. Every sent event will ultimately reach a behavior port (provided ports are properly connected), and the state machine of the capsule owning that behavior port will handle the event. In a structure diagram, behavior ports are connected to a small ellipse which represents the capsule state machine. Note that ports can also be shown in a class diagram.","title":"Port"},{"location":"art-lang/#port-multiplicity","text":"At run-time an instance of a port can be connected to a port instance on another capsule. Such connections is what make a sent event be routed from the port on which it is sent, through a number of non-behavior ports, until it finally reaches a behavior port. By default a port has single multiplicity (1) meaning that at most one such connection can be established. However, you can specify a non-single multiplicity for a port to allow for more connections to be created at run-time. In the example below a Server capsule has a port with multiplicity 100. At run-time an instance of that Server capsule can be connected to 100 different client ports, each of which can send events to the server. capsule Server { service port clients : ComEvents[100]; // ... }; In a structure diagrams a port is shown as \"stacked\" if it has non-single multiplicity. You can also use a C++ expression to specify the port multiplicity. This can for example be useful if the multiplicity is defined in C++ as a macro, a template parameter or a constexpr. For example: capsule Server { service port clients : ComEvents[`NBR_CLIENTS`]; // ... };","title":"Port Multiplicity"},{"location":"art-lang/#notification-port","text":"Every protocol contains two implicit events rtBound and rtUnbound. A port can choose to receive those events whenever a connection for the port is established (rtBound) or dropped (rtUnbound) at run-time. Declare a port as a notification port to receive these events. capsule Server { service notify port clients : ComEvents[100]; // ... }; Port notifications are useful in dynamic systems when capsules need to wait until other capsules are ready, before they can start to communicate with those capsules. For example, a client may need to wait until a server is ready before it sends a request to that server. In the same way it's often useful to get notified when a connection is dropped, since that means communication on that port should no longer take place.","title":"Notification Port"},{"location":"art-lang/#unwired-port","text":"Ports are by default wired, meaning that they should be connected with connectors to specify statically how events will be routed. Having a static connector structure defined has the benefit that it becomes possible to look at a capsule's structure diagram to see how events received by the capsule will be routed at run-time. However, in some dynamic systems it's not possible to describe this statically. Ports may be connected and disconnected dynamically and the run-time connections between port instances may hence vary over time. If you need this flexibility you can declare ports as unwired. Here is an example of an application where a client capsule can connect to different kinds of server capsules. Sometimes it may be connected to server1 and sometimes to server2 . It is therefore not possible to describe the connections of Top statically using connectors, and we can instead declare the ports as unwired. capsule Top { part client : Client; part server1 : Server; part server2 : Server; // ... }; capsule Client { service behavior unwired port p : Protocol; // ... }; capsule Server { service behavior unwired port p~ : Protocol; // ... }; Note Only use unwired ports when required. It's strongly recommended to use wired ports whenever possible to enable the visualization of the connector structure in a structure diagram. When unwired ports are required you should write a comment that describes how they will be connected at run-time, since this often cannot easily be concluded by looking at the C++ code of the capsule. An unwired port is always a behavior port. In a structure diagram an unwired port is drawn with a hollow ellipse, while a wired behavior port is drawn with a filled ellipse. In the structure diagram below port q is wired while port p is unwired. An unwired port is either a service access point (SAP) or a service provision point (SPP) depending on the role it plays in a dynamic connection with another unwired port. The capsule that owns the SAP port uses it to subscribe to a service that is published by another capsule by means of an SPP port. The capsule with the SAP port is often called \"client\" or \"subscriber\" while the capsule with the SPP port is often called \"server\" or \"publisher\". Unwired ports get connected by means of registering them under a service name that should be unique in the application. Registration of unwired ports can either happen automatically when the container capsule instance is created, or programmatically at a later point in time. It's also possible to deregister unwired ports in order to disconnect them. You can specify how an unwired port should be registered by means of the following properties: registration specifies when an unwired port should be registered registration_name specifies the service name with which the port should be registered If you choose to register an unwired port programmatically (using the TargetRTS functions registerSPP and registerSAP ) you decide at registration time whether the port should be an SAP or SPP port. However, if you choose to instead let the port be registered automatically you need to declare the port as either a subscribe (SAP) or publish (SPP) port. Here is the same example again, but now with automatic registration of the unwired ports using the service name myService : capsule Client { subscribe behavior port sap [[rt::properties( registration_name = \"myService\") ]] : Protocol; // ... }; capsule Server { publish behavior port spp~ [[rt::properties( registration_name = \"myService\") ]] : Protocol; // ... }; Note that the keyword unwired is implicit when you declare a port as either a subscribe or publish port.","title":"Unwired Port"},{"location":"art-lang/#connector","text":"Connectors describe how events are routed within a capsule by connecting ports in its composite structure. They make it possible to see in a structure diagram which parts of a capsule that can communicate with each other. Each connector connects exactly two ports with each other. A connected port may either be a port of the capsule itself, or a port of a capsule that types one of its capsule parts. A few constraints decide if it's possible to connect two ports: 1) The ports must be wired. Unwired ports cannot be connected. 2) The ports must be typed by the same protocol. 3) The ports' conjugations must match. If the ports are at the same level in the capsule's structure (e.g. both ports belong to capsules typing capsule parts owned by the same capsule), then the connected ports must have the opposite conjugation. This is because events that are sent out from one of the ports must be able to be received by the other port. However, if the ports are at different levels in the capsule's structure (e.g. one of them belongs to a capsule typing a capsule part owned by the capsule and the other belongs to the capsule itself), then the ports must have the same conjugation. This is because in this case events are simply delegated from one capsule to another. The example below shows the structure diagram of a capsule Top where we can see two connectors. capsule Top { part ping : Pinger, pong : Ponger; connect ping.p1 with pong.p2; // ... }; capsule Internal { service behavior port i~ : PROTO; // ... }; capsule Pinger { service behavior port p1 : PROTO; // ... }; capsule Ponger { service behavior port p2~ : PROTO; part inner : Internal; connect p2 with inner.i; // ... }; The connector between p1 and p2 goes between two ports on the same level which is why these ports must have opposite conjugation. The connector between p2 and i goes between two ports at different levels which is why these ports must have the same conjugation. The non-behavior port p2 is a so called relay port (it just relays all events it receives to another port) and the connector between p2 and i is sometimes called a delegation connector to describe the fact that capsule Ponger uses it for delegating some of its responsiblities to the capsule Inner . Note that relay ports can be optimized away so they don't exist at run-time (i.e. at run-time port p1 can be directly connected to i ). A connector doesn't have a direction, so it doesn't matter in which order it connects the two ports. That is, connecting X with Y is equivalent to connecting Y with X.","title":"Connector"},{"location":"art-lang/#part","text":"A capsule can be decomposed by means of parts (also called \"capsule parts\" to emphasize that they are parts of a capsule). A part is a container that at run-time may hold one or many capsule instances. The part has a multiplicity that specifies the maximum number of capsule instances it can contain at run-time, and it has a type which is another capsule. All capsule instances must either be of that specific capsule type, or of a capsule type that inherits from it. It's common to name parts according to the capsule that types them. For example, a part typed by a capsule Controller may be called controller , ctrl or perhaps theController . By convention part names start with lowercase and use camelCase if the name consists of multiple words. There are three kinds of parts which determine how and when they will be populated with capsule instances. 1) Fixed part In a fixed part capsule instances are created automatically when the container capsule is created, and destroyed when the container is destroyed. Fixed parts by default have multiplicity 1. Such a part will always contain one and only one instance of the capsule that types the part. 2) Optional part In an optional part capsule instances don't have a strong lifetime relationship with the container capsule as is the case for fixed parts. The capsule instances can be created programmatically using the Frame service of the TargetRTS at some point after the container capsule has been created, and they can be destroyed before the container capsule is destroyed. However, at the latest they will be automatically destroyed when the container is destroyed. Optional parts by default have multiplicity 0..1. This means that it may either contain zero or one capsule instance at any point in time. The presence of zero in the multiplicity is what makes the part optional. 3) Plugin part A plugin part is similar to an optional part in that it is populated by capsule instances programmatically. However, the capsule instances are not created in the plugin part but instead imported into the plugin part from another part. Typically such a capsule instance is first created into an optional part, and then at some later point in time imported into a plugin part. Later it can be deported (i.e. removed) from the plugin part and perhaps imported into another plugin part. This makes it possible to create very dynamic composite structures where the same capsule instance can play different roles in different parts over time. Moving a capsule instance by deporting it from one plugin part and then importing it in another plugin part is more efficient than destroying the capsule instance in one optional part and then creating another capsule instance in another optional part. Plugin parts are typically used together with unwired ports . In general it's possible to import a capsule instance into more than one plugin part at the same time, but it can only be imported if its ports are not already bound in its current location. Plugin parts by default have multiplicity 0..1. In the example below the capsule C contains a few parts of different kinds and multiplicities. Note that you may declare multiple parts on the same line if they are of the same kind (both c and d below are optional parts). capsule C { part a : D; fixed part b : D[4]; optional part c : D, d : D[0..5]; plugin part e : D; part f : D[`COUNT`]; // ... }; Part a is fixed with multiplicity 1 since neither kind nor multiplicity is specified for it. Part b is also fixed (using the \"fixed\" keyword for more clarity) and with multiplicity 4. When an instance of capsule C is created 5 instances of capsule D will be automatically created. One of these instances will be inserted into part a and the others into part b . These instances will remain there until the C capsule instance is destroyed. Part c is optional with multiplicity 0..1. At run-time it can contain at most one instance of capsule D . Part d is also optional but can contain up to 5 instances of D as specified by its multiplicity 0..5. Part e is plugin with the default multiplicity 0..1. At run-time at most one instance of capsule D can be imported into it. That instance must already have been created in another part, for example part c . Part f uses a C++ expression for specifying the multiplicity. This can for example be useful if the multiplicity is defined in C++ as a macro, a template parameter or a constexpr. Parts can be shown in a structure diagram: Parts are shown as \"stacked\" if they have non-single multiplicity. Optional parts are shown with a \"diagonal\" background pattern, while plugin parts are shown with a \"double diagonal\" background pattern. Parts can also be shown in a class diagram: In the above diagram the filled diamonds show that there is a strong life-time relationship between a C instance and the instances of D that are located in the fixed and optional parts a , b , c and d , while this is not the case for the instance located in the plugin part d as shown by the hollow diamond.","title":"Part"},{"location":"art-lang/#part-with-capsule-factory","text":"If the capsule that types a part has a capsule constructor with custom constructor parameters, you can define a capsule factory for the part. Such a capsule factory consists of two code snippets that define how an instance of that capsule should be created and destroyed. rt::createFunction Defines how to create an instance of the capsule. For example, which constructor arguments to pass, which thread to use for running the created capsule instance, at which index to insert the capsule instance into the part (in case it has multiplicity > 1) etc. rt::destroyFunction Defines how to destroy an instance of the capsule. By default it's destroyed using the delete operator. Here is an example where a part defines a capsule factory that specifies a create function. The create function gets the mandatory constructor parameters rtg_rts and rtg_ref as arguments, as well as an index argument that specifies the index where the created capsule instance would be inserted by default. part engine : Engine [[rt::createFunction]] ` return new Engine(rtg_rts, rtg_ref, true /* custom constructor arg */); `; Note that you may want to create a capsule factory for a part also for other reasons than passing custom constructor parameters. For example, you may want to change the default thread ( RTController* ) that should execute the created capsule instance, or you may want to instantiate an inherited capsule rather than the capsule that types the part.","title":"Part with Capsule Factory"},{"location":"art-lang/#state-machine","text":"State machines are used for specifying the behavior of capsules . It is also possible to provide a state machine for a passive class; see Class with State Machine for more information about that. In this chapter we focus on state machines in capsules. A state machine consists of states and transitions. During its lifetime a capsule instance transitions between the various states of its state machine, as a consequence of receiving messages on its behavior ports. When transitioning between two states one or several code snippets may execute. Such code may for example send messages to other capsule instances, something that may cause transitions to execute in their state machines. A state machine may also have pseudo states , which just like states may be connected with transitions, but that unlike states are not places where the state machine should stay for some time. For example, most pseudo states like junctions and entry/exit points merely act as connection points that make it possible to execute more than one transition when transitioning between two states. The notable exception is the choice in which actually the state machine may get stuck for ever, but this is something that should not happen in a correctly designed state machine.","title":"State Machine"},{"location":"art-lang/#state","text":"The states of a state machine are the places where the state machine may stay for some time while waiting for another message to arrive. States should have names that describe what is happening while the state machine stays there, or what has happened for the state machine to arrive there. For example, \"WaitForInit\", \"Processing\" or \"Terminated\". By convention state names start with uppercase. You can declare multiple states on the same line using a comma-separated list of state names. It can be good to write a comment in front of the state name, if you want to elaborate more on its meaning that what is possible in the name itself. Here is an example of a state machine with some states: capsule TrafficLight { statemachine { state WaitUntilServerReady, CycleLight; state /* pedestrians are crossing the street */ PedestriansCrossing; initial -> WaitUntilServerReady; WaitUntilServerReady -> CycleLight; CycleLight -> PedestriansCrossing; }; }; A state comment is not visible in a state diagram, but show up in a tooltip when putting the cursor on a reference to the state. They can thereby make it easier to understand a state machine. States may be nested to create a hierarchical state machine .","title":"State"},{"location":"art-lang/#entry-and-exit-action","text":"A state may have an entry and/or exit action which is a code snippet that runs whenever the state is entered and/or exited. state Walk { entry ` server.walk().send(); `; exit ` server.stop().send(); `; };","title":"Entry and Exit Action"},{"location":"art-lang/#transition","text":"A transition connects a source state (or pseudo state) to a target state (or pseudo state). When a capsule instance handles a message that was received on one of its behavior ports, one or several transitions may execute. It's not required to give a name to a transition, but it's possible and often makes the state machine easier to understand. At least triggered transitions (i.e. transitions where the source is a state) should have a name. A transition name can be choosen to describe what needs to have happened for the transition to execute, for example \"requestReceived\", \"timeout\" etc. By convention transition names start with lowercase and use camelCase if the name consists of multiple words. A triggered transition has one or several triggers which define when the transition can be triggered. Each trigger specifies a port and an event. The trigger can only trigger its transition if the received message is an instance of the specified event, and was received on the specified port. In addition it's possible to provide guard conditions that must be fulfilled for the trigger to trigger its transition. Such a guard condition can be specified for the transition, but also for each individual trigger. Here is an example of a capsule state machine with two triggered transitions requestReceived and timeout . It also contains an initial transition that has no name. capsule MyCap { statemachine { state Waiting, Processing; initial -> Waiting; requestReceived: Waiting -> Processing on com1.request, com2.request when ` return canHandleNow(); ` ` log.log(\"Handling request\"); log.commit(); handle(msg); `; timeout: Waiting -> Waiting on timer.timeout[`return zCount < 10;`]; }; }; Note the following: Triggers are specified as PORT.EVENT after the keyword on . You may specify multiple triggers separated by comma ( , ). A guard condition for the transition is specified after the when keyword, while a guard condition for an individual trigger is specified in square brackets ( [] ) after the trigger. A guard condition is actually a C++ statement that returns the boolean guard condition. Note Guard conditions should execute fast and have no side-effects. They are called frequently to decide which transition to execute when a message has arrived.","title":"Transition"},{"location":"art-lang/#initial-transition","text":"Every state machine needs exactly one initial transition. When the state machine starts to run, the first thing that happens is that the initial transition executes and takes the state machine to its first state. Therefore, an initial transition is a non-triggered transition and also cannot have a guard condition. But it can of course have an effect code snippet. The source of the initial transition is the initial pseudo state which is declared using the initial keyword. Just like for any transition it's optional to give a name to the initial transition (in fact it's often left unnamed). For capsule instances that are programmatically created (i.e. located in optional capsule parts) you can provide initialization data at the time of creation. This is a data object that can be accessed in the effect code of the initial transition. Here is an example: initial -> WaitForServerInit ` RTpchar str = *((RTpchar*) rtdata); `; Note Any type of data object can be passed as initialization data which means that rtdata is an untyped pointer that has to be casted to the expected type. A more type-safe way of passing initialization data is to define a constructor for a capsule. A capsule constructor can take any number of arguments, while with rtdata only one data object can be passed (even if you of course can group several data objects into a struct or class to circumvent this limitation). With capsule constructors you can pass initialization data also for capsule instances that are located in fixed parts. By default rtdata cannot be modified (it has type const void* ). However, by setting the const_rtdata_param property to false on the initial transition, you can make it non-const. One reason for doing this could be that the initial transition effect code wants to pass some data back to the code that creates the capsule instance. However, you must be very careful if you do this since this will only work if the creating code runs in the same thread that runs the initial transition. A more legitimate reason could be that you want to move the initialization data into a capsule variable, so you can access it later. Moving data can be more efficient than copying it. [[rt::properties(const_rtdata_param=false)]] initial -> Waiting ` pC = std::move(*((MyClass*) rtdata)); `;","title":"Initial Transition"},{"location":"art-lang/#internal-transition","text":"An internal transition doesn't change the active state and therefore doesn't have a target state. An internal transition is always a triggered transition. You define an internal transition inside the state to which it belongs. Here is an example: state Done { unexpected: on myPort.* ` std::cout << \"Unexpected event received! << std::endl; `; }; Note the usage of an asterisk ( * ) to specify that any event received on myPort will trigger the internal transition when the state machine is in the Done state. Such \"receive-any\" events can of course be used for a trigger of any transition, but can in particular be useful for internal transitions that should handle all messages received on a port that are not handled by other triggered transitions leaving substates of the state. If another event is added to the port's protocol in the future, such a trigger will handle the new event too without a need for being updated. Internal transitions are examples of so called self-transitions. To learn about other types of self-transitions see this chapter .","title":"Internal Transition"},{"location":"art-lang/#frequent-transition","text":"Sometimes you may have a state where one or a few outgoing transitions can be expected to execute much more frequently than others. You can then set a frequent property on the transition trigger that you expect will trigger the transition frequently. The Art compiler uses this information to optimize generated C++ code so that such transition triggers are evaluated before other triggers that are expected to trigger the transition less frequently. interrupted: Working -> Stopped on [[rt::properties( frequent=true )]] external.interrupt ` // Interrupted while working... `; Note The frequent property relies on optimization features in the C++ compiler that may or may not be available depending on which target compiler that is used. Only use frequent transitions if profiling has shown that you have a need to do this optimization.","title":"Frequent Transition"},{"location":"art-lang/#choice-and-junction","text":"Choices and junctions are pseudo states that make it possible to split transition flows in a state machine. That is, one incoming transition may be split into multiple outgoing transitions. Which of the outgoing transitions that will execute is decided by evaluating their guard conditions. For a junction the guard conditions are evaluated already before leaving the currently active state. Only if there exists a path of transitions where all guards are fulfilled, will the active state be exited and the transitions can execute. Otherwise the state machine stays in its current state and attempts to find another path of transitions to execute. For a choice the guard conditions are evaluated after leaving the current state, when reaching the choice itself. The outgoing transition which has a fulfilled guard will execute next. Note It's important that there always is an outgoing transition for a choice with a fulfilled guard condition. Otherwise the state machine will get stuck in the choice without any chance of getting out of it. Choices and junctions must have names, so they can be referenced as the source or target of transitions. You can choose to use a name that gives a hint about what conditions that are checked in the guards of the outgoing transitions. For example, isEnabled for a choice that checks a boolean condition and checkValue when the condition has some other type. If you follow this approach you can then name the outgoing transitions accordingly. For example true and false for a choice that checks a boolean condition. By convention choice and junction names start with lowercase and use camelCase if consisting of multiple words. Sometimes it may be difficult to come up with a good name and in that case you can choose something short and \"technical\" like j1 , check1 etc. Below is an example of a state machine containing a choice and a junction. statemachine { state First, Second, Third; t1: initial -> First; choice isEnabled; junction checkThreshold; switchTurned: First -> isEnabled; true: isEnabled -> Second when ` return isEnabled(); `; false: isEnabled -> Second when ` else `; timeout: First -> checkThreshold; low: checkThreshold -> Third when ` return t < LIMIT1; `; medium: checkThreshold -> Third when ` return t >= LIMIT1 && t < LIMIT2; `; high: checkThreshold -> Third; }; Note the use of the keyword else for defining an else-guard. An else-guard will be fulfilled when no other guard of other outgoing transitions is fulfilled. For choices it's good practise to always have exactly one transition with an else-guard to ensure that at least one guard condition will be fulfilled. Thereby we avoid the risk of the state machine getting stuck in the choice. Else-guards can also be useful for junction transitions, but there they are more optional. You can also define an else-transition for a choice or junction by simply omitting the guard condition. This is consistent with triggered transitions where the absense of a guard condition is equivalent to a guard condition that always is fulfilled. See the transition high in the above example. Guard conditions should be mutually exclusive so that the order in which they are evaluated doesn't matter. Junctions can also be used for merging multiple incoming transition flows into a single outgoing transition. This can for example be useful if you want to reuse a transition path in the state machine for several triggered transitions. statemachine { state S1, S2; junction j1; initial -> S1; t1: S1 -> j1 on port1.e1 ` // handle e1 `; t2: S1 -> j1 on port2.e2 ` // handle e2 `; t3: S1 -> j1 on port3.e3 ` // handle e3 `; common: j1 -> S2 ` // common code here `; }; Of course, in the above simple example the same code reuse could also be obtained by putting the common code in a capsule member function which is called by each of the incoming transitions. But if the common transition is followed by more non-triggered transitions the above approach is more feasible.","title":"Choice and Junction"},{"location":"art-lang/#hierarchical-state-machine","text":"A state machine is hierarchical if it contains at least one composite state, i.e. a state with a nested state machine. A transition that is triggered in the enclosing state machine (i.e. the state machine that contains the composite state) should enter a composite state by specifying an entry point of the composite state as the target. In the nested state machine another transition can connect that entry point to a state in the nested state machine. A transition in the nested state machine may specify an exit point of the composite state as the target. In the enclosing state machine another transition can connect that exit point to a state in the enclosing state machine. Entry and exit points are pseudo states that need to be named. The names can be chosen to give a hint about when the composite state is entered or exited through them, for example systemStarted or errorDetected . If you want you can prefix the names with ep or ex . It's also common to use short and \"technical\" names like ep1 or ex1 if a more descriptive name doesn't make sense. By convention entry and exit point names start with lowercase and use camelCase if consisting of multiple words. It's also possible to directly enter a composite state without using an entry point. In this case the behavior will depend on whether the composite state is entered for the first time or not. If it is for the first time, the initial transition of the nested state machine will execute after the transition that targets the composite state has executed. Otherwise the composite state will instead be entered using deep history , i.e. by activating the state in the nested state machine that was most recently active (and recursively if that state again is a composite state). Note It's recommended to always enter a composite state using an entry point as the behavior then doesn't depend on if the state was previously entered or not. Below is an example of an hierarchical state machine with a composite state CompositeState that contains a nested state machine. Note that you can declare multiple entry or exit points on the same line. statemachine { initial -> CompositeState.ep1; state CompositeState { state Nested; entrypoint ep1, ep2; exitpoint ex1; initial -> Nested; ep1 -> Nested; Nested -> ex1; ep2 -> history*; }; state Other; CompositeState.ex1 -> Other; Other -> CompositeState.ep2; }; Note that a dot ( . ) is used as scope resolution operator, to make it possible to reference an entry or exit point from the enclosing state machine. Inside the nested state machine the entry and exit points are directly accessible without use of the scope resolution operator (using it there would be an error). It is possible to only connect an entry point on the \"outside\". Entering such an entry point will behave in the same way as entering the composite state without using an entry point (see above). It's therefore not recommended. In the same way it's possible to exit a composite state using an exit point that only is connected on the \"inside\". In this case the composite state is not exited and instead the previously active substate again becomes active (recursively, just like for deep history ). This is also not recommended, unless the transition is a local transition .","title":"Hierarchical State Machine"},{"location":"art-lang/#deep-history","text":"Every nested state machine has an implicit pseudo state with the name history* (in state diagrams it's shown as H* to save space). It can be used as a target for any transition inside the nested state machine. When it is reached, the state machine will restore the previously active substate. If that state again is a composite state, its previously active substate will also be restored. This goes on recursively for all nested state machines (which is why it's called a deep history). In the example above we can see that the transition from ep2 targets the deep history pseudo state. This means that if the Nested substate is active and then the transition to ex1 gets triggered, the state Other becomes active. If then the transition to ep2 gets triggered the CompositeState will be entered using deep history so that the Nested substate will again become active.","title":"Deep History"},{"location":"art-lang/#local-transition","text":"A transition in a nested state machine where the source is an entry point and the target is an exit point, and these entry/exit points only are connected on the \"inside\", is a local transition . A local transition is a self-transition that behaves something in between an internal transition and a regular (a.k.a. external) self-transition. An internal transition defined on a composite state handles a message without exiting neither that composite state, nor any of its substates. However, a local transition will exit the composite state and then enter it again, but it will not do this for the substate that is active in the composite state. Hence, if a composite state has an exit action it will be called for the composite state, but not for the active substate. An external self-transition on the other hand will exit both the composite state and all active substates recursively, and then enter these states again. Exiting happens bottom-up which means that the deepest nested substate will first be exited, then its parent state, and so on until the top composite state is exited. Entering happens in the opposite order, i.e. in a top-down fashion. Let's look at an example to understand the difference between these three kinds of self-transitions: statemachine { initial -> SelfTransitionExample; state SelfTransitionExample { state Nested1 { state Nested2; }; internal: on port1.e1 ` // Internal transition `; entrypoint e1; exitpoint e2; local: e1 -> e2 ` // Local transition `; }; external: SelfTransitionExample -> SelfTransitionExample on port2.e2 ` // External transition `; }; Assume the currently active state configuration is { SelfTransitionExample , Nested1 , Nested2 } when one of the self-transitions get triggered: Internal transition ( internal ) No state is exited and the active state configuration remains unchanged. Local transition ( local ) 1) Nested2 is exited. 2) Nested1 is exited. 3) local executes. 4) Nested1 is entered. 5) Nested2 is entered. External transition ( external ) 1) Nested2 is exited. 2) Nested1 is exited. 3) SelfTransitionExample is exited. 4) external executes. 5) SelfTransitionExample is entered. 6) Nested1 is entered. 7) Nested2 is entered.","title":"Local Transition"},{"location":"art-lang/#class-with-state-machine","text":"Art allows you to create passive classes with state machines. This can be an alternative to using a capsule in case you only need a passive stateful data object, and don't need the ability to send events to it, or to let it execute in its own context. A class with a state machine is more lightweight than a capsule at runtime. Transitions in a class state machine are triggered by calling trigger operations on the class. A trigger operation is similar to a regular member function in C++, but does not have a code behavior of its own. Instead, when you call a trigger operation on an object of a class with a state machine it may trigger a transition in the class' state machine. That transition may have an effect code snippet that will execute. A trigger operation can have parameters which allows you to pass data when calling them. Those parameters can be accessed in the transition that is triggered by it. Below is an example of a class with a state machine with two trigger operations initialize and finalize . Note that you can define multiple trigger operations on the same line. class DataObject { /* Trigger Operations */ trigger initialize(`int` data), finalize(); /* State Machine */ statemachine { state Initial, Initialized, Finalized; initial -> Initial; init: Initial -> Initialized on initialize(`int`) ` // Initialized int i = data; `; Initialized -> Finalized on finalize() ` // Finalized `; }; }; Just like for C++ member functions, trigger operations support overloading. That is, you can have many trigger operations with the same name as long as their full signatures are unique. The signature of a trigger operation consists of its name and the types of all its parameters. When you reference a trigger operation with parameters as a transition trigger, you need to include the types of the parameters (see the trigger for the init transition above). The same transition can be triggered by multiple trigger operations (just like a transition in a capsule state machine can be triggered by multiple events). However, in that case those trigger operations should agree on the names and types of their parameters so that the transition effect code can access them in a way that works regardless of which of the trigger operations that will trigger the transition. Names of classes with state machines by convention start with uppercase, while names of trigger operations and their parameters by convention start with lowercase and use camelCase if the name consists of multiple words. A common design pattern is to let a class-with-statemachine instance be managed by a single capsule instance. This means that the capsule instance is responsible both for creating, using and finally destroying the class-with-statemachine instance. If you follow this pattern it is thread-safe to for example call public member functions defined on the capsule from a transition in the class state machine. This can for example be used as a means for the class state machine to send events through the ports of the capsule (i.e. it can call a capsule member function that sends the event). However, to avoid exposing the full capsule functionality to the class state machine it's recommended to define an interface (i.e. abstract C++ class) which the capsule can implement. This interface can contain only those member functions which the class needs to access from its state machine. A class state machine can use the same constructs as a capsule state machine with a few exceptions: The initial transition cannot access initialization data as can a capsule's initial transition . Instead you can define one or several constructors for the class with parameters needed for passing initialization data when the class-with-statemachine instance is created. See Constructor for more information. Frequent transitions are not supported. The state machine can be hierarchical but the deep history pseudo state is not supported. Instead the shallow history pseudo state can be used. Even if it's possible for a class with a state machine to inherit from another class with a state machine, this doesn't mean that the state machines will be inherited as is the case for capsule inheritance. Read more about this in Inheritance . A class with state machine can have the same code snippets as a capsule.","title":"Class with State Machine"},{"location":"art-lang/#constructor","text":"By default the initial transition of a class state machine executes at the time of constructing the class-with-statemachine instance. This happens because the generated default constructor will call an operation rtg_init1() which contains the code from the initial transition. If you want to wait with \"starting\" the state machine until a later point in time you need to define your own parameterless constructor which doesn't call this function. You can define any constructors you need on a class with a state machine. They are regular C++ constructors and allow to pass initialization data when creating a class-with-statemachine instance. Remember to call the rtg_init1() function in all such constructors, if you want the state machine to start at the time of creating the class-with-statemachine instance. Here is an example of a class with a state machine that has a user-defined constructor: class PC { [[rt::decl]] ` private: double m_data; public: PC(double data); ` [[rt::impl]] ` PC::PC(double data) : m_data(data) { rtg_init1(); } ` statemachine { state First; initial -> First ` // State machine started `; }; };","title":"Constructor"},{"location":"art-lang/#shallow-history","text":"Every nested state machine has an implicit pseudo state with the name history (in state diagrams it's shown as H to save space). It can be used as a target for any transition inside the nested state machine. When it is reached, the state machine will restore the previously active substate. However, if that state again is a composite state it's previously active substate will not be restored. This is in contrast to the deep history for capsule state machines, and is why for a class state machine this pseudo state is referred to as a shallow history. Here is an example: class MyClass { statemachine { state First { entrypoint ep1; ep1 -> history; }; initial -> First.ep1; }; };","title":"Shallow History"},{"location":"art-lang/#inheritance","text":"By using inheritance you can reuse and customize generic ( base ) Art elements into more specific ( derived ) Art elements. An Art element can inherit either from one or several other Art elements, and/or it can inherit from one or several C++ classes. The derived Art element can redefine elements of the base element. The redefining element (located in the derived element) can change one or several properties of the redefined element (located in the base element). This is very similar to how inheritance works in C++, with the difference that in C++ a redefining element has more restrictions on what properties that can be changed in the redefined element. For example, a redefining member function (known as an overridden member function in C++ terminology) must keep the same signature as the redefined member function (known as a virtual base member function in C++ terminology), and can only (in fact, must) change its implementation. In some cases Art inheritance not only allows to redefine inherited elements, but also to completely exclude them. An excluded element is not present in the derived element, so exclusion can be seen as a special form of redefinition where the whole element is removed in the derived element. In C++ it's not possible to exclude any inherited members.","title":"Inheritance"},{"location":"art-lang/#capsule-inheritance","text":"A capsule can inherit from another capsule. Only one base capsule is allowed; multiple inheritance is not supported for capsules. In addition a capsule can inherit from any number of C++ classes (or structs). The derived capsule is type compatible with the base capsule in the sense that if you have a capsule part typed by the base capsule, you can at runtime incarnate it with instances of the derived capsule. Capsule inheritance has multiple dimensions. One dimension is the usual C++ inheritance between classes (remember that a capsule is an active class). In this dimension it is for example possible to redefine (a.k.a override) a virtual member function defined in the base capsule or in another base C++ class. But there is also a second dimension where the state machine of the derived capsule will implicitly inherit from the state machine of the base capsule. This makes it possible to redefine transitions and states. For example, a redefining transition in a derived capsule can change the effect code, the guard condition or the target state or pseudo state. And a redefining state in a derived capsule can change the entry or exit action, as well as any substate or subtransition in case the state is composite and has a nested state machine. It's also possible to completely exclude a state or a transition, either in the top capsule state machine, or in a nested state machine. Below is an example of a capsule D that inherits from another capsule B . In addition the capsule D inherits from two C++ classes IDataManager and IController . capsule B { statemachine { state BS, BS2; Initial: initial -> BS; }; }; capsule D : B, `IDataManager`, `IController` { [[rt::decl]] ` // IDataManager impl public: void manageData() override; // IController impl public: void control() override; ` [[rt::impl]] ` // impl of manageData() and control() ` statemachine { state DS; state exclude BS2; redefine Initial: initial -> DS; }; }; In the example we can see that D overrides functions from the base C++ classes that are assumed to be virtual (or pure virtual). For brevity the implementations of these functions have been omitted but would be placed in the rt::impl code snippet. We can also see an example of a state machine redefinition. The initial transition Initial of B 's state machine is redefined in D 's state machine so that it targets state DS instead of state BS . In the state diagram of D the state BS and the initial pseudo state are drawn with gray color and dashed outline, to show that they are inherited. The transition Initial is also drawn in grayed with dashed outline but with a blue label to show that it's redefining the inherited initial transition. The state BS2 is excluded in D 's state machine. In state diagrams excluded elements are by default shown with a \"crossed\" background, but by setting a diagram preference it's also possible to completely hide them from the diagram. Note that to be able to redefine the initial transition of B it is necessary to give it a name (so that it can be referenced as redefined from D ). This is yet another reason why it's good practise to give names to transitions, even if it's not mandated. But, of course, if you want to prevent anyone from creating a derived capsule with a state machine that redefines a certain transition, you can accomplish that by not giving a name to that transition. In effect, an unnamed transition is final , i.e. cannot be overridden or excluded. The rule that a capsule state machine must have exactly one initial transition also applies to a derived capsule. Therefore, when you introduce inheritance between two existing capsules, you typically first get an error saying that the derived capsule has two initial transitions (one inherited, and one locally defined). You then need to decide if you want to either remove the initial transition in the derived capsule, or (like in the above example) instead redefine the initial transition. Capsule inheritance also has a third dimension, which relates to its structure. Parts and ports defined in the base capsule are inherited by the derived capsule. Just like for states and transitions, it's possible to redefine or exclude a part or a port. A redefining port can change the type (i.e. protocol ), multiplicity and the notification property of the redefined port. A redefining part can change the type, multiplicity and kind (fixed, optional or plugin) of the redefined part. Below is an example of a capsule DPPI that inherits from another capsule BPPI . The port port1 and the part part1 is redefined, while the port port2 and part part2 are excluded. capsule BPPI { service port port1 : PR1; port port2 : PR1; part part1 : Cap1; part part2 : Cap1; statemachine { state State; initial -> State; }; }; capsule DPPI : BPPI { service notify port redefine port1 : PR2[10]; optional part redefine part1 : Cap2[0..20]; part exclude part2; port exclude port2; statemachine { state State2; }; };","title":"Capsule Inheritance"},{"location":"art-lang/#class-inheritance","text":"A class with state machine can inherit from other classes with state machines, or from C++ classes (or structs). Multiple inheritance is supported. Contrary to capsule inheritance , class inheritance does not imply inheritance between the state machines in the derived and base classes. This means it's not possible to redefine or exclude states and transitions in an inherited class state machine. Nor is it possible to redefine trigger operations. In fact, the derived class will have two state machines (its own, plus the one inherited from the base class) and these two state machines will execute independently of each other. That is, class inheritance is more a way of aggregating state machines rather than reusing and redefining them. Because of this, it's rather unusual to let two classes with state machines inherit each other. It's more useful to let a class with state machine inherit from other C++ classes. Below is an example of a class with state machine that inherits from two C++ classes DataContainer<CData> and IDisposable . class DataClass : `DataContainer<CData>`, `IDisposable` { [[rt::decl]] ` void dispose() override; // From IDisposable ` [[rt::impl]] ` void DataClass:dispose() { // impl } ` statemachine { state State; initial -> State; }; };","title":"Class Inheritance"},{"location":"art-lang/#protocol-inheritance","text":"A protocol may inherit events from another protocol. Only one base protocol is allowed; multiple inheritance is not supported for protocols. Inherited events can be redefined, but not excluded. A redefining event in a derived protocol can change the type of the event parameter as defined in the base protocol. In the example below, the protocol ExtendedMachineEvents adds one more in-event stop to the inherited MachineEvents protocol. It also redefines the startDeferred event to change its parameter type. protocol MachineEvents { in start(); in startDeferred(`unsigned long` /* milliseconds */); out success(); out error(`std::string` /* error message */); }; protocol ExtendedMachineEvents : MachineEvents { in stop(); in redefine startDeferred(`unsigned long long`); };","title":"Protocol Inheritance"},{"location":"art-lang/#template","text":"A template is a type that is parameterized by means of template parameters to make it more generic. When a template is used (a.k.a. instantiated), actual template parameters must be provided that match the formal template parameters defined in the template. Both capsules and classes can have template parameters. Just like in C++ two kinds of template parameters are supported: Type template parameter Replaced with a type when the template is instantiated. Non-type template parameters Replaced with a non-type, for example a constant value, when the template is instantiated. Template parameters may have defaults that will be used if a matching actual template parameter is not provided when instantiating the template. Below is an example of a capsule and a class with template parameters, some of which have defaults specified. The keywords typename and class can both be used for defining a type template parameter. A non-type template parameter is defined by specifying its type as a C++ code snippet. template <typename T = `int`, `int` p1 = `5`> capsule TemplateCapsule { [[rt::decl]] ` void func(T arg1) { // impl } ` service port mp : MachineEvents[`p1`]; statemachine { state State; initial -> State; }; }; template <typename T, class U, `int` p1> class TemplateClass : `Base<T,U,p1>` { statemachine { state State; initial -> State; }; }; Template parameters can only be used from C++ code snippets, and above you see some examples of how they can be used. It's not possible to instantiate a template in Art itself. For example, even if class Base above was defined as an Art class, a C++ code snippet has to be used since it has template parameters.","title":"Template"},{"location":"art-lang/#property","text":"Properties are name-value pairs that provide a generic mechanism for augmenting Art elements with extra data. Such data can be utilized by tools that operate on a parsed Art file, such as the code generator and semantic checker. Most Art elements can have properties and the syntax for specifying properties is the same regardless of the kind of element. However, different kinds of Art elements can have different properties. For Art elements that have a name, properties are specified right after the name. For elements without name, properties are specified before the element itself. In both cases the syntax looks like this: [[rt::properties( <property name>=<property value>, <property name>=<property value>, ... <property name>=<property value> )]] All properties have a default value, so you only need to specify a property if you want to set it to something else. The default values have been chosen so that you in most cases don't need to specify any properties at all. A property has a type, and its value must conform to that type. The following property types are supported: Boolean Boolean properties have a value that is either true or false . If you want to set a boolean property to true you can use a shorthand syntax where you just specify the property name. For example: capsule CapProp [[rt::properties( generate_file_impl=false, generate_file_header )]] { // ... }; Writing generate_file_header is equivalent to writing generate_file_header=true . However, this particular property has the default value true and hence doesn't need to be set at all. Integer Integer properties have a numeric value (>= 0). Here is an example: protocol XProtocol [[rt::properties( version=1 )]]{ // ... }; String String properties have a string value, enclosed in double quotes. Here is an example: class MC [[rt::properties( rule_config=\"E0022\" )]]{ // ... }; Enumeration A property of enumeration type has a value that references a literal of the enumeration. There are different enumerations used for different properties. The best way to learn about what enumeration literals that are available for a certain property is to use the Content Assist feature in the Art file editor. Place the cursor after the equal sign, and press Ctrl + Space . Here is an example of defining a property of enumeration type: class MC [[rt::properties( kind=struct )]]{ // ... }; Note that in some cases the name of an enumeration literal starts with underscore ( _ ) to prevent it from clashing with the set of Art keywords . Below is a table that lists all properties that can be used on different kinds of Art elements. Each property is described in a section of its own below the table. Art Elements Property Type Default Capsule , Class generate_file_header Boolean true Capsule , Class generate_file_impl Boolean true Capsule , Class , Protocol , Port , Initial transition , Triggered transition Trigger rule_config String \"\" Class , Protocol version Integer 0 Class generate_descriptor Enumeration (true, false, manual) true Class kind Enumeration (_class, struct, union) _class Class generate_class Boolean true Class generate_statemachine Boolean true Class const_target_param_for_decode Boolean false Class default_constructor_generate Boolean true Class default_constructor_explicit Boolean false Class default_constructor_inline Boolean false Class default_constructor_default Boolean false Class default_constructor_delete Boolean false Class default_constructor_visibility Enumeration (public, protected, private) public Port registration Enumeration (automatic, automatic_locked, application) automatic Port registration_name String \"\" Initial transition , Triggered transition const_rtdata_param Boolean true Transition , State , Choice , Junction , Entry Point , Exit Point color String \"\" Trigger frequent Boolean false","title":"Property"},{"location":"art-lang/#generate_file_header","text":"By default a capsule or class is translated to one header file ( .h ) and one implementation file ( .cpp ). Set this property to false to prevent generation of the header file, for example if you prefer to write it manually.","title":"generate_file_header"},{"location":"art-lang/#generate_file_impl","text":"By default a capsule or class is translated to one header file ( .h ) and one implementation file ( .cpp ). Set this property to false to prevent generation of the implementation file, for example if you prefer to write it manually.","title":"generate_file_impl"},{"location":"art-lang/#rule_config","text":"This property is used for configuring validation rules for an Art element. Read more about this here .","title":"rule_config"},{"location":"art-lang/#version","text":"TODO","title":"version"},{"location":"art-lang/#generate_descriptor","text":"By default a type descriptor will be generated for each class . The TargetRTS uses the type descriptor to know how to initialize, copy, move, destroy, encode or decode an instance of that class. Set this property to false for classes that don't need a type descriptor. Set it to manual if the class needs a type descriptor but you want to implement it manually rather than using the implementation that is generated by default. Note that even if you set this property to true so that a default type descriptor is generated, you can still override individual type descriptor functions for the class.","title":"generate_descriptor"},{"location":"art-lang/#kind","text":"By default a class is translated to a C++ class. You can use this property to instead translate it to a struct or union .","title":"kind"},{"location":"art-lang/#generate_class","text":"If set to false no C++ code will be generated for the class.","title":"generate_class"},{"location":"art-lang/#generate_statemachine","text":"If set to false code generation for the class' state machine will be suppressed. You can use this if the state machine is informal, and you prefer to implement it manually in another way.","title":"generate_statemachine"},{"location":"art-lang/#const_target_param_for_decode","text":"By default a decode function uses a non-const target parameter. This is because usually a decode implementation must call non-const functions on the decoded object to populate it with data from the decoding. However, if it doesn't need to call such functions you can set this property so that the target parameter is declared as const.","title":"const_target_param_for_decode"},{"location":"art-lang/#default_constructor_generate","text":"If set to false a default (i.e. parameterless) constructor will not be generated for the class.","title":"default_constructor_generate"},{"location":"art-lang/#default_constructor_explicit","text":"If set to true the default (i.e. parameterless) constructor will be declared as explicit.","title":"default_constructor_explicit"},{"location":"art-lang/#default_constructor_inline","text":"If set to true the default (i.e. parameterless) constructor will be declared as inline. It's implementation will then be generated into the header file.","title":"default_constructor_inline"},{"location":"art-lang/#default_constructor_default","text":"If set to true the default (i.e. parameterless) constructor will be declared as defaulted. This tells the compiler to synthesize a default constructor even if one normally would not be synthesized (for example because there is a user-defined constructor with parameters).","title":"default_constructor_default"},{"location":"art-lang/#default_constructor_delete","text":"If set to true the default (i.e. parameterless) constructor will be declared as deleted? This will cause the compiler to generate an error if it is invoked. This can be used for preventing objects of the class to be created.","title":"default_constructor_delete"},{"location":"art-lang/#default_constructor_visibility","text":"This property can be used for setting the visibility of the default (i.e. parameterless) constructor. By default it will be public but you can change it either to protected or private .","title":"default_constructor_visibility"},{"location":"art-lang/#registration","text":"This property specifies how to register an unwired port at runtime. The default is automatic which means the port will be registered automatically when the container capsule instance is initialized. The value automatic_locked has the same meaning but the registration will be \"locked\" so that any future attempt to deregister it, or register it under a different name, will fail. Set the property to application to programmatically register the port using the functions registerSPP() and registerSAP() respectively.","title":"registration"},{"location":"art-lang/#registration_name","text":"This property specifies the name to use when registering a port at runtime. By default the port name is used, but it can be overridden using this property.","title":"registration_name"},{"location":"art-lang/#const_rtdata_param","text":"If set to false the rtdata parameter in the transition function will be non-const. It can therefore be modified, which for example can avoid copying received message data and instead move it using its move constructor or move assignment operator.","title":"const_rtdata_param"},{"location":"art-lang/#color","text":"Specifies which color to use for an Art element in a diagram. Colors should be specified as RGB values using 6 hexadecimal digits. For example, \"#ff00ff\". The Art text editor will help you set an appropriate color by means of a color picker. Note that you can also set the color directly from the diagram. Select a symbol or line and then set the color property using the Properties view (under \"Appearance\").","title":"color"},{"location":"art-lang/#frequent","text":"Triggers for which this property is true will lead to generated code that handles these triggers faster than other triggers. This is done by placing their if-statements early in the rtsBehavior function to ensure that as little code as possible needs to execute when dispatching a message for a frequent trigger.","title":"frequent"},{"location":"installing/","text":"Installing RTist in Code can be installed on top of Visual Studio Code or Eclipse Theia. The latest version of RTist in Code is available on the Visual Studio Marketplace and on the Open VSX Registry . To install that version into Visual Studio Code or Eclipse Theia follow these steps: 1) Click \"Extensions\" in the activity bar to open the Extensions view. 2) Type \"rtist\" in the search field. 3) Click the \"Install\" button to install the RTist in Code extension Once the installation is finished you will see RTist in Code appear in the \"Installed\" section of the Extensions view: The screenshot above also shows that an extension for working with C/C++ has been installed. See Setup C++ Build Tools for more information. Install from VSIX Another way to install RTist in Code is to use a .vsix file. This can be useful if you want to install another version than the latest. You can download .vsix files for all released versions of RTist in Code from both the Visual Studio Marketplace and the Open VSX Registry . Once you have downloaded the .vsix file follow these steps to install it: 1) If you already have a version of RTist in Code installed, you can manually uninstall it first (see Uninstalling ). Note that this step is usually not required since the newly installed version of the extension will automatically replace the old one. 2) Open the menu of the Extensions view and select the command \"Install from VSIX\". 3) In the file dialog that appears, select the .vsix file to install. If the installation completes successfully you should see the following message (the \"Reload Now\" button will only show if you already had another version of RTist in Code installed): If instead the installation fails, this message will tell you the reason. One common reason for failure is that your version of Visual Studio Code or Eclipse Theia is not compatible (i.e. too old) for RTist in Code. If you are unsure about which version of RTist in Code you have installed, you can see the version in the extension's tooltip, and the full build version is available in the page that appears if you double-click the extension: It should also be noted that it's possible to directly install any published version of RTist in Code by using the \"Install Another Version\" command that is available in the context menu of an extension shown in the \"Installed\" section. Portable Mode Installation You can install multiple versions of RTist in Code by using the portable mode of Visual Studio Code. See Portable Mode for how to install Visual Studio code in portable mode, which will allow you to install a version of RTist in Code that won't affect other Visual Studio Code installations on the machine. Portable mode also allows to move or copy an installation from one machine to another, which makes it useful in scenarios where installs should be centralized in an organization. Post-Installation Configuration After a successful installation you need to perform a few configuration steps before you can start to use RTist in Code. Setup Java RTist in Code uses a Java language server and hence needs a Java Virtual Machine (JVM). More specifically it requires a Java 11 JVM. If an appropriate JVM cannot be found when the RTist in Code extension is activated (which for example happens the first time you open an Art file), you will receive an error message. RTist in Code follows the steps below in priority order when it looks for an appropriate JVM to use: 1) The configuration setting rtistic.languageServer.jvm is examined. If it specifies a path to a JVM it will be used. You can edit this configuration setting by invoking File - Preferences - Settings and then type the configuration setting id mentioned above in the filter box. This setting needs to be edited in the settings.json file. 2) The environment variable JAVA_HOME is examined. If it specifies a path to a JVM it will be used. 3) An attempt is made to launch the java command without using a path. The first JVM found in the system path, if any, will be used. You may also need to adjust the arguments for the JVM. By default the JVM is launched with the below arguments: -Xverify:none -Xmx4024m To change the JVM arguments set the configuration setting rtistic.languageServer.jvmArgs . Setup License If you want to use all features of RTist in Code you need a license. The RTist in Code Community Edition doesn't require a license, but can on the other hand not be used for commercial purposes. Setup C++ Build Tools When RTist in Code builds generated C++ code it uses C++ build tools such as a make tool, a C++ compiler, a C++ linker etc. These tools need to be in the path when you start Visual Studio Code or Eclipse Theia. If you have multiple C++ build tools installed, make sure the correct ones are present in the path before launching Visual Studio Code or Eclipse Theia. For example, if you use the Microsoft C++ compiler, it's recommended to launch from a Visual Studio native tools command prompt with the correct version (e.g. 32 bit or 64 bit). Build errors caused by inconsistent versions of C++ build tools being used can be tricky to find. You also need to install an extension for C/C++ development into Visual Studio Code or Eclipse Theia. C/C++ for Visual Studio Code is recommended. Uninstalling To uninstall RTist in Code follow these steps: 1) Click \"Extensions\" in the left side-bar. 2) Find the RTist in Code extension in the \"Installed\" section, right-click on it, and select the command \"Uninstall\". Once the uninstallation is finished you will no longer see RTist in Code in the \"Installed\" section.","title":"Installing"},{"location":"installing/#installing","text":"RTist in Code can be installed on top of Visual Studio Code or Eclipse Theia. The latest version of RTist in Code is available on the Visual Studio Marketplace and on the Open VSX Registry . To install that version into Visual Studio Code or Eclipse Theia follow these steps: 1) Click \"Extensions\" in the activity bar to open the Extensions view. 2) Type \"rtist\" in the search field. 3) Click the \"Install\" button to install the RTist in Code extension Once the installation is finished you will see RTist in Code appear in the \"Installed\" section of the Extensions view: The screenshot above also shows that an extension for working with C/C++ has been installed. See Setup C++ Build Tools for more information.","title":"Installing"},{"location":"installing/#install-from-vsix","text":"Another way to install RTist in Code is to use a .vsix file. This can be useful if you want to install another version than the latest. You can download .vsix files for all released versions of RTist in Code from both the Visual Studio Marketplace and the Open VSX Registry . Once you have downloaded the .vsix file follow these steps to install it: 1) If you already have a version of RTist in Code installed, you can manually uninstall it first (see Uninstalling ). Note that this step is usually not required since the newly installed version of the extension will automatically replace the old one. 2) Open the menu of the Extensions view and select the command \"Install from VSIX\". 3) In the file dialog that appears, select the .vsix file to install. If the installation completes successfully you should see the following message (the \"Reload Now\" button will only show if you already had another version of RTist in Code installed): If instead the installation fails, this message will tell you the reason. One common reason for failure is that your version of Visual Studio Code or Eclipse Theia is not compatible (i.e. too old) for RTist in Code. If you are unsure about which version of RTist in Code you have installed, you can see the version in the extension's tooltip, and the full build version is available in the page that appears if you double-click the extension: It should also be noted that it's possible to directly install any published version of RTist in Code by using the \"Install Another Version\" command that is available in the context menu of an extension shown in the \"Installed\" section.","title":"Install from VSIX"},{"location":"installing/#portable-mode-installation","text":"You can install multiple versions of RTist in Code by using the portable mode of Visual Studio Code. See Portable Mode for how to install Visual Studio code in portable mode, which will allow you to install a version of RTist in Code that won't affect other Visual Studio Code installations on the machine. Portable mode also allows to move or copy an installation from one machine to another, which makes it useful in scenarios where installs should be centralized in an organization.","title":"Portable Mode Installation"},{"location":"installing/#post-installation-configuration","text":"After a successful installation you need to perform a few configuration steps before you can start to use RTist in Code.","title":"Post-Installation Configuration"},{"location":"installing/#setup-java","text":"RTist in Code uses a Java language server and hence needs a Java Virtual Machine (JVM). More specifically it requires a Java 11 JVM. If an appropriate JVM cannot be found when the RTist in Code extension is activated (which for example happens the first time you open an Art file), you will receive an error message. RTist in Code follows the steps below in priority order when it looks for an appropriate JVM to use: 1) The configuration setting rtistic.languageServer.jvm is examined. If it specifies a path to a JVM it will be used. You can edit this configuration setting by invoking File - Preferences - Settings and then type the configuration setting id mentioned above in the filter box. This setting needs to be edited in the settings.json file. 2) The environment variable JAVA_HOME is examined. If it specifies a path to a JVM it will be used. 3) An attempt is made to launch the java command without using a path. The first JVM found in the system path, if any, will be used. You may also need to adjust the arguments for the JVM. By default the JVM is launched with the below arguments: -Xverify:none -Xmx4024m To change the JVM arguments set the configuration setting rtistic.languageServer.jvmArgs .","title":"Setup Java"},{"location":"installing/#setup-license","text":"If you want to use all features of RTist in Code you need a license. The RTist in Code Community Edition doesn't require a license, but can on the other hand not be used for commercial purposes.","title":"Setup License"},{"location":"installing/#setup-c-build-tools","text":"When RTist in Code builds generated C++ code it uses C++ build tools such as a make tool, a C++ compiler, a C++ linker etc. These tools need to be in the path when you start Visual Studio Code or Eclipse Theia. If you have multiple C++ build tools installed, make sure the correct ones are present in the path before launching Visual Studio Code or Eclipse Theia. For example, if you use the Microsoft C++ compiler, it's recommended to launch from a Visual Studio native tools command prompt with the correct version (e.g. 32 bit or 64 bit). Build errors caused by inconsistent versions of C++ build tools being used can be tricky to find. You also need to install an extension for C/C++ development into Visual Studio Code or Eclipse Theia. C/C++ for Visual Studio Code is recommended.","title":"Setup C++ Build Tools"},{"location":"installing/#uninstalling","text":"To uninstall RTist in Code follow these steps: 1) Click \"Extensions\" in the left side-bar. 2) Find the RTist in Code extension in the \"Installed\" section, right-click on it, and select the command \"Uninstall\". Once the uninstallation is finished you will no longer see RTist in Code in the \"Installed\" section.","title":"Uninstalling"},{"location":"notices/","text":"Notices Licensed Materials - Property of HCL Limited. \u00a9 Copyright HCL Technologies Limited This information was developed for products and services offered in the US. HCL may not offer the products, services, or features discussed in this document in other countries. Consult your local HCL representative for information on the products and services currently available in your area. Any reference to an HCL product, program, or service is not intended to state or imply that only that HCL product, program, or service may be used. Any functionally equivalent product, program, or service that does not infringe any HCL intellectual property right may be used instead. However, it is the user's responsibility to evaluate and verify the operation of any non-HCL product, program, or service. HCL may have patents or pending patent applications covering subject matter described in this document. The furnishing of this document does not grant you any license to these patents. You can send license inquiries, in writing, to: HCL 330 Potrero Ave. Sunnyvale, CA 94085 USA Attention: Office of the General Counsel For license inquiries regarding double-byte character set (DBCS) information, contact the HCL Intellectual Property Department in your country or send inquiries, in writing, to: HCL 330 Potrero Ave. Sunnyvale, CA 94085 USA Attention: Office of the General Counsel HCL TECHNOLOGIES LTD. PROVIDES THIS PUBLICATION \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Some jurisdictions do not allow disclaimer of express or implied warranties in certain transactions, therefore, this statement may not apply to you. This information could include technical inaccuracies or typographical errors. Changes are periodically made to the information herein; these changes will be incorporated in new editions of the publication. HCL may make improvements and/or changes in the product(s) and/or the program(s) described in this publication at any time without notice. Any references in this information to non-HCL websites are provided for convenience only and do not in any manner serve as an endorsement of those websites. The materials at those websites are not part of the materials for this HCL product and use of those websites is at your own risk. HCL may use or distribute any of the information you provide in any way it believes appropriate without incurring any obligation to you. Licensees of this program who wish to have information about it for the purpose of enabling: (i) the exchange of information between independently created programs and other programs (including this one) and (ii) the mutual use of the information which has been exchanged, should contact: HCL 330 Potrero Ave. Sunnyvale, CA 94085 USA Attention: Office of the General Counsel Such information may be available, subject to appropriate terms and conditions, including in some cases, payment of a fee. The licensed program described in this document and all licensed material available for it are provided by HCL under terms of the HCL Customer Agreement, HCL International Program License Agreement or any equivalent agreement between us. The performance data discussed herein is presented as derived under specific operating conditions. Actual results may vary. Information concerning non-HCL products was obtained from the suppliers of those products, their published announcements or other publicly available sources. HCL has not tested those products and cannot confirm the accuracy of performance, compatibility or any other claims related to non-HCL products. Questions on the capabilities of non-HCL products should be addressed to the suppliers of those products. Statements regarding HCL's future direction or intent are subject to change or withdrawal without notice, and represent goals and objectives only. This information contains examples of data and reports used in daily business operations. To illustrate them as completely as possible, the examples include the names of individuals, companies, brands, and products. All of these names are fictitious and any similarity to actual people or business enterprises is entirely coincidental. COPYRIGHT LICENSE: This information contains sample application programs in source language, which illustrate programming techniques on various operating platforms. You may copy, modify, and distribute these sample programs in any form without payment to HCL, for the purposes of developing, using, marketing or distributing application programs conforming to the application programming interface for the operating platform for which the sample programs are written. These examples have not been thoroughly tested under all conditions. HCL, therefore, cannot guarantee or imply reliability, serviceability, or function of these programs. The sample programs are provided \"AS IS,\" without warranty of any kind. HCL shall not be liable for any damages arising out of your use of the sample programs. Each copy or any portion of these sample programs or any derivative work must include a copyright notice as follows: \u00a9 (your company name) (year). Portions of this code are derived from HCL Technologies Limited. Sample Programs. \u00a9 HCL Technologies Limited . Trademarks HCL Technologies Ltd. and HCL Technologies Ltd. logo, and hcl.com are trademarks or registered trademarks of HCL Technologies Ltd., registered in many jurisdictions worldwide. Other product and service names might be trademarks of HCL or other companies. Terms and conditions for product documentation Permissions for the use of these publications are granted subject to the following terms and conditions. Applicability These terms and conditions are in addition to any terms of use for the HCL website. Personal use You may reproduce these publications for your personal, noncommercial use provided that all proprietary notices are preserved. You may not distribute, display or make derivative work of these publications, or any portion thereof, without the express consent of HCL. Commercial use You may reproduce, distribute and display these publications solely within your enterprise provided that all proprietary notices are preserved. You may not make derivative works of these publications, or reproduce, distribute or display these publications or any portion thereof outside your enterprise, without the express consent of HCL. Rights Except as expressly granted in this permission, no other permissions, licenses or rights are granted, either express or implied, to the publications or any information, data, software or other intellectual property contained therein. HCL reserves the right to withdraw the permissions granted herein whenever, in its discretion, the use of the publications is detrimental to its interest or, as determined by HCL, the above instructions are not being properly followed. You may not download, export or re-export this information except in full compliance with all applicable laws and regulations, including all United States export laws and regulations. HCL MAKES NO GUARANTEE ABOUT THE CONTENT OF THESE PUBLICATIONS. THE PUBLICATIONS ARE PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.","title":"Notices"},{"location":"notices/#notices","text":"Licensed Materials - Property of HCL Limited. \u00a9 Copyright HCL Technologies Limited This information was developed for products and services offered in the US. HCL may not offer the products, services, or features discussed in this document in other countries. Consult your local HCL representative for information on the products and services currently available in your area. Any reference to an HCL product, program, or service is not intended to state or imply that only that HCL product, program, or service may be used. Any functionally equivalent product, program, or service that does not infringe any HCL intellectual property right may be used instead. However, it is the user's responsibility to evaluate and verify the operation of any non-HCL product, program, or service. HCL may have patents or pending patent applications covering subject matter described in this document. The furnishing of this document does not grant you any license to these patents. You can send license inquiries, in writing, to: HCL 330 Potrero Ave. Sunnyvale, CA 94085 USA Attention: Office of the General Counsel For license inquiries regarding double-byte character set (DBCS) information, contact the HCL Intellectual Property Department in your country or send inquiries, in writing, to: HCL 330 Potrero Ave. Sunnyvale, CA 94085 USA Attention: Office of the General Counsel HCL TECHNOLOGIES LTD. PROVIDES THIS PUBLICATION \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Some jurisdictions do not allow disclaimer of express or implied warranties in certain transactions, therefore, this statement may not apply to you. This information could include technical inaccuracies or typographical errors. Changes are periodically made to the information herein; these changes will be incorporated in new editions of the publication. HCL may make improvements and/or changes in the product(s) and/or the program(s) described in this publication at any time without notice. Any references in this information to non-HCL websites are provided for convenience only and do not in any manner serve as an endorsement of those websites. The materials at those websites are not part of the materials for this HCL product and use of those websites is at your own risk. HCL may use or distribute any of the information you provide in any way it believes appropriate without incurring any obligation to you. Licensees of this program who wish to have information about it for the purpose of enabling: (i) the exchange of information between independently created programs and other programs (including this one) and (ii) the mutual use of the information which has been exchanged, should contact: HCL 330 Potrero Ave. Sunnyvale, CA 94085 USA Attention: Office of the General Counsel Such information may be available, subject to appropriate terms and conditions, including in some cases, payment of a fee. The licensed program described in this document and all licensed material available for it are provided by HCL under terms of the HCL Customer Agreement, HCL International Program License Agreement or any equivalent agreement between us. The performance data discussed herein is presented as derived under specific operating conditions. Actual results may vary. Information concerning non-HCL products was obtained from the suppliers of those products, their published announcements or other publicly available sources. HCL has not tested those products and cannot confirm the accuracy of performance, compatibility or any other claims related to non-HCL products. Questions on the capabilities of non-HCL products should be addressed to the suppliers of those products. Statements regarding HCL's future direction or intent are subject to change or withdrawal without notice, and represent goals and objectives only. This information contains examples of data and reports used in daily business operations. To illustrate them as completely as possible, the examples include the names of individuals, companies, brands, and products. All of these names are fictitious and any similarity to actual people or business enterprises is entirely coincidental. COPYRIGHT LICENSE: This information contains sample application programs in source language, which illustrate programming techniques on various operating platforms. You may copy, modify, and distribute these sample programs in any form without payment to HCL, for the purposes of developing, using, marketing or distributing application programs conforming to the application programming interface for the operating platform for which the sample programs are written. These examples have not been thoroughly tested under all conditions. HCL, therefore, cannot guarantee or imply reliability, serviceability, or function of these programs. The sample programs are provided \"AS IS,\" without warranty of any kind. HCL shall not be liable for any damages arising out of your use of the sample programs. Each copy or any portion of these sample programs or any derivative work must include a copyright notice as follows: \u00a9 (your company name) (year). Portions of this code are derived from HCL Technologies Limited. Sample Programs. \u00a9 HCL Technologies Limited .","title":"Notices"},{"location":"notices/#trademarks","text":"HCL Technologies Ltd. and HCL Technologies Ltd. logo, and hcl.com are trademarks or registered trademarks of HCL Technologies Ltd., registered in many jurisdictions worldwide. Other product and service names might be trademarks of HCL or other companies.","title":"Trademarks"},{"location":"notices/#terms-and-conditions-for-product-documentation","text":"Permissions for the use of these publications are granted subject to the following terms and conditions.","title":"Terms and conditions for product documentation"},{"location":"notices/#applicability","text":"These terms and conditions are in addition to any terms of use for the HCL website.","title":"Applicability"},{"location":"notices/#personal-use","text":"You may reproduce these publications for your personal, noncommercial use provided that all proprietary notices are preserved. You may not distribute, display or make derivative work of these publications, or any portion thereof, without the express consent of HCL.","title":"Personal use"},{"location":"notices/#commercial-use","text":"You may reproduce, distribute and display these publications solely within your enterprise provided that all proprietary notices are preserved. You may not make derivative works of these publications, or reproduce, distribute or display these publications or any portion thereof outside your enterprise, without the express consent of HCL.","title":"Commercial use"},{"location":"notices/#rights","text":"Except as expressly granted in this permission, no other permissions, licenses or rights are granted, either express or implied, to the publications or any information, data, software or other intellectual property contained therein. HCL reserves the right to withdraw the permissions granted herein whenever, in its discretion, the use of the publications is detrimental to its interest or, as determined by HCL, the above instructions are not being properly followed. You may not download, export or re-export this information except in full compliance with all applicable laws and regulations, including all United States export laws and regulations. HCL MAKES NO GUARANTEE ABOUT THE CONTENT OF THESE PUBLICATIONS. THE PUBLICATIONS ARE PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.","title":"Rights"},{"location":"overview/","text":"RTist in Code lets you create stateful, event-driven realtime applications in C++. It runs as an extension of Visual Studio Code or Eclipse Theia. Follow the installation instructions for installing it. RTist in Code supports the Art language which is an extension of the C++ language. It provides high-level concepts useful when designing stateful, event-driven realtime applications, such as capsules, state machines and protocols. It is a textual language, but also provides a graphical notation that includes class, state and structure diagrams. RTist in Code translates Art files into efficient C++ code which can be compiled on any target system. The generated code makes use of the Target RunTime System which is a C++ library that implements the concepts of the Art language. Art History The Art language as implemented in RTist in Code builds on a foundation with a long history in industry. In the early 1990s the Canadian company ObjecTime Limited developed a language called ROOM to address the challenges of building realtime applications consisting of communicating state machines. ROOM introduced concepts such as capsules, protocols and ports and was first implemented in the tool ObjecTime Developer. This tool got adopted in a wide range of industrial domains for example telecom and embedded systems development. In 2000 ObjectTime was acquired by Rational Software and ObjecTime Developer was merged with Rational Rose, a UML modeling tool. The result was Rational Rose RealTime (Rose RT). At the same time many of the ROOM language concepts made its way into the, by then, new modeling language called UML-RealTime. In 2003 Rational Software was acquired by IBM which at the time was investing heavily in the Eclipse platform. As a result work started to create an Eclipse-based tool as the successor of Rose RT. This new product got the name Rational Software Architect RealTime Edition ( RSARTE ) and was first released in 2007. In 2016 HCL entered a partnership with IBM, which led to a rebranded version of RSARTE called HCL RTist . Work on RTist in Code began in 2020 with the aim of supporting other IDEs than Eclipse. As part of this effort a textual language syntax, Art, was developed. Hence it's fair to describe the Art language as a new syntax for concepts that have a rather old history and have already been used in the industry for more than 30 years. It should also be mentioned that the Target RunTime System used in RTist in Code is the same as is used in HCL RTist and IBM RSARTE. In fact, the implementation of this C++ library started with ObjectTime Developer and has since then been gradually extended and modernized.","title":"Overview"},{"location":"overview/#art-history","text":"The Art language as implemented in RTist in Code builds on a foundation with a long history in industry. In the early 1990s the Canadian company ObjecTime Limited developed a language called ROOM to address the challenges of building realtime applications consisting of communicating state machines. ROOM introduced concepts such as capsules, protocols and ports and was first implemented in the tool ObjecTime Developer. This tool got adopted in a wide range of industrial domains for example telecom and embedded systems development. In 2000 ObjectTime was acquired by Rational Software and ObjecTime Developer was merged with Rational Rose, a UML modeling tool. The result was Rational Rose RealTime (Rose RT). At the same time many of the ROOM language concepts made its way into the, by then, new modeling language called UML-RealTime. In 2003 Rational Software was acquired by IBM which at the time was investing heavily in the Eclipse platform. As a result work started to create an Eclipse-based tool as the successor of Rose RT. This new product got the name Rational Software Architect RealTime Edition ( RSARTE ) and was first released in 2007. In 2016 HCL entered a partnership with IBM, which led to a rebranded version of RSARTE called HCL RTist . Work on RTist in Code began in 2020 with the aim of supporting other IDEs than Eclipse. As part of this effort a textual language syntax, Art, was developed. Hence it's fair to describe the Art language as a new syntax for concepts that have a rather old history and have already been used in the industry for more than 30 years. It should also be mentioned that the Target RunTime System used in RTist in Code is the same as is used in HCL RTist and IBM RSARTE. In fact, the implementation of this C++ library started with ObjectTime Developer and has since then been gradually extended and modernized.","title":"Art History"},{"location":"support/","text":"If you find a bug in RTist in Code please report it with a GitHub Issue . Please include steps to reproduce and any additional files that can help in troubleshooting. For example, it can be good to include all log files. You can find the location of these logs by invoking the command Developer: Open Logs Folder . You can zip the entire logs folder and attach it to the issue. You can also check these logs using the Output view. In particular, the following two output logs are relevant: Art Server Contains messages printed by the Art language server. These are internal errors and other diagnostic messages that you normally would not need to pay attention to, but which can sometimes be useful when troubleshooting a problem. Art Build Contains messages printed when building a TC. It can sometimes contain diagnostic messages from the Art compiler.","title":"Support Procedures"},{"location":"validation/","text":"RTist in Code checks for semantic problems in your application. It does this by running a large number of validation rules each time an Art file has been changed. The rules run automatically as soon as you have made a change to an Art file (even before saving it). This ensures that errors and warnings (i.e. potential problems) are found as early as possible. Problem Severity Each validation rule has a default severity which will be used for the problems that are reported by the rule: Error An error is a problem that is severe enough to prevent building a correct application. Errors must be fixed, and it will not be possible to build the Art files into a C++ application until all errors have been resolved. Warning A warning is a potential problem, which you may or may not choose to fix. It can for example indicate a deviation from common conventions and best practises and it can indicate that the application will not behave as you may expect. Information An information is just a message that you should be aware of. It doesn't really indicate a problem, and you don't need to fix it. You can customize the default severity of any validation rule, and you can also choose to completely disable a certain validation rule that you don't think provides any value. See Configuring Validation for more information. Problem Reporting When a validation rule has found a problem in an Art file, it is marked by underlining one or several Art elements in the file. The underlining is red for errors, yellow for warnings and blue for information messages. For example, in the capsule shown below one warning and two errors have been found. You can hover the cursor over these underlinings to get a tooltip with information about the problem. Every problem has a message that describes it. Often this message gives enough information for understanding how to fix the problem. If this is not the case you can go to the documentation about the validation rule to find more information, examples and suggestions for how the problem can be fixed. To easily find the documentation click the hyperlink that consists of the unique id of the validation rule (it starts with the prefix \"ART_\" followed by a 4 digit number and a name). Alternatively you can search for the validation rule id on this page. Often a problem may be associated with more than one Art element. There is a main element on which the problem will be shown, but there often also are other elements that are related to the problem in one way or another. You can navigate to related elements to get a better understanding of why a problem is reported and how to fix it. In the screenshot above the problem has a single related element (the capsule tlSystem ) but in general a problem can have an arbitrary number of related elements. Problems are also reported by means of icons in diagrams. Below are three states with problems of different severity: A problem icon has a tooltip that shows the message of the problem. You can disable problem reporting in diagrams by means of a configuration setting rtistic.diagram.showDiagnostics . Problems View Too see all problems found in all Art files in the workspace, open the Problems view. The total number of problems found are shown in the Problems view heading. By default problems are shown in a tree grouped by the Art files where they were found. However, you can also view them as a flat table instead (but note that related elements can only be seen when using the tree view). If there are many problems, it can help to filter the Problems View by typing some text in the filter box. For example, you can filter using a regular expression that matches only some of the files in the workspace, to reduce the number of problems shown. Quick Fix Some problems have one or several typical solutions that are possible to apply automatically by means of \"code actions\". If a problem has at least one such code action defined, a yellow light bulb icon will appear and a Quick Fix command will be available in the problem tooltip. Note that most semantic errors cannot be automatically resolved like this, but in some simple cases it's possible. Configuring Validation Validation can be configured to change which rules that should run, and what severity they should report found problems with. By default every validation rule is enabled and uses a predefined severity level. Validation rules can be configured either globally by means of a setting, or locally by means of a property rule_config . In both cases the rule configuration consists of a comma-separated list of 5 letter strings where the first letter specifies if the rule is disabled and it's severity (X,I,W,E) and remaining letters specify the rule id. For example, the rule configuration X0003,I0004,W0009,E0005 means the following: The rule ART_0003_nameShouldStartWithUpperCase is disabled The rule ART_0004_nameShouldStartWithLowerCase has its severity set to Information The rule ART_0009_invalidProperty has its severity set to Warning The rule ART_0005_choiceWithoutElseTransition has its severity set to Error To configure validation rules globally, use the configuration setting rtistic.validation.ruleConfiguration . A global configuration will apply for all Art files in the workspace, and all Art elements within those files, unless a local rule configuration has been set on an element. To configure validation rules locally, set the property rule_config on an Art element. It will affect the validation of that Art element itself, as well as all elements contained within that Art element. Here is an example of how to disable the validation rule ART_0003_nameShouldStartWithUpperCase on a capsule. Note that it also will disable this rule for elements contained within the capsule, such as states. capsule customCapsule // no warning even if capsule name is not capitalized [[rt::properties( rule_config=\"X0003\" )]]{ statemachine { state customState; // no warning here too initial -> customState; }; }; Validation Rules This chapter lists all validation rules which RTist in Code checks your Art application against. ART_0001_invalidNameCpp Severity Reason Quick Fix Error An Art element has a name that is not a valid C++ name. N/A Art elements are translated to C++ elements without changing the elements' names. Hence you need to choose names for Art elements that are valid in C++. For example, C++ keywords cannot be used. If you ignore this error you can expect errors when compiling the generated C++ code. protocol InvalidNameProtocol { in virtual(); // ART_0001 (\"virtual\" is a C++ keyword) }; ART_0002_duplicateNamesInScope Severity Reason Quick Fix Error Two or more Art elements in the same scope have the same names or signatures. N/A Names of Art elements must be unique within the same scope. The following is checked: Top-level elements within an Art file. Note that even top-level elements in different Art files should have unique names since the corresponding C++ elements all will be within the global namespace, but this is currently not checked (but will be detected by the C++ linker). Events of a protocol. Note that in-events and out-events are checked separately, since an in-event and an out-event will have the same name when you define a symmetric event (see Protocol and Event ). Parts of a capsule. Ports of a capsule. States and pseudo states (collectively referred to as \"vertices\") of a state machine. Transitions of a state machine. Trigger operations of a class . Note that several trigger operations may have the same name as long as their signatures are unique. All elements with clashing names or signatures will be reported as related elements. Use this to find the element(s) that need to be renamed. protocol DupProto { in inEvent1(); // ART_0002 in inEvent1(); // ART_0002 out inEvent1(); // OK (symmetric event) }; class DNIS { trigger op1(`int` p); trigger op1(); // OK (signatures are unique) statemachine { state State; initial -> State; }; }; ART_0003_nameShouldStartWithUpperCase Severity Reason Quick Fix Warning An Art element's name doesn't follow the naming convention to start with uppercase. Capitalize Name Just like in most languages Art has certain conventions on how elements should be named. The following elements should have names that start with an uppercase letter: Capsule Class Protocol State A Quick Fix is available that will fix the problem by capitalizing the name. Note, however, that it will only update the element's name, and not all references. If you have references to the element you may instead want to fix the problem by performing a Rename. capsule myCapsule { // ART_0003 statemachine { state sstate; // ART_0003 initial -> sstate; }; }; In this context an underscore ( _ ) is considered a valid upper case character, so all names that start with underscore are accepted by this validation rule. ART_0004_nameShouldStartWithLowerCase Severity Reason Quick Fix Warning An Art element's name doesn't follow the naming convention to start with lowercase. Decapitalize Name Just like in most languages Art has certain conventions on how elements should be named. The following elements should have names that start with a lowercase letter: Event Port Part Trigger operation Choice and junction points Entry and exit points Transition A Quick Fix is available that will fix the problem by decapitalizing the name. Note, however, that it will only update the element's name, and not all references. If you have references to the element you may instead want to fix the problem by performing a Rename. protocol LowerCaseTestProtocol { out MyEvent(); // ART_0004 }; In this context an underscore ( _ ) is considered a valid lower case character, so all names that start with underscore are accepted by this validation rule. ART_0005_choiceWithoutElseTransition Severity Reason Quick Fix Warning A choice lacks an outgoing else-transition. N/A If no outgoing transition of a choice is enabled at runtime (because no outgoing transition has a guard condition that is fulfilled) then the state machine will get stuck in the choice for ever. To avoid this you should ensure that at least one outgoing transition is enabled. A good way to do this is to use 'else' as the guard condition for one of the outgoing transitions. Such an else-transition will then execute if no other outgoing transition of the choice is enabled. capsule ChoiceSample { statemachine { state State; initial -> State; choice x; // ART_0005 State -> x; x -> State when `return getVal() == 5;`; }; }; Note that a transition without any guard condition is equivalent to a transition with a guard condition that is always fulfilled (i.e. a guard condition that returns true). An outgoing transition from a choice or junction without any guard is therefore also an else-transition. ART_0006_choiceWithoutOutgoingTransitions Severity Reason Quick Fix Error A choice has no outgoing transitions. N/A A choice should typically have at least two outgoing transitions to be meaningful. Having only one outgoing transition is possible if it is an else-transition (i.e. a transition with an 'else' guard, or without any guard at all). However, a choice without any outgoing transition is not allowed since the state machine always will get stuck when reaching such a choice. capsule ChoiceSample { statemachine { state State; initial -> State; choice x; // ART_0006 State -> x; }; }; ART_0007_choiceWithTooManyElseTransitions Severity Reason Quick Fix Error A choice has more than one outgoing else-transition. N/A It's good practise to have an outgoing else-transition (i.e. a transition with an 'else' guard, or without any guard at all) for a choice since it will prevent the state machine from getting stuck in the choice at runtime. However, there should not be more than one such else-transition defined, since otherwise it's ambiguous which one of them to trigger in the case none of the other outgoing transitions from the choice are enabled. capsule ChoiceSample { statemachine { state State, State2; initial -> State; choice x; // ART_0007 State -> x; x -> State; x -> State2 when `else`; }; }; ART_0008_initialTransitionCount Severity Reason Quick Fix Error A state machine has too many initial transitions, or no initial transition at all. N/A A state machine of a capsule or class must have exactly one initial transition. A common reason for this error is that you have introduced inheritance between two capsules which both have state machines with an initial transition. Because of that the derived capsule will have two initial transitions (the one it defines itself locally plus the one it inherits from the base capsule). In this case the error can be fixed by either deleting or excluding the initial transition from the derived capsule, or to let it redefine the initial transition from the base capsule. capsule InitTransCap2 { statemachine { state State; initial -> State; }; }; capsule InitTransCap3 : InitTransCap2 { statemachine { state State; initial -> State; // ART_0008 }; }; Note that if the initial transition in the base capsule has no name, the derived capsule cannot exclude or redefine it. It's therefore good practise to name the initial transition if you expect your capsule to be inherited from. ART_0009_invalidProperty Severity Reason Quick Fix Error A non-existing property is set for an element. Remove Property Most Art elements have properties that can be set to change their default values. Different elements have different properties and if you get this error it means you have referenced a non-existing property for an Art element. A Quick Fix is available for removing the setting of the invalid property. Use Content Assist ( Ctrl + Space ) to get a list of valid properties for an Art element. protocol IP_PROTO [[rt::properties( no_property = 4 // ART_0009 (A protocol has no property called \"no_property\") )]] { }; ART_0010_invalidPropertyValue Severity Reason Quick Fix Error A property is set to a value of incorrect type. N/A Most Art elements have properties and every property has a type that is either boolean, integer, string or an enumeration. The type of the value assigned to a property must match the property's type. For example, you cannot assign an integer value to a boolean property. capsule IPV_Cap [[rt::properties( generate_file_header=4 // ART_0010 (\"generate_file_header\" is a boolean property) )]]{ statemachine { state State; initial -> State; }; }; ART_0011_propertySetToDefaultValue Severity Reason Quick Fix Warning A property is set to its default value. Remove Property Most Art elements have properties and every property has a default value. It's unnecessary to explicitly set a property to its default value. A Quick Fix is available for removing the setting of the property. class C_PropDefaultValue [[rt::properties( const_target_param_for_decode=false // ART_0011 )]] { statemachine { state State; initial -> State; }; }; ART_0012_invalidCodeSnippet Severity Reason Quick Fix Error A code snippet is invalid in one way or the other. Remove Code Snippet A code snippet 's kind is specified after the prefix rt:: . Different Art elements may have different kinds of code snippets. Also, some Art elements may have multiple code snippets of a certain kind, while others only may have one code snippet of each kind. A Quick Fix is available for removing the invalid code snippet. [[rt::header_preface]] // ART_0012 (code snippet for capsule/class placed at file level) ` // YourCodeHere ` capsule Name { [[rt::unknown]] // ART_0012 (non-existing kind of code snippet) ` // YourCodeHere ` part x : OtherCap [[rt::createFunction]] ` return new DemoCap(rtg_rts, rtg_ref); ` [[rt::createFunction]] // ART_0012 (duplicated code snippet) ` return new DemoCap(rtg_rts, rtg_ref); `; statemachine { state State; initial -> State; }; }; ART_0013_partMultiplicityError Severity Reason Quick Fix Error The part's lower multiplicity must be less than its upper multiplicity. N/A If a part has a multiplicity that specifies a range (i.e. both a lower and upper multiplicity), then the lower multiplicity must be less than the upper multiplicity. capsule PME_Cap { part myPart : OtherCap [2..2]; // ART_0013 statemachine { state State; initial -> State; }; }; ART_0014_partKindMultiplicityInconsistency Severity Reason Quick Fix Warning The part's kind is inconsistent with its multiplicity. N/A The multiplicity of a capsule part must match the part's kind. The following is checked: A fixed part must have a multiplicity greater than zero. This is because when the container capsule is incarnated at least one capsule instance must be incarnated into the fixed part. An optional part must have a lower multiplicity of zero. This means that when the container capsule is incarnated no capsule instances will be incarnated into the optional part. Hence, this is what makes the part optional. It's only possible to specify the part multiplicity using a C++ expression if the part is fixed. In case any of these inconsistencies is detected, the faulty multiplicity will be ignored and a default multiplicity (see Part ) will be used instead. capsule PKMI_Cap { fixed part myPart : OtherCap [0..2]; // ART_0014 (Fixed part should not have lower multiplicity 0) optional part myPart2 : OtherCap [1..5]; // ART_0014 (Optional part should not have lower multiplicity > 0) optional part myPart3 : OtherCap [`5`]; // ART_0014 (Only a fixed part may have its multiplicity specified with a code expression) statemachine { state State; initial -> State; }; }; ART_0015_internalTransitionOutsideState Severity Reason Quick Fix Error An internal transition is defined outside a state, in the top state machine. N/A An internal transition specifies events that can be handled while a state machine is in a certain state without leaving that state. Hence it's only possible to define an internal transition inside a state. It does not make sense to define an internal transition directly in the top state machine. capsule IntTransOutsideState { service port timer : Timing; statemachine { state State { t1 : on timer.timeout ` `; }; initial -> State; terror : on timer.timeout ` `; // ART_0015 }; }; ART_0016_circularInheritance Severity Reason Quick Fix Error A capsule, class or protocol inherits from itself directly or indirectly. N/A When you use inheritance for capsules, classes and protocols you need to ensure there are no inheritance cycles. Cyclic inheritance means that an element would inherit from itself, directly or indirectly, which is not allowed. Note Both capsules and classes, but not protocols, may have C++ base classes specified by means of C++ code snippets. Such inheritance relationships are not checked by this validation rule, but by the C++ compiler. The elements that form the inheritance cycle will be reported as related elements. Use this to decide how to break the inheritance cycle. protocol PR1 : PR2 { // ART_0016 }; protocol PR2 : PR1 { // ART_0016 }; class C1 { statemachine { state State; initial -> State; }; }; class C2 : C1 { statemachine { state State; initial -> State; }; }; class C3 : C2, C4 { // ART_0016 statemachine { state State; initial -> State; }; }; class C4 : C3 { // ART_0016 statemachine { state State; initial -> State; }; }; ART_0017_circularComposition Severity Reason Quick Fix Error A capsule contains itself through a cycle in the composition hierarchy. N/A Parts of a capsule must form a strict composition hierarchy. At run-time the root of this hierarchy is the top capsule instance, and all other capsule instances in the application must be directly or indirectly owned by that capsule instance. For a fixed part the creation of contained capsule instances happen automatically when the container capsule is incarnated. It's therefore possible to statically analyze the fixed parts and check for cycles in the composition hierarchy. Note Only the static type of fixed capsule parts are used when looking for composition cycles. If a part has a capsule factory that specifies a create function using C++ code, then a different dynamic type may be specified for the created capsule instances for that part. This opens up for more possibilities of introducing cycles in the composition hierarchy that will not be detected by this validation rule. The fixed parts that form the composition cycle will be reported as related elements. Use this to decide how to break the composition cycle. capsule CComp2 { fixed part p2 : CComp3; // ART_0017 statemachine { state State; initial -> State; }; }; capsule CComp3 part p3 : CComp2; // ART_0017 statemachine { state State; initial -> State; }; }; ART_0018_circularTransitions Severity Reason Quick Fix Error A state machine has a cycle in the transitions that execute when leaving a junction. N/A A junction can split an incoming transition flow into multiple outgoing transition flows based on evaluating guard conditions for the outgoing transitions. If care is not taken it's possible to introduce cycles in the outgoing transition flows. Such cycles could lead to infinite recursion when the state machine executes, depending on what guard conditions will be fulfilled at runtime. You should therefore ensure there are no such transition cycles. The transitions that form the cycle will be reported as related elements. Use this to decide how to break the transition cycle. capsule CT_cap { statemachine { // ART_0018 state S1; initial -> S1; junction j1, j2; t1: S1 -> j1; t2: j1 -> j2; t3: j2 -> j1; }; }; ART_0019_unwiredPortBothPublisherAndSubscriber Severity Reason Quick Fix Error An unwired port is declared as being both a subscriber and publisher at the same time. N/A An unwired port can at runtime be connected to another unwired port. One of the connected ports will be a publisher port (a.k.a SPP port) while the other will be a subscriber port (a.k.a SAP port). An unwired port can either be statically declared as being a publisher or subscriber port, or it can be dynamically decided at port registration time if the port should be a publisher or subscriber. The same port can not be both a subscriber and a publisher port at the same time. capsule UnwiredCapsule { subscribe publish port p1 : UnwiredProtocol; // ART_0019 statemachine { state State; initial -> State; }; }; ART_0020_wiredPortWithUnwiredProperties Severity Reason Quick Fix Warning A property that only is applicable for an unwired port is specified for a wired port. N/A An unwired port may have properties that control how it will be registered at runtime (see registration and registration_name ). These properties have no meaning and will be ignored for wired ports. capsule UnwiredCapsule2 { port p1 [[rt::properties( registration_name=\"hi\" )]]: UnwiredProtocol; // ART_0020 statemachine { state State; initial -> State; }; }; ART_0021_unwiredPortRegNameSameAsPortName Severity Reason Quick Fix Warning An unwired port is set to use a registration name that equals the name of the port. N/A When an unwired port is registered a name is used that by default is the name of the port. The property registration_name can be used for specifying another name. It's hence unnecessary to use that property for specifying the name of the port, since it is the default name that anyway would be used. capsule UnwiredCapsule3 { unwired behavior port p1~ [[rt::properties( registration_name = \"p1\" )]] : UnwiredProtocol; // ART_0021 statemachine { state State; initial -> State; }; }; ART_0022_ruleConfigProblem Severity Reason Quick Fix Warning The rule_config property has a malformed value. N/A The rule_config property can be set on Art elements to configure which validation rules to run for that element (and for all elements it contains). It can also be used for setting a custom severity for those rules. The value of the rule_config property should be a comma-separated list of 5 letter strings where the first letter specifies if the rule is disabled and it's severity (X,I,W,E) and remaining letters specify the rule id. See Configuring Validation for more information and examples. capsule RCP [[rt::properties( rule_config=\"X0000\" // ART_0022 (a validation rule with id 0000 does not exist) )]]{ statemachine { state State; initial -> State; }; }; ART_0023_entryExitCodeCount Severity Reason Quick Fix Error A state has too many entry and/or exit actions. N/A A state can at most have one entry and one exit action. Solve this problem by merging all entry and exit actions of the state to a single entry and exit action that performs everything that should be done when the state is entered and exited. capsule CX { statemachine { state Composite { entry // ART_0023 ` entry1(); `; entry // ART_0023 ` entry2(); `; }; initial -> Composite; }; }; ART_0024_unwiredPortNotBehavior Severity Reason Quick Fix Error An unwired port is not defined as a behavior port. Make Behavior Port, Make Wired Port An unwired port cannot be connected to another port by means of a connector . Hence, it's required that an unwired port is defined to be a behavior port. Otherwise it would not be possible for the owner capsule to send and receive events on an unwired port. Two Quick Fixes are available for fixing this problem. Either the port can be turned into a behavior port, or it can be turned into a wired port. capsule Pinger { service unwired port p1 : PROTO; // ART_0024 statemachine { state State1; initial -> State1; }; }; ART_0025_portOnPartConnectionError Severity Reason Quick Fix Error A wired port is not properly connected, or an unwired port is connected. N/A An unwired port must not be connected to another port by means of a connector . Instead you should register such a port dynamically so that it can be connected at runtime with another matching port. A wired port, however, must be connected. If the port is not a behavior port, it must be connected both on the \"inside\" and on the \"outside\" by two connectors. That is because the purpose of such a relay port is to simply relay communication from one port to another. By \"inside\" we mean the composite structure of the capsule that owns the port, and by \"outside\" we mean the composite structure to which the part that is typed by the capsule belongs. If the port is a behavior port, it should only be connected on the \"outside\". capsule Top { part ping : Pinger, // ART_0025 (not connected in capsule Top) pong : Ponger; // ART_0025 (not connected in capsule Top) statemachine { state t21; initial -> t21; }; }; capsule Inner { service behavior port p : PROTO; statemachine { state State; initial -> State; }; }; capsule Pinger { service port p1 : PROTO; part inner : Inner; connect p1 with inner.p; statemachine { state State1; initial -> State1; }; }; capsule Ponger { service behavior port p2~ : PROTO; statemachine { state State1; initial -> State1; }; }; In the above picture we can more easily understand the two errors reported for the Top capsule's two parts ping and pong . Port Ponger::p2 is a behavior port so one connection is expected for that port (but none is present), while port Pinger::p1 is a non-behavior port so two connections are expected for that port (but only one is present, on its \"inside\"). Both problems can be solved by adding a connector in Top which connects these ports on their \"outside\". ART_0026_illegalConnection Severity Reason Quick Fix Error A connector connects two ports with incompatible conjugations. N/A Ports connected by a connector must have compatible conjugations. If the ports are at the same level in the capsule's structure (e.g. both ports belong to capsules typing capsule parts owned by the same capsule), then the connected ports must have the opposite conjugation. This is because events that are sent out from one of the ports must be able to be received by the other port. However, if the ports are at different levels in the capsule's structure (e.g. one of them belongs to a capsule typing a capsule part owned by the capsule and the other belongs to the capsule itself), then the ports must have the same conjugation. This is because in this case events are simply delegated from one capsule to another. capsule Top { part ping : Pinger, pong : Ponger; connect ping.p1 with pong.p2; // ART_0026 (same port conjugations but should be different) statemachine { state t21; initial -> t21; }; }; capsule Inner { service behavior port p : PROTO; statemachine { state State; initial -> State; }; }; capsule Pinger { service port p1~ : PROTO; part inner : Inner; connect p1 with inner.p; // ART_0026 (different port conjugations but should be same) statemachine { state State1; initial -> State1; }; }; capsule Ponger { service behavior port p2~ : PROTO; statemachine { state State1; initial -> State1; }; }; Here we see that both connectors are invalid. Port p2 and port p1 are at the same level in Top 's structure so their conjugations should be different, while port p1 and port p are at different levels in Top 's structure so their conjugations should be the same. ART_0027_incompatibleProtocolsForConnectedPorts Severity Reason Quick Fix Error A connector connects two ports with incompatible protocols. N/A Ports connected by a connector must have compatible protocols. For RTist in Code this means that the protocols must be the same. Note HCL RTist uses a different criteria for protocol compatibility. There two protocols are compatible if all events that can be sent by a port typed by the source protocol can be received by the other port typed by the target protocol. Also in HCL RTist the most common case is that the source and target protocols are the same, but they can also be different as long as all their events (both in-events and out-events) match both by name and parameter data type. This is a legacy behavior which is not recommended, and hence not supported by RTist in Code. protocol PROTO1 { in pong(); out ping(); }; protocol PROTO2 { in pong(); out ping(); }; protocol PROTO3 { in pong(); out ping3(); }; capsule Top { service port p1 : PROTO1; service port p2~ : PROTO2; service port p3~ : PROTO3; connect p1 with p2; // ART_0027 (but OK in HCL RTist) connect p1 with p3; // ART_0027 (also not OK in HCL RTist due to event ping3) statemachine { state t21; initial -> t21; }; }; ART_0028_superfluousTrigger Severity Reason Quick Fix Warning A transition has a trigger which can never be triggered at runtime since there is another trigger on a transition from the same state that is identical. N/A Triggers for outgoing transitions of a state must be different. If two triggers specify the same event and port, and neither of them has a guard condition, then both of them will be enabled at the same time. In this case only one of the triggers will trigger the transition at runtime and the other one is superfluous. You can fix this problem either by removing the superfluous trigger, or to add a guard condition to one or both of the triggers or transitions. This validation rule is not run when the trigger or its transition has a guard, since it's then not possible to statically determine whether a trigger is superfluous or not. capsule Base_27 { service port timer : Timing; statemachine { state BS; initial -> BS; _XTRANS: BS -> BS on timer.timeout; }; }; capsule SC27 : Base_27 { statemachine { state State, State2; redefine _XTRANS : BS -> State on timer.timeout; BS -> State2 on timer.timeout; // ART_0028 State -> State2 on timer.timeout; }; }; ART_0029_transitionToCompositeStateNoEntry Severity Reason Quick Fix Warning A composite state is entered without using an entry point. N/A If a composite state is entered without using an entry point, the behavior may be different the first time the state is entered compared to subsequent times it's entered. The first time the initial transition of the composite state will execute, while after that it will be entered using deep history (i.e. directly activate the substate that was previously active in the composite state). This difference in behavior is not evident just by looking at the state diagram, and can therefore be surprising and cause bugs. It's therefore recommended to always enter a composite state using an entry point. See Hierarchical Statemachines for more information. capsule Cap { statemachine { state BS { entrypoint ep1; initial -> Nested; state Nested; }; _Initial: initial -> BS; // ART_0029 }; }; ART_0030_transitionToCompositeStateNoEntryNoInitialTrans Severity Reason Quick Fix Error A composite state is entered without using an entry point, and its state machine has no initial transition. N/A This validation rule is related to ART_0029_transitionToCompositeStateNoEntry . If a composite state is entered without using an entry point, and the nested state machine of the composite state has no initial transition, then it is undefined what to do when entering the state. This is therefore not allowed. capsule Cap { statemachine { state BS { entrypoint ep1; state Nested; }; _Initial: initial -> BS; // ART_0030 }; }; ART_0031_portBothNonServiceAndNonBehavior Severity Reason Quick Fix Error A port is both a non-service and a non-behavior port at the same time. N/A A port that is not a service port is internal to a capsule. For such a port to be useful it must be a behavior port; otherwise the capsule cannot send and receive events on the port. Hence, a non-service port cannot at the same time be a non-behavior port. capsule C31 { port fp : Proto; // ART_0031 statemachine { state State; initial -> State; }; };","title":"Validation"},{"location":"validation/#problem-severity","text":"Each validation rule has a default severity which will be used for the problems that are reported by the rule: Error An error is a problem that is severe enough to prevent building a correct application. Errors must be fixed, and it will not be possible to build the Art files into a C++ application until all errors have been resolved. Warning A warning is a potential problem, which you may or may not choose to fix. It can for example indicate a deviation from common conventions and best practises and it can indicate that the application will not behave as you may expect. Information An information is just a message that you should be aware of. It doesn't really indicate a problem, and you don't need to fix it. You can customize the default severity of any validation rule, and you can also choose to completely disable a certain validation rule that you don't think provides any value. See Configuring Validation for more information.","title":"Problem Severity"},{"location":"validation/#problem-reporting","text":"When a validation rule has found a problem in an Art file, it is marked by underlining one or several Art elements in the file. The underlining is red for errors, yellow for warnings and blue for information messages. For example, in the capsule shown below one warning and two errors have been found. You can hover the cursor over these underlinings to get a tooltip with information about the problem. Every problem has a message that describes it. Often this message gives enough information for understanding how to fix the problem. If this is not the case you can go to the documentation about the validation rule to find more information, examples and suggestions for how the problem can be fixed. To easily find the documentation click the hyperlink that consists of the unique id of the validation rule (it starts with the prefix \"ART_\" followed by a 4 digit number and a name). Alternatively you can search for the validation rule id on this page. Often a problem may be associated with more than one Art element. There is a main element on which the problem will be shown, but there often also are other elements that are related to the problem in one way or another. You can navigate to related elements to get a better understanding of why a problem is reported and how to fix it. In the screenshot above the problem has a single related element (the capsule tlSystem ) but in general a problem can have an arbitrary number of related elements. Problems are also reported by means of icons in diagrams. Below are three states with problems of different severity: A problem icon has a tooltip that shows the message of the problem. You can disable problem reporting in diagrams by means of a configuration setting rtistic.diagram.showDiagnostics .","title":"Problem Reporting"},{"location":"validation/#problems-view","text":"Too see all problems found in all Art files in the workspace, open the Problems view. The total number of problems found are shown in the Problems view heading. By default problems are shown in a tree grouped by the Art files where they were found. However, you can also view them as a flat table instead (but note that related elements can only be seen when using the tree view). If there are many problems, it can help to filter the Problems View by typing some text in the filter box. For example, you can filter using a regular expression that matches only some of the files in the workspace, to reduce the number of problems shown.","title":"Problems View"},{"location":"validation/#quick-fix","text":"Some problems have one or several typical solutions that are possible to apply automatically by means of \"code actions\". If a problem has at least one such code action defined, a yellow light bulb icon will appear and a Quick Fix command will be available in the problem tooltip. Note that most semantic errors cannot be automatically resolved like this, but in some simple cases it's possible.","title":"Quick Fix"},{"location":"validation/#configuring-validation","text":"Validation can be configured to change which rules that should run, and what severity they should report found problems with. By default every validation rule is enabled and uses a predefined severity level. Validation rules can be configured either globally by means of a setting, or locally by means of a property rule_config . In both cases the rule configuration consists of a comma-separated list of 5 letter strings where the first letter specifies if the rule is disabled and it's severity (X,I,W,E) and remaining letters specify the rule id. For example, the rule configuration X0003,I0004,W0009,E0005 means the following: The rule ART_0003_nameShouldStartWithUpperCase is disabled The rule ART_0004_nameShouldStartWithLowerCase has its severity set to Information The rule ART_0009_invalidProperty has its severity set to Warning The rule ART_0005_choiceWithoutElseTransition has its severity set to Error To configure validation rules globally, use the configuration setting rtistic.validation.ruleConfiguration . A global configuration will apply for all Art files in the workspace, and all Art elements within those files, unless a local rule configuration has been set on an element. To configure validation rules locally, set the property rule_config on an Art element. It will affect the validation of that Art element itself, as well as all elements contained within that Art element. Here is an example of how to disable the validation rule ART_0003_nameShouldStartWithUpperCase on a capsule. Note that it also will disable this rule for elements contained within the capsule, such as states. capsule customCapsule // no warning even if capsule name is not capitalized [[rt::properties( rule_config=\"X0003\" )]]{ statemachine { state customState; // no warning here too initial -> customState; }; };","title":"Configuring Validation"},{"location":"validation/#validation-rules","text":"This chapter lists all validation rules which RTist in Code checks your Art application against.","title":"Validation Rules"},{"location":"validation/#art_0001_invalidnamecpp","text":"Severity Reason Quick Fix Error An Art element has a name that is not a valid C++ name. N/A Art elements are translated to C++ elements without changing the elements' names. Hence you need to choose names for Art elements that are valid in C++. For example, C++ keywords cannot be used. If you ignore this error you can expect errors when compiling the generated C++ code. protocol InvalidNameProtocol { in virtual(); // ART_0001 (\"virtual\" is a C++ keyword) };","title":"ART_0001_invalidNameCpp"},{"location":"validation/#art_0002_duplicatenamesinscope","text":"Severity Reason Quick Fix Error Two or more Art elements in the same scope have the same names or signatures. N/A Names of Art elements must be unique within the same scope. The following is checked: Top-level elements within an Art file. Note that even top-level elements in different Art files should have unique names since the corresponding C++ elements all will be within the global namespace, but this is currently not checked (but will be detected by the C++ linker). Events of a protocol. Note that in-events and out-events are checked separately, since an in-event and an out-event will have the same name when you define a symmetric event (see Protocol and Event ). Parts of a capsule. Ports of a capsule. States and pseudo states (collectively referred to as \"vertices\") of a state machine. Transitions of a state machine. Trigger operations of a class . Note that several trigger operations may have the same name as long as their signatures are unique. All elements with clashing names or signatures will be reported as related elements. Use this to find the element(s) that need to be renamed. protocol DupProto { in inEvent1(); // ART_0002 in inEvent1(); // ART_0002 out inEvent1(); // OK (symmetric event) }; class DNIS { trigger op1(`int` p); trigger op1(); // OK (signatures are unique) statemachine { state State; initial -> State; }; };","title":"ART_0002_duplicateNamesInScope"},{"location":"validation/#art_0003_nameshouldstartwithuppercase","text":"Severity Reason Quick Fix Warning An Art element's name doesn't follow the naming convention to start with uppercase. Capitalize Name Just like in most languages Art has certain conventions on how elements should be named. The following elements should have names that start with an uppercase letter: Capsule Class Protocol State A Quick Fix is available that will fix the problem by capitalizing the name. Note, however, that it will only update the element's name, and not all references. If you have references to the element you may instead want to fix the problem by performing a Rename. capsule myCapsule { // ART_0003 statemachine { state sstate; // ART_0003 initial -> sstate; }; }; In this context an underscore ( _ ) is considered a valid upper case character, so all names that start with underscore are accepted by this validation rule.","title":"ART_0003_nameShouldStartWithUpperCase"},{"location":"validation/#art_0004_nameshouldstartwithlowercase","text":"Severity Reason Quick Fix Warning An Art element's name doesn't follow the naming convention to start with lowercase. Decapitalize Name Just like in most languages Art has certain conventions on how elements should be named. The following elements should have names that start with a lowercase letter: Event Port Part Trigger operation Choice and junction points Entry and exit points Transition A Quick Fix is available that will fix the problem by decapitalizing the name. Note, however, that it will only update the element's name, and not all references. If you have references to the element you may instead want to fix the problem by performing a Rename. protocol LowerCaseTestProtocol { out MyEvent(); // ART_0004 }; In this context an underscore ( _ ) is considered a valid lower case character, so all names that start with underscore are accepted by this validation rule.","title":"ART_0004_nameShouldStartWithLowerCase"},{"location":"validation/#art_0005_choicewithoutelsetransition","text":"Severity Reason Quick Fix Warning A choice lacks an outgoing else-transition. N/A If no outgoing transition of a choice is enabled at runtime (because no outgoing transition has a guard condition that is fulfilled) then the state machine will get stuck in the choice for ever. To avoid this you should ensure that at least one outgoing transition is enabled. A good way to do this is to use 'else' as the guard condition for one of the outgoing transitions. Such an else-transition will then execute if no other outgoing transition of the choice is enabled. capsule ChoiceSample { statemachine { state State; initial -> State; choice x; // ART_0005 State -> x; x -> State when `return getVal() == 5;`; }; }; Note that a transition without any guard condition is equivalent to a transition with a guard condition that is always fulfilled (i.e. a guard condition that returns true). An outgoing transition from a choice or junction without any guard is therefore also an else-transition.","title":"ART_0005_choiceWithoutElseTransition"},{"location":"validation/#art_0006_choicewithoutoutgoingtransitions","text":"Severity Reason Quick Fix Error A choice has no outgoing transitions. N/A A choice should typically have at least two outgoing transitions to be meaningful. Having only one outgoing transition is possible if it is an else-transition (i.e. a transition with an 'else' guard, or without any guard at all). However, a choice without any outgoing transition is not allowed since the state machine always will get stuck when reaching such a choice. capsule ChoiceSample { statemachine { state State; initial -> State; choice x; // ART_0006 State -> x; }; };","title":"ART_0006_choiceWithoutOutgoingTransitions"},{"location":"validation/#art_0007_choicewithtoomanyelsetransitions","text":"Severity Reason Quick Fix Error A choice has more than one outgoing else-transition. N/A It's good practise to have an outgoing else-transition (i.e. a transition with an 'else' guard, or without any guard at all) for a choice since it will prevent the state machine from getting stuck in the choice at runtime. However, there should not be more than one such else-transition defined, since otherwise it's ambiguous which one of them to trigger in the case none of the other outgoing transitions from the choice are enabled. capsule ChoiceSample { statemachine { state State, State2; initial -> State; choice x; // ART_0007 State -> x; x -> State; x -> State2 when `else`; }; };","title":"ART_0007_choiceWithTooManyElseTransitions"},{"location":"validation/#art_0008_initialtransitioncount","text":"Severity Reason Quick Fix Error A state machine has too many initial transitions, or no initial transition at all. N/A A state machine of a capsule or class must have exactly one initial transition. A common reason for this error is that you have introduced inheritance between two capsules which both have state machines with an initial transition. Because of that the derived capsule will have two initial transitions (the one it defines itself locally plus the one it inherits from the base capsule). In this case the error can be fixed by either deleting or excluding the initial transition from the derived capsule, or to let it redefine the initial transition from the base capsule. capsule InitTransCap2 { statemachine { state State; initial -> State; }; }; capsule InitTransCap3 : InitTransCap2 { statemachine { state State; initial -> State; // ART_0008 }; }; Note that if the initial transition in the base capsule has no name, the derived capsule cannot exclude or redefine it. It's therefore good practise to name the initial transition if you expect your capsule to be inherited from.","title":"ART_0008_initialTransitionCount"},{"location":"validation/#art_0009_invalidproperty","text":"Severity Reason Quick Fix Error A non-existing property is set for an element. Remove Property Most Art elements have properties that can be set to change their default values. Different elements have different properties and if you get this error it means you have referenced a non-existing property for an Art element. A Quick Fix is available for removing the setting of the invalid property. Use Content Assist ( Ctrl + Space ) to get a list of valid properties for an Art element. protocol IP_PROTO [[rt::properties( no_property = 4 // ART_0009 (A protocol has no property called \"no_property\") )]] { };","title":"ART_0009_invalidProperty"},{"location":"validation/#art_0010_invalidpropertyvalue","text":"Severity Reason Quick Fix Error A property is set to a value of incorrect type. N/A Most Art elements have properties and every property has a type that is either boolean, integer, string or an enumeration. The type of the value assigned to a property must match the property's type. For example, you cannot assign an integer value to a boolean property. capsule IPV_Cap [[rt::properties( generate_file_header=4 // ART_0010 (\"generate_file_header\" is a boolean property) )]]{ statemachine { state State; initial -> State; }; };","title":"ART_0010_invalidPropertyValue"},{"location":"validation/#art_0011_propertysettodefaultvalue","text":"Severity Reason Quick Fix Warning A property is set to its default value. Remove Property Most Art elements have properties and every property has a default value. It's unnecessary to explicitly set a property to its default value. A Quick Fix is available for removing the setting of the property. class C_PropDefaultValue [[rt::properties( const_target_param_for_decode=false // ART_0011 )]] { statemachine { state State; initial -> State; }; };","title":"ART_0011_propertySetToDefaultValue"},{"location":"validation/#art_0012_invalidcodesnippet","text":"Severity Reason Quick Fix Error A code snippet is invalid in one way or the other. Remove Code Snippet A code snippet 's kind is specified after the prefix rt:: . Different Art elements may have different kinds of code snippets. Also, some Art elements may have multiple code snippets of a certain kind, while others only may have one code snippet of each kind. A Quick Fix is available for removing the invalid code snippet. [[rt::header_preface]] // ART_0012 (code snippet for capsule/class placed at file level) ` // YourCodeHere ` capsule Name { [[rt::unknown]] // ART_0012 (non-existing kind of code snippet) ` // YourCodeHere ` part x : OtherCap [[rt::createFunction]] ` return new DemoCap(rtg_rts, rtg_ref); ` [[rt::createFunction]] // ART_0012 (duplicated code snippet) ` return new DemoCap(rtg_rts, rtg_ref); `; statemachine { state State; initial -> State; }; };","title":"ART_0012_invalidCodeSnippet"},{"location":"validation/#art_0013_partmultiplicityerror","text":"Severity Reason Quick Fix Error The part's lower multiplicity must be less than its upper multiplicity. N/A If a part has a multiplicity that specifies a range (i.e. both a lower and upper multiplicity), then the lower multiplicity must be less than the upper multiplicity. capsule PME_Cap { part myPart : OtherCap [2..2]; // ART_0013 statemachine { state State; initial -> State; }; };","title":"ART_0013_partMultiplicityError"},{"location":"validation/#art_0014_partkindmultiplicityinconsistency","text":"Severity Reason Quick Fix Warning The part's kind is inconsistent with its multiplicity. N/A The multiplicity of a capsule part must match the part's kind. The following is checked: A fixed part must have a multiplicity greater than zero. This is because when the container capsule is incarnated at least one capsule instance must be incarnated into the fixed part. An optional part must have a lower multiplicity of zero. This means that when the container capsule is incarnated no capsule instances will be incarnated into the optional part. Hence, this is what makes the part optional. It's only possible to specify the part multiplicity using a C++ expression if the part is fixed. In case any of these inconsistencies is detected, the faulty multiplicity will be ignored and a default multiplicity (see Part ) will be used instead. capsule PKMI_Cap { fixed part myPart : OtherCap [0..2]; // ART_0014 (Fixed part should not have lower multiplicity 0) optional part myPart2 : OtherCap [1..5]; // ART_0014 (Optional part should not have lower multiplicity > 0) optional part myPart3 : OtherCap [`5`]; // ART_0014 (Only a fixed part may have its multiplicity specified with a code expression) statemachine { state State; initial -> State; }; };","title":"ART_0014_partKindMultiplicityInconsistency"},{"location":"validation/#art_0015_internaltransitionoutsidestate","text":"Severity Reason Quick Fix Error An internal transition is defined outside a state, in the top state machine. N/A An internal transition specifies events that can be handled while a state machine is in a certain state without leaving that state. Hence it's only possible to define an internal transition inside a state. It does not make sense to define an internal transition directly in the top state machine. capsule IntTransOutsideState { service port timer : Timing; statemachine { state State { t1 : on timer.timeout ` `; }; initial -> State; terror : on timer.timeout ` `; // ART_0015 }; };","title":"ART_0015_internalTransitionOutsideState"},{"location":"validation/#art_0016_circularinheritance","text":"Severity Reason Quick Fix Error A capsule, class or protocol inherits from itself directly or indirectly. N/A When you use inheritance for capsules, classes and protocols you need to ensure there are no inheritance cycles. Cyclic inheritance means that an element would inherit from itself, directly or indirectly, which is not allowed. Note Both capsules and classes, but not protocols, may have C++ base classes specified by means of C++ code snippets. Such inheritance relationships are not checked by this validation rule, but by the C++ compiler. The elements that form the inheritance cycle will be reported as related elements. Use this to decide how to break the inheritance cycle. protocol PR1 : PR2 { // ART_0016 }; protocol PR2 : PR1 { // ART_0016 }; class C1 { statemachine { state State; initial -> State; }; }; class C2 : C1 { statemachine { state State; initial -> State; }; }; class C3 : C2, C4 { // ART_0016 statemachine { state State; initial -> State; }; }; class C4 : C3 { // ART_0016 statemachine { state State; initial -> State; }; };","title":"ART_0016_circularInheritance"},{"location":"validation/#art_0017_circularcomposition","text":"Severity Reason Quick Fix Error A capsule contains itself through a cycle in the composition hierarchy. N/A Parts of a capsule must form a strict composition hierarchy. At run-time the root of this hierarchy is the top capsule instance, and all other capsule instances in the application must be directly or indirectly owned by that capsule instance. For a fixed part the creation of contained capsule instances happen automatically when the container capsule is incarnated. It's therefore possible to statically analyze the fixed parts and check for cycles in the composition hierarchy. Note Only the static type of fixed capsule parts are used when looking for composition cycles. If a part has a capsule factory that specifies a create function using C++ code, then a different dynamic type may be specified for the created capsule instances for that part. This opens up for more possibilities of introducing cycles in the composition hierarchy that will not be detected by this validation rule. The fixed parts that form the composition cycle will be reported as related elements. Use this to decide how to break the composition cycle. capsule CComp2 { fixed part p2 : CComp3; // ART_0017 statemachine { state State; initial -> State; }; }; capsule CComp3 part p3 : CComp2; // ART_0017 statemachine { state State; initial -> State; }; };","title":"ART_0017_circularComposition"},{"location":"validation/#art_0018_circulartransitions","text":"Severity Reason Quick Fix Error A state machine has a cycle in the transitions that execute when leaving a junction. N/A A junction can split an incoming transition flow into multiple outgoing transition flows based on evaluating guard conditions for the outgoing transitions. If care is not taken it's possible to introduce cycles in the outgoing transition flows. Such cycles could lead to infinite recursion when the state machine executes, depending on what guard conditions will be fulfilled at runtime. You should therefore ensure there are no such transition cycles. The transitions that form the cycle will be reported as related elements. Use this to decide how to break the transition cycle. capsule CT_cap { statemachine { // ART_0018 state S1; initial -> S1; junction j1, j2; t1: S1 -> j1; t2: j1 -> j2; t3: j2 -> j1; }; };","title":"ART_0018_circularTransitions"},{"location":"validation/#art_0019_unwiredportbothpublisherandsubscriber","text":"Severity Reason Quick Fix Error An unwired port is declared as being both a subscriber and publisher at the same time. N/A An unwired port can at runtime be connected to another unwired port. One of the connected ports will be a publisher port (a.k.a SPP port) while the other will be a subscriber port (a.k.a SAP port). An unwired port can either be statically declared as being a publisher or subscriber port, or it can be dynamically decided at port registration time if the port should be a publisher or subscriber. The same port can not be both a subscriber and a publisher port at the same time. capsule UnwiredCapsule { subscribe publish port p1 : UnwiredProtocol; // ART_0019 statemachine { state State; initial -> State; }; };","title":"ART_0019_unwiredPortBothPublisherAndSubscriber"},{"location":"validation/#art_0020_wiredportwithunwiredproperties","text":"Severity Reason Quick Fix Warning A property that only is applicable for an unwired port is specified for a wired port. N/A An unwired port may have properties that control how it will be registered at runtime (see registration and registration_name ). These properties have no meaning and will be ignored for wired ports. capsule UnwiredCapsule2 { port p1 [[rt::properties( registration_name=\"hi\" )]]: UnwiredProtocol; // ART_0020 statemachine { state State; initial -> State; }; };","title":"ART_0020_wiredPortWithUnwiredProperties"},{"location":"validation/#art_0021_unwiredportregnamesameasportname","text":"Severity Reason Quick Fix Warning An unwired port is set to use a registration name that equals the name of the port. N/A When an unwired port is registered a name is used that by default is the name of the port. The property registration_name can be used for specifying another name. It's hence unnecessary to use that property for specifying the name of the port, since it is the default name that anyway would be used. capsule UnwiredCapsule3 { unwired behavior port p1~ [[rt::properties( registration_name = \"p1\" )]] : UnwiredProtocol; // ART_0021 statemachine { state State; initial -> State; }; };","title":"ART_0021_unwiredPortRegNameSameAsPortName"},{"location":"validation/#art_0022_ruleconfigproblem","text":"Severity Reason Quick Fix Warning The rule_config property has a malformed value. N/A The rule_config property can be set on Art elements to configure which validation rules to run for that element (and for all elements it contains). It can also be used for setting a custom severity for those rules. The value of the rule_config property should be a comma-separated list of 5 letter strings where the first letter specifies if the rule is disabled and it's severity (X,I,W,E) and remaining letters specify the rule id. See Configuring Validation for more information and examples. capsule RCP [[rt::properties( rule_config=\"X0000\" // ART_0022 (a validation rule with id 0000 does not exist) )]]{ statemachine { state State; initial -> State; }; };","title":"ART_0022_ruleConfigProblem"},{"location":"validation/#art_0023_entryexitcodecount","text":"Severity Reason Quick Fix Error A state has too many entry and/or exit actions. N/A A state can at most have one entry and one exit action. Solve this problem by merging all entry and exit actions of the state to a single entry and exit action that performs everything that should be done when the state is entered and exited. capsule CX { statemachine { state Composite { entry // ART_0023 ` entry1(); `; entry // ART_0023 ` entry2(); `; }; initial -> Composite; }; };","title":"ART_0023_entryExitCodeCount"},{"location":"validation/#art_0024_unwiredportnotbehavior","text":"Severity Reason Quick Fix Error An unwired port is not defined as a behavior port. Make Behavior Port, Make Wired Port An unwired port cannot be connected to another port by means of a connector . Hence, it's required that an unwired port is defined to be a behavior port. Otherwise it would not be possible for the owner capsule to send and receive events on an unwired port. Two Quick Fixes are available for fixing this problem. Either the port can be turned into a behavior port, or it can be turned into a wired port. capsule Pinger { service unwired port p1 : PROTO; // ART_0024 statemachine { state State1; initial -> State1; }; };","title":"ART_0024_unwiredPortNotBehavior"},{"location":"validation/#art_0025_portonpartconnectionerror","text":"Severity Reason Quick Fix Error A wired port is not properly connected, or an unwired port is connected. N/A An unwired port must not be connected to another port by means of a connector . Instead you should register such a port dynamically so that it can be connected at runtime with another matching port. A wired port, however, must be connected. If the port is not a behavior port, it must be connected both on the \"inside\" and on the \"outside\" by two connectors. That is because the purpose of such a relay port is to simply relay communication from one port to another. By \"inside\" we mean the composite structure of the capsule that owns the port, and by \"outside\" we mean the composite structure to which the part that is typed by the capsule belongs. If the port is a behavior port, it should only be connected on the \"outside\". capsule Top { part ping : Pinger, // ART_0025 (not connected in capsule Top) pong : Ponger; // ART_0025 (not connected in capsule Top) statemachine { state t21; initial -> t21; }; }; capsule Inner { service behavior port p : PROTO; statemachine { state State; initial -> State; }; }; capsule Pinger { service port p1 : PROTO; part inner : Inner; connect p1 with inner.p; statemachine { state State1; initial -> State1; }; }; capsule Ponger { service behavior port p2~ : PROTO; statemachine { state State1; initial -> State1; }; }; In the above picture we can more easily understand the two errors reported for the Top capsule's two parts ping and pong . Port Ponger::p2 is a behavior port so one connection is expected for that port (but none is present), while port Pinger::p1 is a non-behavior port so two connections are expected for that port (but only one is present, on its \"inside\"). Both problems can be solved by adding a connector in Top which connects these ports on their \"outside\".","title":"ART_0025_portOnPartConnectionError"},{"location":"validation/#art_0026_illegalconnection","text":"Severity Reason Quick Fix Error A connector connects two ports with incompatible conjugations. N/A Ports connected by a connector must have compatible conjugations. If the ports are at the same level in the capsule's structure (e.g. both ports belong to capsules typing capsule parts owned by the same capsule), then the connected ports must have the opposite conjugation. This is because events that are sent out from one of the ports must be able to be received by the other port. However, if the ports are at different levels in the capsule's structure (e.g. one of them belongs to a capsule typing a capsule part owned by the capsule and the other belongs to the capsule itself), then the ports must have the same conjugation. This is because in this case events are simply delegated from one capsule to another. capsule Top { part ping : Pinger, pong : Ponger; connect ping.p1 with pong.p2; // ART_0026 (same port conjugations but should be different) statemachine { state t21; initial -> t21; }; }; capsule Inner { service behavior port p : PROTO; statemachine { state State; initial -> State; }; }; capsule Pinger { service port p1~ : PROTO; part inner : Inner; connect p1 with inner.p; // ART_0026 (different port conjugations but should be same) statemachine { state State1; initial -> State1; }; }; capsule Ponger { service behavior port p2~ : PROTO; statemachine { state State1; initial -> State1; }; }; Here we see that both connectors are invalid. Port p2 and port p1 are at the same level in Top 's structure so their conjugations should be different, while port p1 and port p are at different levels in Top 's structure so their conjugations should be the same.","title":"ART_0026_illegalConnection"},{"location":"validation/#art_0027_incompatibleprotocolsforconnectedports","text":"Severity Reason Quick Fix Error A connector connects two ports with incompatible protocols. N/A Ports connected by a connector must have compatible protocols. For RTist in Code this means that the protocols must be the same. Note HCL RTist uses a different criteria for protocol compatibility. There two protocols are compatible if all events that can be sent by a port typed by the source protocol can be received by the other port typed by the target protocol. Also in HCL RTist the most common case is that the source and target protocols are the same, but they can also be different as long as all their events (both in-events and out-events) match both by name and parameter data type. This is a legacy behavior which is not recommended, and hence not supported by RTist in Code. protocol PROTO1 { in pong(); out ping(); }; protocol PROTO2 { in pong(); out ping(); }; protocol PROTO3 { in pong(); out ping3(); }; capsule Top { service port p1 : PROTO1; service port p2~ : PROTO2; service port p3~ : PROTO3; connect p1 with p2; // ART_0027 (but OK in HCL RTist) connect p1 with p3; // ART_0027 (also not OK in HCL RTist due to event ping3) statemachine { state t21; initial -> t21; }; };","title":"ART_0027_incompatibleProtocolsForConnectedPorts"},{"location":"validation/#art_0028_superfluoustrigger","text":"Severity Reason Quick Fix Warning A transition has a trigger which can never be triggered at runtime since there is another trigger on a transition from the same state that is identical. N/A Triggers for outgoing transitions of a state must be different. If two triggers specify the same event and port, and neither of them has a guard condition, then both of them will be enabled at the same time. In this case only one of the triggers will trigger the transition at runtime and the other one is superfluous. You can fix this problem either by removing the superfluous trigger, or to add a guard condition to one or both of the triggers or transitions. This validation rule is not run when the trigger or its transition has a guard, since it's then not possible to statically determine whether a trigger is superfluous or not. capsule Base_27 { service port timer : Timing; statemachine { state BS; initial -> BS; _XTRANS: BS -> BS on timer.timeout; }; }; capsule SC27 : Base_27 { statemachine { state State, State2; redefine _XTRANS : BS -> State on timer.timeout; BS -> State2 on timer.timeout; // ART_0028 State -> State2 on timer.timeout; }; };","title":"ART_0028_superfluousTrigger"},{"location":"validation/#art_0029_transitiontocompositestatenoentry","text":"Severity Reason Quick Fix Warning A composite state is entered without using an entry point. N/A If a composite state is entered without using an entry point, the behavior may be different the first time the state is entered compared to subsequent times it's entered. The first time the initial transition of the composite state will execute, while after that it will be entered using deep history (i.e. directly activate the substate that was previously active in the composite state). This difference in behavior is not evident just by looking at the state diagram, and can therefore be surprising and cause bugs. It's therefore recommended to always enter a composite state using an entry point. See Hierarchical Statemachines for more information. capsule Cap { statemachine { state BS { entrypoint ep1; initial -> Nested; state Nested; }; _Initial: initial -> BS; // ART_0029 }; };","title":"ART_0029_transitionToCompositeStateNoEntry"},{"location":"validation/#art_0030_transitiontocompositestatenoentrynoinitialtrans","text":"Severity Reason Quick Fix Error A composite state is entered without using an entry point, and its state machine has no initial transition. N/A This validation rule is related to ART_0029_transitionToCompositeStateNoEntry . If a composite state is entered without using an entry point, and the nested state machine of the composite state has no initial transition, then it is undefined what to do when entering the state. This is therefore not allowed. capsule Cap { statemachine { state BS { entrypoint ep1; state Nested; }; _Initial: initial -> BS; // ART_0030 }; };","title":"ART_0030_transitionToCompositeStateNoEntryNoInitialTrans"},{"location":"validation/#art_0031_portbothnonserviceandnonbehavior","text":"Severity Reason Quick Fix Error A port is both a non-service and a non-behavior port at the same time. N/A A port that is not a service port is internal to a capsule. For such a port to be useful it must be a behavior port; otherwise the capsule cannot send and receive events on the port. Hence, a non-service port cannot at the same time be a non-behavior port. capsule C31 { port fp : Proto; // ART_0031 statemachine { state State; initial -> State; }; };","title":"ART_0031_portBothNonServiceAndNonBehavior"},{"location":"building/","text":"Art and C++ files can be built into applications or libraries. The build process consists of three steps: Generate source files In this step Art files are translated to C++ source files. Generate a make file A make file for building generated C++ code (and possibly also other C++ code) is generated. Run make to generate binaries A make tool is invoked for building an executable or library from the generated make file. All these steps require information which is stored in a transformation configuration (TC for short). It is a text file which contains various properties needed for translating Art elements to C++ code, for generating the make file, and finally for launching the make tool. You can have more than one TC in your workspace, but at most one TC in each workspace folder can be active . Set a TC as active by right-clicking on it and perform the command Set as Active . An active TC is marked with a checkmark. Once there is an active TC in a workspace folder, the first and second steps (generation of C++ source files and make file) will happen automatically for all Art files contained in that workspace folder. The files that get generated are placed in its own workspace folder as specified by the targetFolder property of the TC. The C++ code in this target workspace folder is then incrementally and automatically updated as soon as any of these Art files are changed. Also the make file (which by default is placed in a subfolder called default in the target workspace folder) gets updated when needed. Below is an example of a simple target workspace folder. To perform the third step (running make to generate binaries) you can simply go to the Terminal and invoke the command make . For convenience there is also a command Build available in the context menu of a TC. This command will first set the TC as active (if it was not already active) so that C++ code and a make file get generated. It will then run the make tool on the generated make file. There are also two other useful commands in the context menu of a TC: Run First builds the TC, and then attempts to launch the executable that is produced. The executable is launched in a non-debug mode by specifying the launch argument -URTS_DEBUG=quit . If you instead want to launch the executable for debugging it you can go to the Terminal and manually launch it from there without any extra arguments. Note that if your TC creates a library rather than an executable, then this command will still build the TC, but will then give an error message since there is no executable to run. Clean Removes the target workspace folder produced when building a TC. This means that all generated C++ code, the make file, as well as any produced binaries will be removed. If you only want to remove the binaries you can instead go to the Terminal and invoke make clean to clean using the make file. Build Messages When you use the Build or Run commands on a TC, messages will be printed in two places depending on what kind of message it is: The Terminal view. Messages produced when compiling and linking the generated C++ code will be printed here, for example compilation errors. In many cases such messages will have a reference to a generated C++ file which you can control-click to open. In case of Run messages printed by the running executable will also be printed in the Terminal view. To terminate a running executable you can press Ctrl + C in the Terminal view. The Art Build output channel. All other build messages are printed here, for example messages emitted by the C++ code generator. In some cases these messages will have a reference to a file (e.g. an input TC or Art file), and sometimes even to an element within that file. You can control-click these to open the file and navigate to the element. In case the build fails (e.g. because of compilation errors) a hyperlink will be present for opening the Terminal view where the errors that caused the build to fail can be found. Navigation Between Art and Generated C++ You can navigate from an element in an Art file to the corresponding element in the C++ file that gets generated from that Art file. Use the context menu that appears when you right-click on an element in an Art file and invoke the command Open Generated Code . If C++ code has not yet been generated for the Art file, for example because no active TC has been set, navigation will fail with an error message. When navigating to generated C++ code an attempt is made to put the cursor as close as possible to the relevant C++ element. However, when there is no C++ element that directly corresponds to the selected Art element, the cursor may instead be placed on a container C++ element. If there are more than one C++ element generated from a single Art element, you will be prompted for where to navigate. For example: For C++ code snippets you can as an alternative perform the navigation using a tooltip that appears when you hover over the code snippet: If the cursor is within the C++ code snippet when navigating, the cursor will be set at the same place in the generated C++ code. This is convenient if you start to edit a code snippet in an Art file but later realize that you instead want to edit it in the generated C++ code instead. Making Changes in Generated C++ C++ code snippets that are embedded in the Art file will be enclosed by special comments in the generated C++ file. You can edit such code snippets in a generated C++ file. When you save the file your changes will be automatically propagated back to the Art file. Here is an example of what a code snippet may look like in the generated C++ code: //{{{USR file:///c:/rtistic/workspaces/demoWorkspace/HelloWorld.art#::HelloWorld::<TopStateMachine>::<TriggeredTransition_5>::<Effect> std::cout << \"Hello World!\" << std::endl; context()->abort(); //}}}USR The comment contains information about the source Art file and the Art element in that file that contains the code snippet. Note Only make edits on the lines within the special code snippet comments. If you edit outside the comment those edits will be lost the next time the file gets regenerated. And if you change the comment itself, the propagation of changes back to the Art file will no longer work correctly. One very common scenario where it's useful to change a code snippet in a generated file is when there is a compilation error reported in the code snippet. Navigating from that compilation error will take you to the code snippet in the generated file, and it's convenient to directly fix the problem there. Another scenario is when you write new code in such a code snippet and want to take advantage of the editing support for C++ that is provided by your IDE, and/or need to see the full C++ context of the edited code snippet. You can navigate from the code snippet in the Art file to the code snippet in the generated file as described above . You can make edits in multiple code snippets in a generated file. When the file is saved all edited code snippets will be automatically propagated back to the Art file. Building from the Command Line You can build a TC from the command line by using the Art compiler .","title":"Building"},{"location":"building/#build-messages","text":"When you use the Build or Run commands on a TC, messages will be printed in two places depending on what kind of message it is: The Terminal view. Messages produced when compiling and linking the generated C++ code will be printed here, for example compilation errors. In many cases such messages will have a reference to a generated C++ file which you can control-click to open. In case of Run messages printed by the running executable will also be printed in the Terminal view. To terminate a running executable you can press Ctrl + C in the Terminal view. The Art Build output channel. All other build messages are printed here, for example messages emitted by the C++ code generator. In some cases these messages will have a reference to a file (e.g. an input TC or Art file), and sometimes even to an element within that file. You can control-click these to open the file and navigate to the element. In case the build fails (e.g. because of compilation errors) a hyperlink will be present for opening the Terminal view where the errors that caused the build to fail can be found.","title":"Build Messages"},{"location":"building/#navigation-between-art-and-generated-c","text":"You can navigate from an element in an Art file to the corresponding element in the C++ file that gets generated from that Art file. Use the context menu that appears when you right-click on an element in an Art file and invoke the command Open Generated Code . If C++ code has not yet been generated for the Art file, for example because no active TC has been set, navigation will fail with an error message. When navigating to generated C++ code an attempt is made to put the cursor as close as possible to the relevant C++ element. However, when there is no C++ element that directly corresponds to the selected Art element, the cursor may instead be placed on a container C++ element. If there are more than one C++ element generated from a single Art element, you will be prompted for where to navigate. For example: For C++ code snippets you can as an alternative perform the navigation using a tooltip that appears when you hover over the code snippet: If the cursor is within the C++ code snippet when navigating, the cursor will be set at the same place in the generated C++ code. This is convenient if you start to edit a code snippet in an Art file but later realize that you instead want to edit it in the generated C++ code instead.","title":"Navigation Between Art and Generated C++"},{"location":"building/#making-changes-in-generated-c","text":"C++ code snippets that are embedded in the Art file will be enclosed by special comments in the generated C++ file. You can edit such code snippets in a generated C++ file. When you save the file your changes will be automatically propagated back to the Art file. Here is an example of what a code snippet may look like in the generated C++ code: //{{{USR file:///c:/rtistic/workspaces/demoWorkspace/HelloWorld.art#::HelloWorld::<TopStateMachine>::<TriggeredTransition_5>::<Effect> std::cout << \"Hello World!\" << std::endl; context()->abort(); //}}}USR The comment contains information about the source Art file and the Art element in that file that contains the code snippet. Note Only make edits on the lines within the special code snippet comments. If you edit outside the comment those edits will be lost the next time the file gets regenerated. And if you change the comment itself, the propagation of changes back to the Art file will no longer work correctly. One very common scenario where it's useful to change a code snippet in a generated file is when there is a compilation error reported in the code snippet. Navigating from that compilation error will take you to the code snippet in the generated file, and it's convenient to directly fix the problem there. Another scenario is when you write new code in such a code snippet and want to take advantage of the editing support for C++ that is provided by your IDE, and/or need to see the full C++ context of the edited code snippet. You can navigate from the code snippet in the Art file to the code snippet in the generated file as described above . You can make edits in multiple code snippets in a generated file. When the file is saved all edited code snippets will be automatically propagated back to the Art file.","title":"Making Changes in Generated C++"},{"location":"building/#building-from-the-command-line","text":"You can build a TC from the command line by using the Art compiler .","title":"Building from the Command Line"},{"location":"building/art-compiler/","text":"Art compiler reference (command-line arguments etc)","title":"Art Compiler"},{"location":"building/transformation-configurations/","text":"A transformation configuration (or TC for short) contains all properties needed for transforming Art files into C++ code and for building the generated code into an application. It is a text file in JavaScript format with the file extension .tcjs. Using JavaScript for defining build properties has many advantages. For example, it allows for dynamic properties where the value is not a static value but computed by JavaScript code. RTist in Code provides a dedicated language server for TCs to make them just as easy to work with as Art files. A form-based editor is also provided as an alternative. Creating Transformation Configurations To create a new TC select a file in the workspace folder that contains the Art files you want to transform to C++. Then invoke the command File - New File - Transformation Configuration . In the popup that appears specify the name of the TC or keep the suggested default name. A .tcjs file will be created with minimal contents. Specify the mandatory targetFolder property and any other properties needed. Setting a Transformation Configuration as Active You can have more than one TC in your workspace, but at most one TC in each workspace folder can be active . Set a TC as active by right-clicking on it and perform the command Set as Active . An active TC is marked with a checkmark. Automatic code generation for the active TC will start immediately. Editing Transformation Configurations You can edit a TC directly as a JavaScript file in the text editor. Features such as content assist, navigation and hover tooltips work very similar to how they work for an Art file: Use content assist ( Ctrl + Space ) after typing tc. to get the list of all available TC properties that can be set. You can also use content assist in many places to get suggestions for valid TC property values, for example the list of available top capsules. Certain references in the TC can be navigated by Ctrl + click. For example, you can navigate to the top capsule. Rest the cursor on a TC property name to get more information about the property. TC properties are validated when edited and found problems will be reported. As an alternative to editing a TC as a JavaScript file RTist in Code also provides a dedicated form-based editor which may be easier to use, especially until you are familiar with all TC properties that exist and what they mean. To open the form-based TC editor, right-click on a TC file and invoke the context menu command Edit Properties (UI) . Each available TC property has its own widget for viewing and editing the value. The type of widget depends on the type of TC property. For example, an enumerated property like \"C++ Code Standard\" uses a drop down menu. Click the info button to view documentation about a certain TC property. Click the button again to hide the documentation. Certain TC properties have default values. Such values are not stored in the TC file, but the TC editor still shows them so you can know what value will actually be used unless you set a custom value for such a property. You can freely choose if you want to edit TC files as text files or using the form-based TC editor, and you can even use both at the same time. The form-based TC editor is automatically updated when you save the TC file, and the TC file is automatically updated when a widget with a modified value loses focus. Properties Below is an alphabetic list of all properties that can be used in a TC. Note that many TC properties have default values and you only need to specify a value for a TC property if its different from the default value. commonPreface This property allows you to write some code that will be inserted verbatimly into the header unit file (by default called \"UnitName.h\"). Since the header unit file is included by all files that are generated from the TC, you can use the common preface to define or include definitions that should be available everywhere in generated code. compileArguments Specifies the arguments for the C++ compiler used for compiling generated C++ code. Note that some compiler arguments may already be specified in the TargetRTS configuration that is used, and the value of this property will be appended to those standard compiler arguments. compileCommand Specifies which C++ compiler to use for compiling generated C++ code. The default value for this property is $(CC) which is a variable that gets its value from the TargetRTS configuration that is used. copyrightText This property may be used to insert a common comment block in the beginning of each generated file, typically a copyright text. cppCodeStandard Defines the C++ language standard to which generated code will conform. The default value for this property is C++ 17 . Other valid values are C++ 11 , C++ 14 and C++ 20 . If you need to compile generated code with a compiler that doesn't support C++ 11 you can set this preference to Older than C++ 11 . However, you then cannot use the standard version of the TargetRTS since it uses C++ 11 constructs. linkArguments Specifies the arguments for the C++ linker used for linking object files and libraries into an executable. This property is only applicable for TCs that build executables. linkCommand Specifies which C++ linker to use for linking object files and libraries into an executable. The default value for this property is $(LD) which is a variable that gets its value from the TargetRTS configuration that is used. This property is only applicable for executable TCs. makeArguments Specifies the arguments for the make command to be used. makeCommand Specifies which make command to use for processing the generated make file. By default the make command is $defaultMakeCommand which gets its value from which TargetRTS configuration that is used. targetConfiguration Specifies which TargetRTS configuration to use. The TargetRTS location specified in the targetRTSLocation property defines valid values for this property. If this property is not specified, and the default TargetRTS location from the RTist in Code installation is used, then it will get a default value according to the operating system that is used. For Windows a MinGw-based configuration will be used, while for Linux a GCC-based configuration will be used. targetConfigurationName This property maps to a subfolder of the target folder where all generated files that are not source code will be placed. This includes for example makefiles and the files that are produced by these makefiles (typically binaries). The default value of this property is default . targetLocation When a TC is built all generated files (C++ code, make file, binaries etc) will be placed in a so called target folder. This property specifies the name of that folder. The target folder will be added as a workspace folder the first time the TC is built. You can choose any name that is a valid name of a folder, but it can be convenient to base the name on the workspace folder that contains the TC so that the target folder appears near it. For example, if the workspace folder that contains the TC is called \"MyApp\" you can use \"MyApp_target\" as the name of the target folder. The path can be either absolute or relative. Relative paths are resolved against the folder that contains the TC. Use forward slashes as path separator. targetLocation is a mandatory TC property and it has no default value. targetRTSLocation Specifies the location of the TargetRTS to use. The default value of this property is ${RSA_RT_HOME}/C++/TargetRTS which points at the folder in the RTist in Code installation where the TargetRTS C++ implementation resides. topCapsule Specifies the capsule that should be automatically incarnated when the executable starts to run. Hence this property is only applicable for TCs that build executables, and for those TCs it's a mandatory property. The top capsule is the entry point of the realtime application. unitName Specifies the base name of the so called unit header and implementation files that are generated from the TC. By default the value of this property is UnitName which means that these unit files will be called UnitName.cpp and UnitName.h . The unit files contain certain information that applies to the whole unit of code that is generated from a TC. The header unit file is included by all files that are generated from the TC.","title":"Transformation Configurations"},{"location":"building/transformation-configurations/#creating-transformation-configurations","text":"To create a new TC select a file in the workspace folder that contains the Art files you want to transform to C++. Then invoke the command File - New File - Transformation Configuration . In the popup that appears specify the name of the TC or keep the suggested default name. A .tcjs file will be created with minimal contents. Specify the mandatory targetFolder property and any other properties needed.","title":"Creating Transformation Configurations"},{"location":"building/transformation-configurations/#setting-a-transformation-configuration-as-active","text":"You can have more than one TC in your workspace, but at most one TC in each workspace folder can be active . Set a TC as active by right-clicking on it and perform the command Set as Active . An active TC is marked with a checkmark. Automatic code generation for the active TC will start immediately.","title":"Setting a Transformation Configuration as Active"},{"location":"building/transformation-configurations/#editing-transformation-configurations","text":"You can edit a TC directly as a JavaScript file in the text editor. Features such as content assist, navigation and hover tooltips work very similar to how they work for an Art file: Use content assist ( Ctrl + Space ) after typing tc. to get the list of all available TC properties that can be set. You can also use content assist in many places to get suggestions for valid TC property values, for example the list of available top capsules. Certain references in the TC can be navigated by Ctrl + click. For example, you can navigate to the top capsule. Rest the cursor on a TC property name to get more information about the property. TC properties are validated when edited and found problems will be reported. As an alternative to editing a TC as a JavaScript file RTist in Code also provides a dedicated form-based editor which may be easier to use, especially until you are familiar with all TC properties that exist and what they mean. To open the form-based TC editor, right-click on a TC file and invoke the context menu command Edit Properties (UI) . Each available TC property has its own widget for viewing and editing the value. The type of widget depends on the type of TC property. For example, an enumerated property like \"C++ Code Standard\" uses a drop down menu. Click the info button to view documentation about a certain TC property. Click the button again to hide the documentation. Certain TC properties have default values. Such values are not stored in the TC file, but the TC editor still shows them so you can know what value will actually be used unless you set a custom value for such a property. You can freely choose if you want to edit TC files as text files or using the form-based TC editor, and you can even use both at the same time. The form-based TC editor is automatically updated when you save the TC file, and the TC file is automatically updated when a widget with a modified value loses focus.","title":"Editing Transformation Configurations"},{"location":"building/transformation-configurations/#properties","text":"Below is an alphabetic list of all properties that can be used in a TC. Note that many TC properties have default values and you only need to specify a value for a TC property if its different from the default value.","title":"Properties"},{"location":"building/transformation-configurations/#commonpreface","text":"This property allows you to write some code that will be inserted verbatimly into the header unit file (by default called \"UnitName.h\"). Since the header unit file is included by all files that are generated from the TC, you can use the common preface to define or include definitions that should be available everywhere in generated code.","title":"commonPreface"},{"location":"building/transformation-configurations/#compilearguments","text":"Specifies the arguments for the C++ compiler used for compiling generated C++ code. Note that some compiler arguments may already be specified in the TargetRTS configuration that is used, and the value of this property will be appended to those standard compiler arguments.","title":"compileArguments"},{"location":"building/transformation-configurations/#compilecommand","text":"Specifies which C++ compiler to use for compiling generated C++ code. The default value for this property is $(CC) which is a variable that gets its value from the TargetRTS configuration that is used.","title":"compileCommand"},{"location":"building/transformation-configurations/#copyrighttext","text":"This property may be used to insert a common comment block in the beginning of each generated file, typically a copyright text.","title":"copyrightText"},{"location":"building/transformation-configurations/#cppcodestandard","text":"Defines the C++ language standard to which generated code will conform. The default value for this property is C++ 17 . Other valid values are C++ 11 , C++ 14 and C++ 20 . If you need to compile generated code with a compiler that doesn't support C++ 11 you can set this preference to Older than C++ 11 . However, you then cannot use the standard version of the TargetRTS since it uses C++ 11 constructs.","title":"cppCodeStandard"},{"location":"building/transformation-configurations/#linkarguments","text":"Specifies the arguments for the C++ linker used for linking object files and libraries into an executable. This property is only applicable for TCs that build executables.","title":"linkArguments"},{"location":"building/transformation-configurations/#linkcommand","text":"Specifies which C++ linker to use for linking object files and libraries into an executable. The default value for this property is $(LD) which is a variable that gets its value from the TargetRTS configuration that is used. This property is only applicable for executable TCs.","title":"linkCommand"},{"location":"building/transformation-configurations/#makearguments","text":"Specifies the arguments for the make command to be used.","title":"makeArguments"},{"location":"building/transformation-configurations/#makecommand","text":"Specifies which make command to use for processing the generated make file. By default the make command is $defaultMakeCommand which gets its value from which TargetRTS configuration that is used.","title":"makeCommand"},{"location":"building/transformation-configurations/#targetconfiguration","text":"Specifies which TargetRTS configuration to use. The TargetRTS location specified in the targetRTSLocation property defines valid values for this property. If this property is not specified, and the default TargetRTS location from the RTist in Code installation is used, then it will get a default value according to the operating system that is used. For Windows a MinGw-based configuration will be used, while for Linux a GCC-based configuration will be used.","title":"targetConfiguration"},{"location":"building/transformation-configurations/#targetconfigurationname","text":"This property maps to a subfolder of the target folder where all generated files that are not source code will be placed. This includes for example makefiles and the files that are produced by these makefiles (typically binaries). The default value of this property is default .","title":"targetConfigurationName"},{"location":"building/transformation-configurations/#targetlocation","text":"When a TC is built all generated files (C++ code, make file, binaries etc) will be placed in a so called target folder. This property specifies the name of that folder. The target folder will be added as a workspace folder the first time the TC is built. You can choose any name that is a valid name of a folder, but it can be convenient to base the name on the workspace folder that contains the TC so that the target folder appears near it. For example, if the workspace folder that contains the TC is called \"MyApp\" you can use \"MyApp_target\" as the name of the target folder. The path can be either absolute or relative. Relative paths are resolved against the folder that contains the TC. Use forward slashes as path separator. targetLocation is a mandatory TC property and it has no default value.","title":"targetLocation"},{"location":"building/transformation-configurations/#targetrtslocation","text":"Specifies the location of the TargetRTS to use. The default value of this property is ${RSA_RT_HOME}/C++/TargetRTS which points at the folder in the RTist in Code installation where the TargetRTS C++ implementation resides.","title":"targetRTSLocation"},{"location":"building/transformation-configurations/#topcapsule","text":"Specifies the capsule that should be automatically incarnated when the executable starts to run. Hence this property is only applicable for TCs that build executables, and for those TCs it's a mandatory property. The top capsule is the entry point of the realtime application.","title":"topCapsule"},{"location":"building/transformation-configurations/#unitname","text":"Specifies the base name of the so called unit header and implementation files that are generated from the TC. By default the value of this property is UnitName which means that these unit files will be called UnitName.cpp and UnitName.h . The unit files contain certain information that applies to the whole unit of code that is generated from a TC. The header unit file is included by all files that are generated from the TC.","title":"unitName"},{"location":"releases/","text":"All releases of RTist in Code are available on the Visual Studio Marketplace . Release notes can be found here .","title":"Releases"},{"location":"releases/CHANGELOG/","text":"0.0.4 (2022-12-21 13:11) A target configuration for the latest version of the MinGw compiler (ver. 12.2) is now provided. Better support for Linux platform. Improved makefile generation for incremental builds. More information for internal transitions are now shown in the Properties view. The triggers of the internal transitions are shown in a similar way as in the Outline view. Also, the blue and yellow icons representing the effect and guard code snippets for the internal transitions are shown and can be double-clicked in order to navigate to the code snippets in the Art file. If a port has multiplicity > 1 it is now shown in structure diagrams. The form-based TC editor is now automatically refreshed when the underlying .tcjs file is modified and saved. It's now possible to navigate to the top capsule from a TC file by ctrl+click on the capsule name. Content assist (ctrl+space) is now supported for TC property values. Valid values appear in a popup when typing the = character. If there is not a fixed list of valid values, the expected value type (e.g. string) will be shown. Cross-references now bind across workspace folders. This makes it possible to split an application into several workspace folders. For example, Art files built into a library can now be placed in its own folder, and be used from Art files outside that folder. A composite state can now only be expanded if it contains at least one nested state. Previously the Expand button was shown also when the state only contained entry or exit points, which was misleading since expanding such a state didn't reveal anything new that could not already be seen. Attempting to open a diagram using the Art editor context menu now works even when the cursor is not placed within an Art element that can be shown in the diagram. In this case a \"quick pick\" will appear where you can choose one of the elements that are present in the Art file. Hence, this behavior is now the same as when you open diagrams from the Explorer context menu. Protocols now support the rt::header_preface and rt::header_ending code snippets. In particular rt::header_preface is useful for including header files with user-defined types used in the protocol. A new output channel called Art Server is now available and can be seen in the Output view. It's used by the Art language server for printing diagnostic messages (usually internal errors), and can be useful for troubleshooting problems. A new output channel called Art Build is now available and can be seen in the Output view. It's used when building a TC. For example, messages are printed when a build starts and finishes. The editor title for diagrams now contain the name of the Art element. This makes it easier to work with multiple open diagrams at the same time. Content assist now supports creating non-triggered transitions in a state machine. Code generation now supports transition guards, events with parameters of predefined types, connectors between local port and inner structure. It's now possible to set custom colors to be used in diagrams by means of a new color property. Currently this is supported for initial and triggered transitions. 0.0.3 (2022-11-23) The graphical appearance of symbols in class diagrams has improved. Now a line separates the name from properties such as ports and events. Also, icons were added for the properties to make it easier to understand the diagram. The Expand All/Collapse All commands in the Properties view now work also for structure diagrams. Cycles in the composition hierarchy are detected and reported with an error message if found. It's now possible to build a TC using a context menu command Build . And if it produces an executable it's possible to launch it with another context menu command Run . Of course, it's still possible to manually build and run from the terminal. The RTist in Code documentation was extended with several new topics and the landing page was improved. New color themes for better syntax highlighting of Art files (and embedded C++ code) are now available. See this topic for more information. It's now possible to edit TC properties using a form-based editor, as an alternative to directly editing the .tcjs file. The form-based editor is invoked from a context menu on the TC called Edit Properties (UI) . New TC properties are now supported for specifying which make command to use for building generated code, as well as the make arguments. The new properties are makeCommand and makeArguments . The existing TC properties targetProject and targetServicesLibrary were renamed to targetFolder and targetRTSLocation respectively. Fixed several Linux specific problems in the language server. The GLSP library was uplifted to version 1.0. Read about the improvements it brings to diagrams here . A problem with automatically expanding symbols when doing a Rename from a diagram was fixed. When renaming an element, for which one or several diagrams have been opened, the diagrams stay open (previously they were automatically closed as a side-effect of the rename). Navigation from a C++ code snippet to generated C++ code using the hyperlink in the code snippet tooltip now works even if the cursor is not placed inside the code snippet. 0.0.2 (2022-10-20) First public release. Initial support for the Art language, graphical diagrams, transformation configurations and C++ code generation.","title":"0.0.4 (2022-12-21 13:11)"},{"location":"releases/CHANGELOG/#004-2022-12-21-1311","text":"A target configuration for the latest version of the MinGw compiler (ver. 12.2) is now provided. Better support for Linux platform. Improved makefile generation for incremental builds. More information for internal transitions are now shown in the Properties view. The triggers of the internal transitions are shown in a similar way as in the Outline view. Also, the blue and yellow icons representing the effect and guard code snippets for the internal transitions are shown and can be double-clicked in order to navigate to the code snippets in the Art file. If a port has multiplicity > 1 it is now shown in structure diagrams. The form-based TC editor is now automatically refreshed when the underlying .tcjs file is modified and saved. It's now possible to navigate to the top capsule from a TC file by ctrl+click on the capsule name. Content assist (ctrl+space) is now supported for TC property values. Valid values appear in a popup when typing the = character. If there is not a fixed list of valid values, the expected value type (e.g. string) will be shown. Cross-references now bind across workspace folders. This makes it possible to split an application into several workspace folders. For example, Art files built into a library can now be placed in its own folder, and be used from Art files outside that folder. A composite state can now only be expanded if it contains at least one nested state. Previously the Expand button was shown also when the state only contained entry or exit points, which was misleading since expanding such a state didn't reveal anything new that could not already be seen. Attempting to open a diagram using the Art editor context menu now works even when the cursor is not placed within an Art element that can be shown in the diagram. In this case a \"quick pick\" will appear where you can choose one of the elements that are present in the Art file. Hence, this behavior is now the same as when you open diagrams from the Explorer context menu. Protocols now support the rt::header_preface and rt::header_ending code snippets. In particular rt::header_preface is useful for including header files with user-defined types used in the protocol. A new output channel called Art Server is now available and can be seen in the Output view. It's used by the Art language server for printing diagnostic messages (usually internal errors), and can be useful for troubleshooting problems. A new output channel called Art Build is now available and can be seen in the Output view. It's used when building a TC. For example, messages are printed when a build starts and finishes. The editor title for diagrams now contain the name of the Art element. This makes it easier to work with multiple open diagrams at the same time. Content assist now supports creating non-triggered transitions in a state machine. Code generation now supports transition guards, events with parameters of predefined types, connectors between local port and inner structure. It's now possible to set custom colors to be used in diagrams by means of a new color property. Currently this is supported for initial and triggered transitions.","title":"0.0.4 (2022-12-21 13:11)"},{"location":"releases/CHANGELOG/#003-2022-11-23","text":"The graphical appearance of symbols in class diagrams has improved. Now a line separates the name from properties such as ports and events. Also, icons were added for the properties to make it easier to understand the diagram. The Expand All/Collapse All commands in the Properties view now work also for structure diagrams. Cycles in the composition hierarchy are detected and reported with an error message if found. It's now possible to build a TC using a context menu command Build . And if it produces an executable it's possible to launch it with another context menu command Run . Of course, it's still possible to manually build and run from the terminal. The RTist in Code documentation was extended with several new topics and the landing page was improved. New color themes for better syntax highlighting of Art files (and embedded C++ code) are now available. See this topic for more information. It's now possible to edit TC properties using a form-based editor, as an alternative to directly editing the .tcjs file. The form-based editor is invoked from a context menu on the TC called Edit Properties (UI) . New TC properties are now supported for specifying which make command to use for building generated code, as well as the make arguments. The new properties are makeCommand and makeArguments . The existing TC properties targetProject and targetServicesLibrary were renamed to targetFolder and targetRTSLocation respectively. Fixed several Linux specific problems in the language server. The GLSP library was uplifted to version 1.0. Read about the improvements it brings to diagrams here . A problem with automatically expanding symbols when doing a Rename from a diagram was fixed. When renaming an element, for which one or several diagrams have been opened, the diagrams stay open (previously they were automatically closed as a side-effect of the rename). Navigation from a C++ code snippet to generated C++ code using the hyperlink in the code snippet tooltip now works even if the cursor is not placed inside the code snippet.","title":"0.0.3 (2022-11-23)"},{"location":"releases/CHANGELOG/#002-2022-10-20","text":"First public release. Initial support for the Art language, graphical diagrams, transformation configurations and C++ code generation.","title":"0.0.2 (2022-10-20)"},{"location":"target-rts/","text":"The Target RunTime System (or TargetRTS for short) is a C++ library that is used by the code that is generated by RTist in Code. When building the realtime application from the generated code, it links with a TargetRTS library that has been prebuilt for the platform (hardware, operating system etc) on which the realtime application will run. The TargetRTS provides C++ implementations for the concepts of the Art language . The APIs of these implementations are used by the generated code, but also by the embedded C++ code that you write inside the Art files. This documentation serves the following purposes: Provide a general understanding of how the TargetRTS is structured and how it implements important concepts from the Art language. Document the C++ APIs that you can use in C++ code snippets within an Art file. Describe how to build the TargetRTS for a new target platform, including ways to customize it as required.","title":"Target RunTime System"},{"location":"working-with-art/","text":"An Art file is primarily edited using its textual syntax in the text editor . However, many parts of the Art language also has a graphical syntax which can be shown (and to some extent also edited) from graphical diagrams . Visual Studio Code and Eclipse Theia also provide a few views that provide value for Art, such as the Outline view and the References view . These views do not support any editing, but provide useful overview and navigation possibilities.","title":"Working with Art"},{"location":"working-with-art/art-editor/","text":"You can use any text editor for editing Art files, but it's highly recommended to edit them in RTist in Code. Thereby you will have access to features such as syntax coloring , content assist and semantic validation . Syntax Coloring RTist in Code provides color themes that have been specifically designed for being used for editing Art files. Activate one of these color themes from File - Preferences - Color Theme . Art Dark This is a dark theme that colorizes Art keywords, properties and comments. All embedded C++ code will be shown in gray color. This theme can be useful if you mostly edit C++ code snippets in generated files and propagate those changes back to the Art files automatically (see Making Changes in Generated C++ ). Showing C++ code in gray color makes it easier to see what parts you have to edit in the Art file, and what parts (i.e. the C++ code) that you can edit in generated files. Art Dark++ This is a dark theme that colorizes Art keywords, properties and comments. In addition it colorizes embedded C++ code using the same colors as are used for a C++ file. To help in separating Art from C++, all Art code uses a bold font, while C++ code uses a regular font. This theme can be useful if you prefer to edit both Art and C++ code in the Art file. Art Light This is a light theme that uses the same colors as Art Dark. Art Light++ This is a light theme that uses the same colors as Art Dark++. Content Assist This feature, which also is known as IntelliSense or Code Completion, helps you when editing an Art file by proposing commonly used Art constructs that are valid at the current cursor position. Invoke Content Assist by pressing Ctrl + Space . Depending on where the cursor is placed you will get different proposals to choose from. There are four kinds of proposals as shown in the picture below: Code Templates are complete Art elements, for example a capsule, protocol or state. The inserted code template often has variables that you should replace as you find appropriate. For example, the code template for a capsule contains one variable for the capsule name and another for the name of the state which its state machine contains. Press Tab to move forward from one variable to the next and if needed Shift + Tab to move backwards to a previous variable. Note that the same variable may occur in multiple places, like the State variable for the capsule code template which occurs both in the state definition and as a state reference in the initial transition. All occurrances of a variable are updated simultaneously when you replace the variable with a string. References are references to existing Art elements, for example a state, event or capsule. All Art elements of the correct kind which are visible from the cursor position will be available. References may have a qualifier if necessary, for example when referencing an entry point. Name represents an identifier used as the name of an Art element. It appears as a proposal at positions where the Art language allows a named element. Choosing this proposal just inserts the string \"name\" which probably is not so useful. However, the presence of a name item in the proposals list tells you that you can use an arbitrary identifier as the name of an Art element at that position. For example, in the proposals list shown in the picture above name appears since a triggered transition may have an optional name before its declaration. The code template for the triggered transition will not insert a name, since many transitions don't have names, but you can manually add it afterwards: MyTransition: State -> X on timer.timeout Keywords are keywords from the Art language that are valid to use at the cursor position. This also includes lexical tokens such as : or . where applicable. For example, after you have typed the name for the triggered transition shown above you can use Content Assist to learn that it may be followed by either a -> or : token: Renaming Elements To rename an Art element place the cursor on the element's name and press F2 (or invoke the command Rename Symbol from the context menu). This performs a \"rename refactoring\" that updates all references to the renamed element too. Note Avoid renaming an element by simply editing its name. For RTist in Code to understand that you want to rename an element, you need to use the approach described above.","title":"Text Editor"},{"location":"working-with-art/art-editor/#syntax-coloring","text":"RTist in Code provides color themes that have been specifically designed for being used for editing Art files. Activate one of these color themes from File - Preferences - Color Theme . Art Dark This is a dark theme that colorizes Art keywords, properties and comments. All embedded C++ code will be shown in gray color. This theme can be useful if you mostly edit C++ code snippets in generated files and propagate those changes back to the Art files automatically (see Making Changes in Generated C++ ). Showing C++ code in gray color makes it easier to see what parts you have to edit in the Art file, and what parts (i.e. the C++ code) that you can edit in generated files. Art Dark++ This is a dark theme that colorizes Art keywords, properties and comments. In addition it colorizes embedded C++ code using the same colors as are used for a C++ file. To help in separating Art from C++, all Art code uses a bold font, while C++ code uses a regular font. This theme can be useful if you prefer to edit both Art and C++ code in the Art file. Art Light This is a light theme that uses the same colors as Art Dark. Art Light++ This is a light theme that uses the same colors as Art Dark++.","title":"Syntax Coloring"},{"location":"working-with-art/art-editor/#content-assist","text":"This feature, which also is known as IntelliSense or Code Completion, helps you when editing an Art file by proposing commonly used Art constructs that are valid at the current cursor position. Invoke Content Assist by pressing Ctrl + Space . Depending on where the cursor is placed you will get different proposals to choose from. There are four kinds of proposals as shown in the picture below: Code Templates are complete Art elements, for example a capsule, protocol or state. The inserted code template often has variables that you should replace as you find appropriate. For example, the code template for a capsule contains one variable for the capsule name and another for the name of the state which its state machine contains. Press Tab to move forward from one variable to the next and if needed Shift + Tab to move backwards to a previous variable. Note that the same variable may occur in multiple places, like the State variable for the capsule code template which occurs both in the state definition and as a state reference in the initial transition. All occurrances of a variable are updated simultaneously when you replace the variable with a string. References are references to existing Art elements, for example a state, event or capsule. All Art elements of the correct kind which are visible from the cursor position will be available. References may have a qualifier if necessary, for example when referencing an entry point. Name represents an identifier used as the name of an Art element. It appears as a proposal at positions where the Art language allows a named element. Choosing this proposal just inserts the string \"name\" which probably is not so useful. However, the presence of a name item in the proposals list tells you that you can use an arbitrary identifier as the name of an Art element at that position. For example, in the proposals list shown in the picture above name appears since a triggered transition may have an optional name before its declaration. The code template for the triggered transition will not insert a name, since many transitions don't have names, but you can manually add it afterwards: MyTransition: State -> X on timer.timeout Keywords are keywords from the Art language that are valid to use at the cursor position. This also includes lexical tokens such as : or . where applicable. For example, after you have typed the name for the triggered transition shown above you can use Content Assist to learn that it may be followed by either a -> or : token:","title":"Content Assist"},{"location":"working-with-art/art-editor/#renaming-elements","text":"To rename an Art element place the cursor on the element's name and press F2 (or invoke the command Rename Symbol from the context menu). This performs a \"rename refactoring\" that updates all references to the renamed element too. Note Avoid renaming an element by simply editing its name. For RTist in Code to understand that you want to rename an element, you need to use the approach described above.","title":"Renaming Elements"},{"location":"working-with-art/diagrams/","text":"Art is a textual language but there is also a graphical notation for many parts of the language. You can therefore visualize (and to some extent also edit) some of the Art elements using graphical diagrams. The following diagrams can be used: State Diagram Shows the state machine of a capsule or class. A single diagram can show all states, pseudo states and transitions also for hierarchical state machines. Structure Diagram Shows the composite structure of a capsule. A single diagram can show all parts, ports and connectors also for hierarchical composite structures. Class Diagram Shows how capsules, classes and protocols are related by means of inheritance relationships. Also shows ports and parts of capsules and events of protocols. The picture below shows an example of what these diagrams may look like: Opening Diagrams To open a diagram from an Art file place the cursor inside an Art element. Bring up the context menu and invoke a command for opening a diagram for the Art element: Open State Diagram , Open Structure Diagram or Open Class Diagram . Note that all these three commands are always available, but if the selected Art element cannot be shown in the selected kind of diagram, you will get an error and no diagram will open. If the cursor is placed on an Art element that has a graphic representation in the form of a symbol or line in the diagram, for example a state in a state diagram, the symbol or line will be highlighted in the opened diagram by selecting it. You can use this feature as a way to navigate from an element in an Art file to the corresponding symbol or line in a diagram. If the diagram is already open, it will be made visible and the selection will be updated. You can also open diagrams from the context menu of an Art file in the Explorer view. In this case the Art file will be searched for an element that can be shown in the selected kind of diagram. If more than one such Art element is found, you will be prompted to pick the one to show in the diagram. For example: The same prompting happens if you open a diagram from an Art file when the cursor position doesn't indicate which Art element to open the diagram for. All valid Art elements in the file will be listed and you can choose which one to open the diagram for. Navigating from Diagram to Art File If you double-click a symbol or a line in a diagram, the Art element that corresponds to that symbol or line will be highlighted in the Art file. Note that you need to double-click on the symbol or line itself, and not on a text label shown in the symbol or on the line. However, as an alternative you can instead hold down the Ctrl key and then click on the text label. It will then become a hyperlink that navigates to the Art element that corresponds to that text label. You need to use this approach in case a symbol has multiple text labels each of which represent different Art elements. For example: In state diagrams you can also double-click on icons that are shown for transitions that contain effect and/or guard code. The presence of effect code is indicated by a blue icon, and guard code with a yellow icon. Double-clicking these icons will highlight the code snippets in the Art file. Working with Diagrams Zooming and Panning When a diagram is opened it is initially centered and with medium zoom level which makes all text labels big enough for reading. However, if the diagram is big then all contents may not be visible unless you zoom out. You can zoom the diagram using either the mouse scroll wheel or by means of the two-finger zoom gesture on a touch pad. You can also zoom using the buttons in the Properties view toolbar. There you will also find a Center button which will restore the diagram to its original zoom level. Alternatively you can use the command Fit to Screen which will set the zoom level so that the entire diagram fits the size of the diagram editor. Note that this command must be invoked from the general Command Palette or by means of the keyboard shortcut Ctrl + Shift + F . It's also possible to work with a big diagram without zooming, but instead panning the viewport so that a different part of the diagram becomes visible. To pan the viewport click anywhere on the diagram and drag while holding down the mouse button. Note that there are no limits to panning which means you can move the viewport as far away from the center of the diagram as you like. Use the Center or Fit to Screen command for panning back the viewport to its original position. Note that if a symbol or line is selected, the Center command will move the viewport so that the selected symbol or line appears in the middle. Collapsing and Expanding Symbols State and structure diagrams can be hierarchical. A state diagram is hierarchical if it contains a composite state with a nested state machine. A structure diagram is hierarchical if it contains a part typed by another capsule with nested parts. By default symbols that contain nested symbols are collapsed to minimize the size of the diagram: To expand a collapsed symbol click the yellow button. The symbol will then be resized to show the nested symbols. Click the button again to collapse the symbol and hide the nested symbols. You can use the Expand All and Collapse All buttons in the Properties view toolbar to expand or collapse all symbols so that the full hierarchical diagram becomes visible or hidden. Information about which symbols that are currently expanded will be remembered if you save the diagram. This information is stored in the file .vscode/art_diagram_settings.json . Invoking Diagram Commands from Keyboard Many diagram commands mentioned above can be invoked using the keyboard. Press Ctrl + Space in a diagram to open a pop-up menu from where you can invoke a diagram command. Diagram Appearance Certain properties on Art elements control how they will appear in a diagram. Currently it's possible to configure which color to use for elements of a state diagram. See the color property for more information. Diagram Filters To avoid cluttered diagrams with too many text labels, certain information is by default hidden. If you click in the background of the diagram, the Properties view will show various filters that you can turn on or off for showing or hiding such additional information. Here is an example of the filters available for a state diagram: Information about applied filters will be remembered if you save the diagram. This information is stored in the file .vscode/art_diagram_settings.json . You can also set diagram filters globally using configuration settings. Such filters will apply to all diagrams unless a more specific filter has been set on an individual diagram. You can find these configuration settings by filtering on rtistic.diagram in the Settings: Elements in the Properties View The Properties view can show additional Art elements when you select a symbol or a line. For example, it shows internal transitions of a state. Showing such elements in the diagram itself would risk making it cluttered, especially when there is a large number of elements. You can double-click the Art elements in the Properties view to highlight them in the Art file. For internal transitions the same blue and yellow dots are shown as for regular transitions in diagrams. Double-click the blue dot to navigate to the transition effect code and the yellow dot for navigating to the transition guard code. Renaming Elements You can rename an Art element shown in a diagram by double-clicking on the text label that shows its name. Alternatively select the symbol or line to which the text label belongs and press F2 . Note that this is a \"rename refactoring\" and all references to the renamed element will be updated too.","title":"Diagrams"},{"location":"working-with-art/diagrams/#opening-diagrams","text":"To open a diagram from an Art file place the cursor inside an Art element. Bring up the context menu and invoke a command for opening a diagram for the Art element: Open State Diagram , Open Structure Diagram or Open Class Diagram . Note that all these three commands are always available, but if the selected Art element cannot be shown in the selected kind of diagram, you will get an error and no diagram will open. If the cursor is placed on an Art element that has a graphic representation in the form of a symbol or line in the diagram, for example a state in a state diagram, the symbol or line will be highlighted in the opened diagram by selecting it. You can use this feature as a way to navigate from an element in an Art file to the corresponding symbol or line in a diagram. If the diagram is already open, it will be made visible and the selection will be updated. You can also open diagrams from the context menu of an Art file in the Explorer view. In this case the Art file will be searched for an element that can be shown in the selected kind of diagram. If more than one such Art element is found, you will be prompted to pick the one to show in the diagram. For example: The same prompting happens if you open a diagram from an Art file when the cursor position doesn't indicate which Art element to open the diagram for. All valid Art elements in the file will be listed and you can choose which one to open the diagram for.","title":"Opening Diagrams"},{"location":"working-with-art/diagrams/#navigating-from-diagram-to-art-file","text":"If you double-click a symbol or a line in a diagram, the Art element that corresponds to that symbol or line will be highlighted in the Art file. Note that you need to double-click on the symbol or line itself, and not on a text label shown in the symbol or on the line. However, as an alternative you can instead hold down the Ctrl key and then click on the text label. It will then become a hyperlink that navigates to the Art element that corresponds to that text label. You need to use this approach in case a symbol has multiple text labels each of which represent different Art elements. For example: In state diagrams you can also double-click on icons that are shown for transitions that contain effect and/or guard code. The presence of effect code is indicated by a blue icon, and guard code with a yellow icon. Double-clicking these icons will highlight the code snippets in the Art file.","title":"Navigating from Diagram to Art File"},{"location":"working-with-art/diagrams/#working-with-diagrams","text":"","title":"Working with Diagrams"},{"location":"working-with-art/diagrams/#zooming-and-panning","text":"When a diagram is opened it is initially centered and with medium zoom level which makes all text labels big enough for reading. However, if the diagram is big then all contents may not be visible unless you zoom out. You can zoom the diagram using either the mouse scroll wheel or by means of the two-finger zoom gesture on a touch pad. You can also zoom using the buttons in the Properties view toolbar. There you will also find a Center button which will restore the diagram to its original zoom level. Alternatively you can use the command Fit to Screen which will set the zoom level so that the entire diagram fits the size of the diagram editor. Note that this command must be invoked from the general Command Palette or by means of the keyboard shortcut Ctrl + Shift + F . It's also possible to work with a big diagram without zooming, but instead panning the viewport so that a different part of the diagram becomes visible. To pan the viewport click anywhere on the diagram and drag while holding down the mouse button. Note that there are no limits to panning which means you can move the viewport as far away from the center of the diagram as you like. Use the Center or Fit to Screen command for panning back the viewport to its original position. Note that if a symbol or line is selected, the Center command will move the viewport so that the selected symbol or line appears in the middle.","title":"Zooming and Panning"},{"location":"working-with-art/diagrams/#collapsing-and-expanding-symbols","text":"State and structure diagrams can be hierarchical. A state diagram is hierarchical if it contains a composite state with a nested state machine. A structure diagram is hierarchical if it contains a part typed by another capsule with nested parts. By default symbols that contain nested symbols are collapsed to minimize the size of the diagram: To expand a collapsed symbol click the yellow button. The symbol will then be resized to show the nested symbols. Click the button again to collapse the symbol and hide the nested symbols. You can use the Expand All and Collapse All buttons in the Properties view toolbar to expand or collapse all symbols so that the full hierarchical diagram becomes visible or hidden. Information about which symbols that are currently expanded will be remembered if you save the diagram. This information is stored in the file .vscode/art_diagram_settings.json .","title":"Collapsing and Expanding Symbols"},{"location":"working-with-art/diagrams/#invoking-diagram-commands-from-keyboard","text":"Many diagram commands mentioned above can be invoked using the keyboard. Press Ctrl + Space in a diagram to open a pop-up menu from where you can invoke a diagram command.","title":"Invoking Diagram Commands from Keyboard"},{"location":"working-with-art/diagrams/#diagram-appearance","text":"Certain properties on Art elements control how they will appear in a diagram. Currently it's possible to configure which color to use for elements of a state diagram. See the color property for more information.","title":"Diagram Appearance"},{"location":"working-with-art/diagrams/#diagram-filters","text":"To avoid cluttered diagrams with too many text labels, certain information is by default hidden. If you click in the background of the diagram, the Properties view will show various filters that you can turn on or off for showing or hiding such additional information. Here is an example of the filters available for a state diagram: Information about applied filters will be remembered if you save the diagram. This information is stored in the file .vscode/art_diagram_settings.json . You can also set diagram filters globally using configuration settings. Such filters will apply to all diagrams unless a more specific filter has been set on an individual diagram. You can find these configuration settings by filtering on rtistic.diagram in the Settings:","title":"Diagram Filters"},{"location":"working-with-art/diagrams/#elements-in-the-properties-view","text":"The Properties view can show additional Art elements when you select a symbol or a line. For example, it shows internal transitions of a state. Showing such elements in the diagram itself would risk making it cluttered, especially when there is a large number of elements. You can double-click the Art elements in the Properties view to highlight them in the Art file. For internal transitions the same blue and yellow dots are shown as for regular transitions in diagrams. Double-click the blue dot to navigate to the transition effect code and the yellow dot for navigating to the transition guard code.","title":"Elements in the Properties View"},{"location":"working-with-art/diagrams/#renaming-elements","text":"You can rename an Art element shown in a diagram by double-clicking on the text label that shows its name. Alternatively select the symbol or line to which the text label belongs and press F2 . Note that this is a \"rename refactoring\" and all references to the renamed element will be updated too.","title":"Renaming Elements"},{"location":"working-with-art/outline-view/","text":"The Outline view shows information about the Art elements that are defined in an Art file. You can see the most important information for each element, such as its name and other important properties. You can also see the containment hierarchy, i.e. which elements that contain other elements. Below is an example of what it can look like: You can use the Outline view for getting an overview of what elements an Art file contains, and for searching and navigating to elements. Navigating To navigate to an element in the Art file, double-click on the element in the Outline view. The cursor will be placed just before the element's name in the Art file (or where the name would be in case it has no name). You can also single-click on elements to just make the clicked element visible in the Art editor, without changing the cursor position. In this case the element is marked with a thin rectangle: If you hold down the Ctrl key when clicking, a new Art editor showing the same Art file will open to the side, in a new editor area to the right. The element will then be made visible and marked in that new editor. This can be useful if you don't want to change the original Art editor, for example when comparing two elements located in the same Art file. It's also possible to navigate in the other direction, i.e. from the Art editor to the Outline view. To do this, set the Outline view to follow the cursor: Now the Outline view will automatically highlight the element that corresponds to the cursor position in the Art editor. Searching You can use the Outline view when searching for one or many Art elements, as an alternative to searching textually in the Art editor. Start by selecting the element shown first in the Outline view, and then type quickly the first few characters of the element name. After every keystroke the selection will move downwards to an element with a name that matches the typed characters. If you make a brief pause, you can then start to type again to proceed searching further down in the Outline view. Another way to search is to press Ctrl + f when the Outline view has focus. A small popup will then appear where you can type a few characters. Nodes in the Outline view with a label that matches the typed characters will be highlighted. The matching allows additional characters between the typed characters which is why the typed string \"init\" also matches the transition Waiting -> Terminated : When the search has matched a few elements that look interesting you can press the Filter button next to the text field to filter the Outline view so it only shows the matching elements. This can avoid lots of scrolling if the matching elements are far apart.","title":"Outline View"},{"location":"working-with-art/outline-view/#navigating","text":"To navigate to an element in the Art file, double-click on the element in the Outline view. The cursor will be placed just before the element's name in the Art file (or where the name would be in case it has no name). You can also single-click on elements to just make the clicked element visible in the Art editor, without changing the cursor position. In this case the element is marked with a thin rectangle: If you hold down the Ctrl key when clicking, a new Art editor showing the same Art file will open to the side, in a new editor area to the right. The element will then be made visible and marked in that new editor. This can be useful if you don't want to change the original Art editor, for example when comparing two elements located in the same Art file. It's also possible to navigate in the other direction, i.e. from the Art editor to the Outline view. To do this, set the Outline view to follow the cursor: Now the Outline view will automatically highlight the element that corresponds to the cursor position in the Art editor.","title":"Navigating"},{"location":"working-with-art/outline-view/#searching","text":"You can use the Outline view when searching for one or many Art elements, as an alternative to searching textually in the Art editor. Start by selecting the element shown first in the Outline view, and then type quickly the first few characters of the element name. After every keystroke the selection will move downwards to an element with a name that matches the typed characters. If you make a brief pause, you can then start to type again to proceed searching further down in the Outline view. Another way to search is to press Ctrl + f when the Outline view has focus. A small popup will then appear where you can type a few characters. Nodes in the Outline view with a label that matches the typed characters will be highlighted. The matching allows additional characters between the typed characters which is why the typed string \"init\" also matches the transition Waiting -> Terminated : When the search has matched a few elements that look interesting you can press the Filter button next to the text field to filter the Outline view so it only shows the matching elements. This can avoid lots of scrolling if the matching elements are far apart.","title":"Searching"},{"location":"working-with-art/references/","text":"The References view shows how Art elements reference each other. Depending on what kind of reference you are interested in, there are different commands to use. Referencing Elements To find all elements that reference a certain Art element, right-click on the name of the Art element (it must have a name, otherwise it cannot be referenced) and perform the context menu command Find All References . The References view will in this case list all referencing elements, and group them by the Art file where they are located. For example, it could look like this if the command was invoked on a state. Double-click the items in the References view to navigate to the referencing element in the Art file. You can remove a referencing element from the view by clicking the Dismiss (x) button. This can for example be useful if you are going through a large list of references and want to remove those you have already examined to make the list more manageable. You can restore all referenced element to be shown again by pressing the Refresh button in the toolbar. An alternative way of finding and going through all referencing elements is to instead use the context menu command Go to References . This commands works the same as Find All References but will show the referencing elements inline in a popup in the Art editor instead of using the References view. Type Hierarchy To find how Art elements relate to each other in terms of inheritance, right click on the name of an Art element that can be inherited (i.e. a class, capsule or protocol) and perform the context menu command Show Type Hierarchy . The References view will show the subtypes or supertypes of the selected Art element. For example: Use the leftmost toolbar button to toggle between showing subtypes or supertypes. Double-click on items in the tree to navigate to a subtype or supertype. Note that an alternative to using the References view for looking at type hierarchies is to visualize them graphically using class diagrams (see Diagrams ).","title":"References View"},{"location":"working-with-art/references/#referencing-elements","text":"To find all elements that reference a certain Art element, right-click on the name of the Art element (it must have a name, otherwise it cannot be referenced) and perform the context menu command Find All References . The References view will in this case list all referencing elements, and group them by the Art file where they are located. For example, it could look like this if the command was invoked on a state. Double-click the items in the References view to navigate to the referencing element in the Art file. You can remove a referencing element from the view by clicking the Dismiss (x) button. This can for example be useful if you are going through a large list of references and want to remove those you have already examined to make the list more manageable. You can restore all referenced element to be shown again by pressing the Refresh button in the toolbar. An alternative way of finding and going through all referencing elements is to instead use the context menu command Go to References . This commands works the same as Find All References but will show the referencing elements inline in a popup in the Art editor instead of using the References view.","title":"Referencing Elements"},{"location":"working-with-art/references/#type-hierarchy","text":"To find how Art elements relate to each other in terms of inheritance, right click on the name of an Art element that can be inherited (i.e. a class, capsule or protocol) and perform the context menu command Show Type Hierarchy . The References view will show the subtypes or supertypes of the selected Art element. For example: Use the leftmost toolbar button to toggle between showing subtypes or supertypes. Double-click on items in the tree to navigate to a subtype or supertype. Note that an alternative to using the References view for looking at type hierarchies is to visualize them graphically using class diagrams (see Diagrams ).","title":"Type Hierarchy"}]}